<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>华为OD题库 | Felix's Footprint</title><meta name="author" content="Felix"><meta name="copyright" content="Felix"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1.最大化资源控制成本 查看代码测试                               公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决个任务混部问题: 有taskNum项任务，每个任务有开始时间 (startTime) ，结束时间(endTime)并行度(parallelism) 三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个">
<meta property="og:type" content="article">
<meta property="og:title" content="华为OD题库">
<meta property="og:url" content="https://www.felixshen.top/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/index.html">
<meta property="og:site_name" content="Felix&#39;s Footprint">
<meta property="og:description" content="1.最大化资源控制成本 查看代码测试                               公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决个任务混部问题: 有taskNum项任务，每个任务有开始时间 (startTime) ，结束时间(endTime)并行度(parallelism) 三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.felixshen.top/img/cover1.jpg">
<meta property="article:published_time" content="2023-05-23T13:43:18.000Z">
<meta property="article:modified_time" content="2023-06-08T06:21:07.165Z">
<meta property="article:author" content="Felix">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.felixshen.top/img/cover1.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202305241151839.png"><link rel="canonical" href="https://www.felixshen.top/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Felix","link":"链接: ","source":"来源: Felix's Footprint","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '华为OD题库',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-08 14:21:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4082146_34cixruws56.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202305221617001.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Felix's Footprint"><span class="site-name">Felix's Footprint</span></a></span><div id="menus"></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">华为OD题库</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-23T13:43:18.000Z" title="发表于 2023-05-23 21:43:18">2023-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-08T06:21:07.165Z" title="更新于 2023-06-08 14:21:07">2023-06-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="华为OD题库"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h3 id="1-最大化资源控制成本"><a href="#1-最大化资源控制成本" class="headerlink" title="1.最大化资源控制成本"></a>1.最大化资源控制成本</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决个任务混部问题: 有taskNum项任务，每个任务有开始时间 (startTime) ，结束时间(endTime)并行度(parallelism) 三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放(结束时刻不占用)。任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行请你计算完成这批任务混部最少需要多少服务器，从而最大最大化控制资源成本。<br><strong>输入描述:</strong><br>第一行输入为taskNum，表示有taskNum项任务接下来taskNum行，每行三个整数，表示每个任务的开始时间(startTime ) ，结束时间 (endTime ) ，并行度 (parallelism)<br><strong>输出描述:</strong><br>个整数，表示最少需要的服务器数量<br><strong>示例1</strong> 输入输出示例仅供调试，后台判断数据一般不包含示例输入<br>3<br>2 3 1<br>6 9 2<br>0 5 1<br><strong>输出</strong><br>2</p><p>说明共有三个任务，第一个任务在时间区间[2，3]运行，占用1个服务器，第二个任务在时间区间[6，9] 运行，占用2个服务器，第三个任务在时间区间[0，5]运行，占用1个服务器，需要最多服务器的时间区间为[2，3]和[6，9] ，需要2个服务器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];<span class="comment">//小顶堆,结束时间最早的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">task</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;task[i][<span class="number">0</span>]&gt;&gt;task[i][<span class="number">1</span>]&gt;&gt;task[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//priority_queue存放未完成的task</span></span><br><span class="line">    <span class="comment">//每次只需要比较堆顶的结束时间和当前任务的开始时间就可以得知当前任务是否可以加入</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务按照开始时间升序</span></span><br><span class="line">    <span class="built_in">sort</span>(task.<span class="built_in">begin</span>(),task.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> max_res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur_res=<span class="number">0</span>;<span class="comment">//优先队列里面的任务对应并发度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;task.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将结束时间小于当前任务开始时间的任务清空</span></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">top</span>()[<span class="number">0</span>]&lt;task[i][<span class="number">0</span>])&#123;</span><br><span class="line">                cur_res-=pq.<span class="built_in">top</span>()[<span class="number">1</span>];</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(vector&lt;<span class="type">int</span>&gt;&#123;task[i][<span class="number">1</span>],task[i][<span class="number">2</span>]&#125;);</span><br><span class="line">        cur_res+=task[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur_res&gt;max_res) max_res=cur_res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h3 id="2-完美走位"><a href="#2-完美走位" class="headerlink" title="2.完美走位"></a>2.完美走位</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>输入一个长度为4的倍数的字符串，字符串中仅包含WASD四个字母将这个字符串中的连续子串用同等长度的仅包含WASD的 字符串替换Q，如果替换后整个字符串中WASD四个字母出现的频数相同，那么我们称替换后的字符串是“完美走位”。求子串的最小长度。如果输入字符串已经平衡则输出0.<br><strong>二、输入</strong><br>一行字符表示给定的字符串s<br>数据范围:<br>1&lt;=n&lt;=10^5且n是4的倍数，字符串中仅包含WASD四个字母<br><strong>三、输出</strong><br>一个整数表示答案<br><strong>四、样例输入输出</strong><br>输入:<br>WASDAASD<br>输出:</p><p>1<br>说明:<br>将第二个A替换为W，即可得到完美走位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">滑动区间内为可自由变更的区间，若滑动区间的长度可以&gt;=最大值与各个字母的差</span></span><br><span class="line"><span class="comment">且二者的差值为4的整数倍，滑动区间满足</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char_count;</span><br><span class="line">    <span class="comment">//初始化不能省略</span></span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;S&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;D&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: str)</span><br><span class="line">    &#123;</span><br><span class="line">        char_count[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;A&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;S&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;D&#x27;</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//出现最多的字母</span></span><br><span class="line">    <span class="type">int</span> max_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空闲的字母数</span></span><br><span class="line">    <span class="type">int</span> surplus_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始时，滑动窗口的长度为1,滑动窗口外的相应字母--</span></span><br><span class="line">    char_count[str[<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;str.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要重新赋值，不然会保留最开始的最大值</span></span><br><span class="line">        max_char_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)&#123;</span><br><span class="line">            max_char_num=<span class="built_in">max</span>(max_char_num,x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;最大的字母数:&quot;&lt;&lt;max_char_num&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//滑动窗口的长度也是可自由分配字母的个数</span></span><br><span class="line">        length=right-left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//需要改变的字母数</span></span><br><span class="line">        <span class="type">int</span> required=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)</span><br><span class="line">        &#123;</span><br><span class="line">            required+=(max_char_num-x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;需要改变的字母数&quot;&lt;&lt;required&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;区间长度&quot;&lt;&lt;length&lt;&lt;&quot;,&quot;&lt;&lt;&quot;区间范围&quot;&lt;&lt;left&lt;&lt;&quot;,&quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        surplus_char_num=length-required;</span><br><span class="line">        <span class="comment">//区间满足，左指针左移</span></span><br><span class="line">        <span class="keyword">if</span>(surplus_char_num&gt;=<span class="number">0</span>&amp;&amp;surplus_char_num%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(length&lt;ans) ans=length;</span><br><span class="line">            char_count[str[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//区间不满足，右指针右移</span></span><br><span class="line">            <span class="comment">//右指针需要先右移</span></span><br><span class="line">            right++;</span><br><span class="line">            char_count[str[right]]--;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="3-羊、狼、农夫过河"><a href="#3-羊、狼、农夫过河" class="headerlink" title="3.羊、狼、农夫过河"></a>3.羊、狼、农夫过河</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。农夫有一艘容量固定的船，能够承载固定数量的动物。要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。<br>备注: 农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊农夫自身不占用船的容量。<br><strong>输入描述</strong><br>第一行输入为M，N，x，分别代表羊的数量，狼的数量，小船的容量.<br><strong>输出描述</strong><br>输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。(若无法满足条件则输出0)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> minTimes=INT_MAX;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transport</span><span class="params">(<span class="type">int</span> m0, <span class="type">int</span> n0, <span class="type">int</span> x, <span class="type">int</span> m1, <span class="type">int</span> n1, <span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=m0+n0)&#123;</span><br><span class="line">        <span class="keyword">if</span>(times+<span class="number">1</span>&lt;minTimes) minTimes=times+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层保证羊的数量小于容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m0 &amp;&amp; i&lt;=x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证羊+狼不超重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n0 &amp;&amp; i+j&lt;=x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证两岸的羊数量&gt;=狼(要么羊数量为0)</span></span><br><span class="line">            <span class="keyword">if</span>((m0-i==<span class="number">0</span>||m0-i&gt;n0-j)&amp;&amp;(m1+i==<span class="number">0</span>||m1+i&gt;n1+j))&#123;</span><br><span class="line">                <span class="built_in">transport</span>(m0-i,n0-j,x,m1+i,n1+j,times+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N,X;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;X;</span><br><span class="line">    <span class="built_in">transport</span>(M,N,X,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(minTimes==INT_MAX)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minTimes&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="4-字符串重新排列"><a href="#4-字符串重新排列" class="headerlink" title="4.字符串重新排列"></a>4.字符串重新排列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出</p><p>1、单词内部调整: 对每个单词字母重新按字典序排序<br>2、单词间顺序调整:<br>1)统计每个单词出现的次数，并按次数 降序排列Q<br>2)次数相同，按单词长度Q 升序排列<br>3)次数和单词长度均相同，按字典升序排列<br>请输出处理后的字符串，每个单词以一个空格分隔<br><strong>输入描述:</strong><br>一行字符串，每个字符取值范围:[a-ZA-z0-9] 以及空格，字符串长度范围:[1，1000]<br>例1:<br>输入<br>This is an apple<br>输出<br>an is This aelpp<br>例2:<br>输入:<br>My sister is in the house not in the yard<br>输出:<br>in in eht eht My is not adry ehosu eirsst</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a, pair&lt;string,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second!=b.second) <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.<span class="built_in">size</span>()!=b.first.<span class="built_in">size</span>()) <span class="keyword">return</span> a.first.<span class="built_in">size</span>()&lt;b.first.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pos = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="comment">//第一步，单词内部调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步，单词间调整</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; str_count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str_count.<span class="built_in">count</span>(v[i]))&#123;</span><br><span class="line">            str_count[v[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str_count[v[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">str_count_vec</span>(str_count.<span class="built_in">begin</span>(),str_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(str_count_vec.<span class="built_in">begin</span>(),str_count_vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : str_count_vec)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;item.second; i++) cout&lt;&lt;item.first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="5-租车骑绿岛"><a href="#5-租车骑绿岛" class="headerlink" title="5.租车骑绿岛"></a>5.租车骑绿岛</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，做最大载重M。给出部门每个人的体重，请问最多需要租用多少双人自行车</p><p><strong>输入描述:</strong><br>第一行两个数字m、n，分别代表自行车限重，部门总人数。第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。0&lt;me=200<br>0&lt;n&lt;=1000000<br><strong>输出描述:</strong><br>最小需要的双人自行车数量。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>34<br>3 2 2 1<br>输出</p><p>3</p><p><strong>思路</strong>：这个问题可以通过贪心算法来解决。首先，将所有人的体重从小到大排序。然后，从最轻的人开始，每次选择最轻的人和最重的人搭配在一起。如果两个人的体重之和不超过自行车的限重，则他们可以共用一辆自行车；否则，最重的人需要单独使用一辆自行车。重复这个过程，直到所有人都被安排好。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min_bikes</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> weights[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + n);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bikes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weights[left] + weights[right] &lt;= m) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bikes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> weights[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min_bikes</span>(m, n, weights) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="6-无向图染色"><a href="#6-无向图染色" class="headerlink" title="6.无向图染色"></a>6.无向图染色</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给一个无向图Q 染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方案?<br><strong>输入描述:</strong><br>第一行输入M(图中节点数) N(边数)<br>后续N行格式为: V1 V2表示一个V1到V2的边<br>数据范围: 1 &lt;= M &lt;= 15.0 &lt;= N &lt;= M3，不能保证所有节点都是连通的</p><p><strong>输出描述:</strong><br>输出一个数字表示染色方案的个数<br>示例1:<br>输入:<br>4 4<br>1 2<br>2 4<br>3 4<br>1 3<br><strong>输出:</strong></p><p>7<br>说明: 4个节点，4条边，1号节点和2号节点相连，2号节点和4号节点相连，3号节点和4号节点相连，1号节点和3号节点相连，若想必须保证相邻两个节点不能同时为红色，总共7种方案。</p><p><strong>思路</strong>：遍历所有的染色方案，再逐一判断每条边的两边是否都是红色</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//存入结点时，以0号结点开头</span></span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;a<span class="number">-1</span>,b<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0101表示0号结点为黑，1号结点为红，2号结点为黑，3号结点为红</span></span><br><span class="line"><span class="comment">    从右边往左边分别是0,1,2,3</span></span><br><span class="line"><span class="comment">    为了取得相应结点的颜色，需要右移0,1,2,3位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;m); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//检测所有边的两端</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: edges)&#123;</span><br><span class="line">            <span class="type">int</span> node1=i&gt;&gt;edge.first;</span><br><span class="line">            <span class="type">int</span> node2=i&gt;&gt;edge.second;</span><br><span class="line">            <span class="keyword">if</span>((node1&amp;<span class="number">1</span>) &amp;&amp; (node2&amp;<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="7-单向链表中间节点"><a href="#7-单向链表中间节点" class="headerlink" title="7.单向链表中间节点"></a>7.单向链表中间节点</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>求单向链表Q 中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。</p><p><strong>输入描述:</strong><br>第一行 链表头节点地址path 后续输入的节点数n后续输入每行表示一个节点，格式:”节点地址 节点值 下一个节点地址(-1表示空指针“输入保证链表不会出现环，并且可能存在一些节点不属于链表输出描述:<br>链表中间节点值。<br>测试用例:<br><strong>输入:</strong><br>00010 4<br>00000 3 -1<br>00010 5 12309<br>11451 6 00000<br>12309 7 11451<br>输出:<br>6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; node_value;</span><br><span class="line">    map&lt;string,string&gt; node_node;</span><br><span class="line">    string head;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;head&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string start,end;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin&gt;&gt;start&gt;&gt;val&gt;&gt;end;</span><br><span class="line">        node_value[start]=val;</span><br><span class="line">        node_node[start]=end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍求长度</span></span><br><span class="line">    string tmp=head;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(node_node[tmp]!=<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;node_value[tmp]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="8-划分为k个相等的子集"><a href="#8-划分为k个相等的子集" class="headerlink" title="8.划分为k个相等的子集"></a>8.划分为k个相等的子集</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给定一个整数数组  <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>思路一：动态规划</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / k;</span><br><span class="line">    <span class="comment">//dp压缩状态，dp[i]表示状态i下是否可以划分为x个target</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举每一种状态，并由当前状态推导出后面的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>()); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第j位是否为1,即是否已经使用</span></span><br><span class="line">            <span class="type">int</span> flag=i&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;dp[i]+nums[j]&lt;=target)&#123;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=(dp[i]+nums[j])%target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>())<span class="number">-1</span>]==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二：回溯法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum%k!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target=sum/k;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,bucket,k,target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt;&amp; bucket, <span class="type">int</span> k, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//每个球有k个选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;bucket[i]==bucket[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]+nums[index]&gt;target) <span class="keyword">continue</span>;</span><br><span class="line">        bucket[i]+=nums[index];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">backtrack</span>(nums,index+<span class="number">1</span>,bucket,k,target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        bucket[i]-=nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="9-最多颜色的车"><a href="#9-最多颜色的车" class="headerlink" title="9.最多颜色的车"></a>9.最多颜色的车</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>在一个狭小的路口，每秒只能通过一辆车，假好车辆的颜色只有 3 种，找出N 秒内经过的最多颜色的车辆数量。<br>三种颜色编号为0，1，2<br><strong>输入描述</strong><br>第一行输入的是通过的车辆颜色信息<br>[0,1,1,2]代表4 秒钟通过的车辆颜色分别是 0，1，1，2</p><p>第二行输入的是统计时间窗，整型，单位为秒输出描述<br>输出指定时间窗内经过的最多颜色的车辆数量<br>样例<br>样例一:<br>输入<br>0 1 2 1<br>3<br>输出<br>2<br>样例解释<br>在 3 秒时间窗内，每个颜色最多出现 2 次。例为: [1,2,1]<br>样例二:<br>输入<br>0 1 2 1<br>2<br>输出</p><p>1<br>样例解释<br>在 2 秒时间窗内，每个颜色最多出现1 次</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="type">int</span> window;</span><br><span class="line">    cin&gt;&gt;window;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cars;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> found=input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,found)));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(found+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="comment">//初始化滑动窗口</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; car_count=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;window; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滑动窗口滑动</span></span><br><span class="line">    <span class="type">int</span> max_res=*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=window; i&lt;cars.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]++;</span><br><span class="line">        car_count[cars[i-window]]--;</span><br><span class="line">        max_res=<span class="built_in">max</span>(max_res,*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="10-不含101的数"><a href="#10-不含101的数" class="headerlink" title="10.不含101的数"></a>10.不含101的数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>小明在学习二进制时，发现了一类不含 101的数，也就是：将数字用二进制表示，不能出现 101 。现在给定一个整数区间 [l,r] ，请问这个区间包含了多少个不含 101 的数？</p><p><strong>输入描述</strong></p><p>输入的唯一一行包含两个正整数 l， r（ 1 ≤ l ≤ r ≤ 10^9）。</p><p><strong>输出描述</strong></p><p>输出的唯一一行包含一个整数，表示在 [l,r] 区间内一共有几个不含 101 的数。</p><p><strong>样例一：</strong></p><p><strong>输入</strong></p><p>1 10</p><p><strong>输出</strong></p><p>8</p><p>样例解释：区间 [1,10] 内， 5 的二进制表示为 101 ，10的二进制表示为 1010 ，因此区间 [ 1 , 10 ] 内有 10−2=8个不含 101的数。</p><p>思路一：暴力法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;64&gt; <span class="title">bit</span><span class="params">(num)</span></span>;</span><br><span class="line">    string bin=bit.<span class="built_in">to_string</span>();</span><br><span class="line">    cout&lt;&lt;bin&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(bin.<span class="built_in">find</span>(<span class="string">&quot;101&quot;</span>)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValid</span>(i))&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：数位dp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> p, <span class="type">bool</span> flag, vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; binary_dp, vector&lt;<span class="type">int</span>&gt; single_binary_nums, <span class="type">int</span> pre, <span class="type">int</span> prepre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == single_binary_nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag &amp;&amp; binary_dp[p][pre][prepre] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> binary_dp[p][pre][prepre];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = flag ? single_binary_nums[p] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; pre == <span class="number">0</span> &amp;&amp; prepre == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="built_in">search</span>(p + <span class="number">1</span>, flag &amp;&amp; i == index, binary_dp, single_binary_nums, i, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        binary_dp[p][pre][prepre] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 10 -&gt; [1,0,1,0,0]</span></span><br><span class="line">    bitset&lt;20&gt; number;</span><br><span class="line">    number = num;</span><br><span class="line">    string number_str=number.<span class="built_in">to_string</span>(); </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">single_binary_nums</span><span class="params">(number_str.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;number_str.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        single_binary_nums[i] = (<span class="type">int</span>)number_str[i]<span class="number">-48</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">binary_dp</span>(single_binary_nums.<span class="built_in">size</span>(), vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(<span class="number">0</span>, <span class="literal">true</span>, binary_dp, single_binary_nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> left, right;</span><br><span class="line">    cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(right)-<span class="built_in">dp</span>(left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="11-过滤组合字符串"><a href="#11-过滤组合字符串" class="headerlink" title="11.过滤组合字符串"></a>11.过滤组合字符串</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母<br>0关联”a””b””c”<br>1关联”d”,”e”,”?<br>2关联”g”,”h”””<br>3 关联”,”k”,””<br>4 关联”m””n””o”<br>5关联”p”,”q”””<br>6关联”s”,”t”<br>7 关联”u””v”<br>8关联”w””x”<br>9关联”y”,”z”<br>例如7关联”u””v”，8关联”x””w”，输入一个字符串例如“78”和一个屏蔽字符串“ux”,那么“78”可以组成多个字符串例如:“ux”，“uw”“vx”，“ww”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。<br>示例:<br>输入:<br>78<br>ux<br>输出:<br>uw vx vw<br>说明: ux完全包含屏蔽字符串ux，因此别除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">//0</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>,<span class="comment">//1</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,<span class="comment">//2</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,<span class="comment">//3</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,<span class="comment">//4</span></span><br><span class="line">    <span class="string">&quot;pqr&quot;</span>,<span class="comment">//5</span></span><br><span class="line">    <span class="string">&quot;st&quot;</span>,<span class="comment">//6</span></span><br><span class="line">    <span class="string">&quot;uv&quot;</span>,<span class="comment">//7</span></span><br><span class="line">    <span class="string">&quot;wx&quot;</span>,<span class="comment">//8</span></span><br><span class="line">    <span class="string">&quot;yz&quot;</span>,<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, string&amp; digits, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> digit = digits[index]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    string letters = letterMap[digit];<span class="comment">//取数字对应字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;letters.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(index+<span class="number">1</span>,digits,s+letters[i]);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符是否全部包含</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string str1, string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str1)</span><br><span class="line">    &#123;</span><br><span class="line">        set1.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str2)</span><br><span class="line">    &#123;</span><br><span class="line">        set2.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: set2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.<span class="built_in">count</span>(x)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string digits;</span><br><span class="line">    string filter;</span><br><span class="line">    cin&gt;&gt;digits&gt;&gt;filter;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,digits,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    string result_str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(filter,x))&#123;</span><br><span class="line">            result_str+=(x+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result_str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="12-真正的密码"><a href="#12-真正的密码" class="headerlink" title="12.真正的密码"></a>12.真正的密码</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>在一行中输入一个字符串数组Q，如果其中一个字符串的所有以索引0开头的子串在数组中都有，那么这个字符串就是潜在密码，在所有潜在密码中最长的是真正的密码，如果有多个长度相同的真正的密码，那么取字典序最大的为唯一的真正的密码，求唯一的真正的密码</p><p>示例1:<br>输入: h he hel hell hello o ok n ni nin ninj ninjaQ<br>输出: ninja说明:按要求，hello、ok、ninja都是潜在密码。检查长度，hello、ninja是真正的密码。检查字典序Q，ninja是唯一真正密码。<br>示例2:<br>输入:<br>a b c d f<br>输出:<br>说明: 按要求，a b c d f都是潜在密码。检查长度，a b c d f 是真正的密码。检查字典序，f是唯一真正密码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有字符串放入哈希集合</span></span><br><span class="line">    set&lt;string&gt; word_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        word_set.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的密码</span></span><br><span class="line">    string true_pass_word=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序检查每一个词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        <span class="comment">// 条件1：检查这个词所有以索引0开头的子串在数组中是否都有</span></span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 以索引0开头的子串</span></span><br><span class="line">            string sub_str=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(!word_set.<span class="built_in">count</span>(sub_str))&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">// 条件2：比较密码长度</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;true_pass_word.<span class="built_in">size</span>())</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            <span class="comment">// 条件3：比较密码字典排序</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()==true_pass_word.<span class="built_in">size</span>()&amp;&amp; s&gt;true_pass_word)&#123;</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; true_pass_word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="13-最小调整顺序次数"><a href="#13-最小调整顺序次数" class="headerlink" title="13.最小调整顺序次数"></a>13.最小调整顺序次数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_number;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_number);</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">stoi</span>(input_number);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; operations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>*number;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        operations.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否有序</span></span><br><span class="line">    <span class="type">bool</span> in_order = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;string&gt; operaion_str = operations[i];</span><br><span class="line">        <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;head&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size &gt; <span class="number">0</span> &amp;&amp; in_order) &#123;</span><br><span class="line">                in_order = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;tail&quot;</span>) &#123;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_order) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                in_order = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="14-星球移居计划-n"><a href="#14-星球移居计划-n" class="headerlink" title="14.星球移居计划-n"></a>14.星球移居计划-n</h2><h2 id="15-需要打开多少监视器-n"><a href="#15-需要打开多少监视器-n" class="headerlink" title="15.需要打开多少监视器-n"></a>15.需要打开多少监视器-n</h2><h2 id="16-最佳种树距离-n"><a href="#16-最佳种树距离-n" class="headerlink" title="16.最佳种树距离-n"></a>16.最佳种树距离-n</h2><h2 id="17-阿里巴巴寻宝盒-n"><a href="#17-阿里巴巴寻宝盒-n" class="headerlink" title="17.阿里巴巴寻宝盒-n"></a>17.阿里巴巴寻宝盒-n</h2><h2 id="18-选修课-n"><a href="#18-选修课-n" class="headerlink" title="18.选修课-n"></a>18.选修课-n</h2><h2 id="19-探索地块建立"><a href="#19-探索地块建立" class="headerlink" title="19.探索地块建立"></a>19.探索地块建立</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给一块n<em>m的地块，相当于n</em>m的二维数组，每个元素的值表示这个小地块的发电量;求在这块地上建立正方形的边长为c的发电站，发电量满足目标电量k的地块数量。输入描述:<br>第一行为四个按空格分隔的正整数，分别表示n,m,c k后面n行整数，表示每个地块的发电量输出描述:<br>输出满足条件的地块数量<br>示例:<br>输入:<br>2 5 2 6 // n m ck，下面每行是nm地块每格的发电量<br>1 3 4 5 8<br>2 3 6 7 1<br>输出:<br>4<br>说明:<br>满足条件的地块有以下几种<br>第一种:<br>1 3<br>2 3<br>第二种:<br>3 4<br>3 6<br>第三种:<br>4 5<br>6 7<br>第四种:<br>5 8<br>7 1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;P,<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P[x2][y2]-P[x1<span class="number">-1</span>][y2]-P[x2][y1<span class="number">-1</span>]+P[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_area_count</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> threshold, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//1、生成前缀和子矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="comment">//s[i][j]表示以[i,j]作为矩阵最右下角的最大矩阵的前缀和</span></span><br><span class="line">            <span class="comment">//解释：以点[i,j]作为作为最右下角的最大矩阵的前缀和需要加上点[i-1,j]和点[i,j-1]的前缀和，然而会重复多加一个点[i-1][j-1]的前缀和，所以要减一个</span></span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2、遍历前缀和矩阵，获得边长等于c的矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-c+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m-c+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getRect</span>(s,i,j,i+c<span class="number">-1</span>,j+c<span class="number">-1</span>)&gt;=threshold) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> c = params[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        matrix.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_area_count</span>(matrix, k, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="20-模拟商场优惠打折"><a href="#20-模拟商场优惠打折" class="headerlink" title="20.模拟商场优惠打折"></a>20.模拟商场优惠打折</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>模拟商场优惠打折，有三种 优惠券Q 可以用，满减券、打折券和无门槛券满减券: 满100减10，满200减20，满300减30，满400减40，以此类推不限制使用;打折券: 固定折扣92折，且打折之后向下取整Q，每次购物只能用1次:无门槛券: 一张券减5元，没有使用限制;<br>每个人结账使用优惠券时有以下限制: 每人每次只能用两种优惠券，并且同一种优惠券必须一次用完，不能跟别的穿插使用(比如用一张满减，再用一张打折，再用一张满减，这种顺序<br>不行)求不同使用顺序下每个人用完券之后得到的最低价格和对应使用优惠券的总数:如果两种顺序得到的价格一样低，就取使用优惠券数量较少的那个。输入描述:<br>第一行三个数字m,n,k，分别表示每个人可以使用的满减券、打折券和无门槛券的数量第二行一个数字x,表示有几个人购物<br>后面x行数字，依次表示是这几个人打折之前的商品总价输出描述:<br>输出每个人使用券之后的最低价格和对应使用优惠券的数量示例:<br>输入:<br>3 2 5<br>3<br>100<br>200<br>400<br>输出:<br>65 6<br>135 8<br>275 8</p><p>说明</p><p>第一个人使用 1 张满减券和5张无门槛券价格最低</p><p>第二个人使用 3 张满减券和5张无门槛券价格最低</p><p>第三个人使用 3 张满减券和5张无门槛券价格最低</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后打折</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_a</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后满减</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_b</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_c</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>; </span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_d</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first == b.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string input_params_x;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params_x);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">stoi</span>(input_params_x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> price = <span class="built_in">stoi</span>(input_str);</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_a</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_b</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_c</span>(price, m, k));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_d</span>(price, n, k));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照价格降序，用券数降序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), comp);</span><br><span class="line">        cout &lt;&lt; result[<span class="number">0</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; result[<span class="number">0</span>].second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="21-区间覆盖"><a href="#21-区间覆盖" class="headerlink" title="21.区间覆盖"></a>21.区间覆盖</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给定坐标轴上的一组线段，线段的起点和终点均为整数并且长度不小于1，请你从中找到最少数量的线段，这些线段可以覆盖住所有线段。<br>输入描述<br>第一行输入为所有线段的数量，不超过10000，后面每行表示一条线段，格式为”x,y”x和y 分别表示起点和终点，取值范围是[-10^5，10^5]。输出描述<br>最少线段数量，为正整数。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>1,4<br>2,5<br>3,6<br>输出</p><p>2</p><p>思路<a target="_blank" rel="noopener" href="https://www.programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%96%B9%E6%B3%95%E4%B8%80">代码随想录</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按左端点从小到大排 ,左端点相同，右端点大的在前面</span></span><br><span class="line">    <span class="keyword">if</span>(x.first!=y.first)</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;       </span><br><span class="line">    <span class="keyword">return</span> x.second&gt;y.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; range;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    range.first = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">    range.second = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="type">int</span> destiny=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        cin &gt;&gt; input_str;</span><br><span class="line">        destiny=<span class="built_in">max</span>(destiny,<span class="built_in">split</span>(input_str).second);</span><br><span class="line">        ranges.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp); </span><br><span class="line">    <span class="type">int</span> curDistance=ranges[<span class="number">0</span>].second;<span class="comment">//当前覆盖最远距离</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextDistance=ranges[<span class="number">0</span>].second;<span class="comment">//下一步覆盖最远距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(ranges[i].first&lt;=curDistance)&#123;</span><br><span class="line">           nextDistance=<span class="built_in">max</span>(nextDistance,ranges[i].second);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           i--;</span><br><span class="line">           ans++;</span><br><span class="line">           curDistance=nextDistance;</span><br><span class="line">           <span class="keyword">if</span>(nextDistance==destiny) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curDistance!=destiny) ans++;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="22-二元组个数"><a href="#22-二元组个数" class="headerlink" title="22.二元组个数"></a>22.二元组个数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>给定两个数组Qa，b，若l == ] 则称[,] 为一个二元组，求在给定的两个数组中，二元组的个数。输入描述:<br>第一行输入 m<br>第二行输入m个数，表示第一个数组<br>第三行输入 n<br>第四行输入n个数，表示第二个数组<br>输出描述:<br>二元组Q个数。<br>示例1:<br>输入:<br>d<br>1 2 34<br>输出:<br>说明: 二元组个数为 1个<br>示例2:<br>输入:<br>6<br>1 1 2 2 4 5<br>3<br>2 2 4<br>输出:<br>5<br>说明:二元组个数为 5 个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_a;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_a_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        nums_a.<span class="built_in">push_back</span>(a);</span><br><span class="line">        nums_a_count[a] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_b;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_b_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        nums_b.<span class="built_in">push_back</span>(b);</span><br><span class="line">        nums_b_count[b] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums_a_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums_b_count.<span class="built_in">count</span>(x.first)) &#123;</span><br><span class="line">            result += x.second * nums_b_count[x.first];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="23-连接器问题"><a href="#23-连接器问题" class="headerlink" title="23.连接器问题"></a>23.连接器问题</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>有一组区间[a0，b0]，[a1，b1]，… (a，b表示起点，终点) ，区间有可能重叠、相邻，重叠或相邻则可以合并为更大的区间;给定一组连接器[x1，x2，x3，…] (x表示连接器的最大可连接长度，即x&gt;=gapQ)，可用于将分离的区间连接起来，但两个分离区间之间只能使用1个连接器请编程实现使用连接器后，最少的区间数结果。<br>区间数量&lt;10000，ab均 &lt;=10000<br>连接器梳理&lt;10000; x &lt;= 10000<br>输入描述<br>区间组: [1,10],[15,201,[18,30],[33,40]</p><p>连接器组: [5,4,3,2]<br>输出描述</p><p>1<br>说明:<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。示例1 输入输出示例仅供调试，后台判题数据一般不包含示例入<br>[1,10],[15,20],[18,30],[33,40]<br>[5,4, 3, 2]<br>输出</p><p>1<br>说明<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    string range_str;</span><br><span class="line">    cin &gt;&gt; range_str;</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp_ranges = <span class="built_in">split</span>(range_str);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp_ranges.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; single_range;</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i<span class="number">-1</span>]);</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i]);</span><br><span class="line">            ranges.<span class="built_in">push_back</span>(single_range);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string conntetor_str;</span><br><span class="line">    cin &gt;&gt; conntetor_str;</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; connectors = <span class="built_in">split</span>(conntetor_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并区间</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merge_ranges;</span><br><span class="line">    merge_ranges.<span class="built_in">push_back</span>(ranges[<span class="number">0</span>]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; range_diffs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range1 = merge_ranges[merge_ranges.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range2 = ranges[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (range2[<span class="number">0</span>] &lt;= range1[<span class="number">1</span>]) &#123;</span><br><span class="line">            merge_ranges.<span class="built_in">pop_back</span>();</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;range1[<span class="number">0</span>], <span class="built_in">max</span>(range1[<span class="number">1</span>], range2[<span class="number">1</span>])&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            range_diffs.<span class="built_in">push_back</span>(range2[<span class="number">0</span>] - range1[<span class="number">1</span>]);</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(range2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range_diffs.<span class="built_in">begin</span>(), range_diffs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(connectors.<span class="built_in">begin</span>(), connectors.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = merge_ranges.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connectors.<span class="built_in">size</span>()&amp;&amp;idx&lt;range_diffs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectors[i] &gt;= range_diffs[idx]) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            result--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="24-打印机队列"><a href="#24-打印机队列" class="headerlink" title="24.打印机队列"></a>24.打印机队列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>有5台打印机打印文件，每台打印机有自己的待打印队列。因为打印的文件内容有轻重缓急之分，<br>所以队列中的文件有1~10不同的代先级，其中数宁越大优先级越高打印机会从自己的待打印队列中选择优先级最高的文件来打印。如果存在两个优先级一样的文件，则选择最早进入队列的那个文件现在请你来模拟这5台打印机的打印过程。<br>输入描述<br>每个输入包含1个测试用例，每个测试用例第一行给出发生事件的数量N (0 &lt; N&lt; 1000)。<br>接下来有 N 行，分别表示发生的事件。<br>共有如下两种事件:<br>1.“IN P NUM”，表示有一个拥有优先级 NUM 的文件放到了打印机 P 的待打印队列中。 (0&lt; P&lt;= 5, 0&lt; NUM &lt;= 10);<br>2.“OUT P”，表示打印机 P 进行了一次文件打印，同时该文件从待打印队列中取出。 (0&lt; P&lt;=57<br>输出描述<br>对于每个测试用例，每次”OUT P”事件，请在一行中输出文件的编号如果此时没有文件可以打印，请输出”NULL“。文件的编号定义为”IN P NUM”事件发生第 次，此处待打印文件的编号为x。编号从1开始.示例1 输入输出示例仅供调试，后台判断数据一般不包含示例<br>输入</p><p>7<br>IN 1 1<br>IN 1 2<br>IN 1 3<br>IN 2 1<br>OUT 1<br>OUT 2<br>OUT 2<br>输出</p><p>3</p><p>4</p><p>NULL</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(File a, File b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.priority-a.priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_count_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_count_str);</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">stoi</span>(input_count_str);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;File&gt;&gt; <span class="built_in">printers</span>(<span class="number">5</span>, <span class="built_in">vector</span>&lt;File&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        string temp_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,temp_str);</span><br><span class="line">        vector&lt;string&gt; operations = <span class="built_in">split</span>(temp_str);</span><br><span class="line">        string type = operations[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;IN&quot;</span> == type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">stoi</span>(operations[<span class="number">2</span>]);</span><br><span class="line">            flag++;</span><br><span class="line">            File file;</span><br><span class="line">            file.order = flag;</span><br><span class="line">            file.priority = num;</span><br><span class="line">            printers[p - <span class="number">1</span>].<span class="built_in">push_back</span>(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;OUT&quot;</span>==type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (printers[p<span class="number">-1</span>].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>(), printers[p<span class="number">-1</span>].<span class="built_in">end</span>(), comp);</span><br><span class="line">                File file = printers[p<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                cout&lt;&lt;file.order&lt;&lt;endl;</span><br><span class="line">                printers[p<span class="number">-1</span>].<span class="built_in">erase</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="25-处理器问题"><a href="#25-处理器问题" class="headerlink" title="25.处理器问题"></a>25.处理器问题</h2><h2 id="26-日志首次上报最多积分"><a href="#26-日志首次上报最多积分" class="headerlink" title="26.日志首次上报最多积分"></a>26.日志首次上报最多积分</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。如果上报太频繁，会对服务端造成压力;如果上报太晚，会降低用户的体验,如果一次上报的条数太多，会导致超时失败。为此，项目组设计了如下的上报策略<br>1、每成功上报一条日志，奖励1分<br>2、每条日志每延迟上报1秒，扣1分3、积累日志达到100条，必须立即上报给出日志序列，根据该规则，计算首次上报能获得的最多积分数输入描述:<br>按时序产生的日志条数 T1,T2…Tn，其中 1&lt;=n&lt;=1000，0&lt;=Ti&lt;=100输出描述:<br>首次上报最多能获得的积分数<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>1 98 1<br>输出<br>98<br>说明:<br>T1 时刻上报得 1 分<br>T2 时刻上报得98分，最大<br>T3 时刻上报得 0分<br>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>3 7 40 10 60<br>输出</p><p>37<br>说明:<br>T1 时刻上报得 3 分<br>T2 时刻上报得 7 分<br>T3 时刻上报得 37 分，最大<br>T4 时刻上报得 -3 分<br>T5 时刻上报，因为已经超了100条的限制，所以只能上报100条，得 -23 分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; logs;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        logs.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    logs.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加分</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plus_score</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    plus_score[<span class="number">0</span>] = logs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减分</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minus_score</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = logs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        plus_score[i] = <span class="built_in">min</span>(<span class="number">100</span>, plus_score[i - <span class="number">1</span>] + logs[i]);</span><br><span class="line">        minus_score[i] = minus_score[i - <span class="number">1</span>] + plus_score[i - <span class="number">1</span>];</span><br><span class="line">        result[i] = plus_score[i] - minus_score[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (plus_score[i] &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_score = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &gt; max_score) &#123;</span><br><span class="line">            max_score = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="27-简单的曝光"><a href="#27-简单的曝光" class="headerlink" title="27.简单的曝光"></a>27.简单的曝光</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>一个图像有n个像素点，存储在一个长度为n的数组img里，每个像素点的取值范围[0,255]的正整数。清你给图像每个像素点值加上一个整数k(可以是负数》，得到新图newImg，使得新图newImg的所有像素平均值最接近中位值128。请输出这个整数k。<br>输入描述<br>n个整数，中间用空格分开<br>例如<br>0 0 0 0<br>4个数值，中间用空格分开<br>输出描述<br>个整数k<br>补充说明<br>1&lt;=n&lt;= 100<br>·如有多个整数k都满足，输出小的那个k;新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0; 当新像素值>255其值会更改为255;<br>例如newlmg=”-1 -2 256”会自动更改为”0 0 255”<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>0 0 0 0<br>输出<br>128</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str, string op)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(op) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(op);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(input_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> min_diff = <span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-127</span>; i &lt;= <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="comment">// 注意项3</span></span><br><span class="line">            sum += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(nums[j] + i, <span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//靠近中位数的程度</span></span><br><span class="line">        <span class="type">double</span> diff = <span class="built_in">abs</span>(sum / nums.<span class="built_in">size</span>() - <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; min_diff) &#123;</span><br><span class="line">            min_diff = diff;</span><br><span class="line">            result = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff == min_diff &amp;&amp; result != <span class="number">-256</span>) &#123;</span><br><span class="line">            <span class="comment">//注意项2</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="27-最大版本号"><a href="#27-最大版本号" class="headerlink" title="27.最大版本号"></a>27.最大版本号</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>Maven 版本号定义，&lt;主版本&gt;.&lt;次版本&gt;.增量版本&gt;-&lt;里程碑版本举例3.1.4-beta 其中，主版本和次版本都是必须的，主版本，次版本，增量版本由多位数字组成，可能包含前导零，里程碑版本由字符串组成</p><p>&lt;主版本&gt;.&lt;次版本&gt;增量版本&gt;: 基于数字比较</p><p>比较里程碑版本: 基于宁符串比较</p><p>采用字典典序比较版本号时，按从左到右的顺序依次比较。基于数字比较只需比较忽略任何前导零后的整数值</p><p>输入2个版本号</p><p>输出最大版本号<br>输入描述:<br>输入两个版本号，按行分割，每个版本号的长度小于50</p><p>输出描述:<br>输出较大的版本号<br>示例1:<br>输入:<br>2.5.1-0<br>1.4.2-D<br>输出:<br>2.5.1-0</p>
              </div>
            </details>
<h2 id="28-二进制差异数"><a href="#28-二进制差异数" class="headerlink" title="28.二进制差异数"></a>28.二进制差异数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>对于任意两个正整数A和B，定义它们之间的差异值和相似值:差异值:A、B转换成二进制后，对于二进制的每一位，对应位置的bit值不相同则为1，否则为<br>0:<br>相似值: A、B转换成二进制后，对于二进制的每一位，对应位置的bit值都为1则为1，否则为0:<br>现在有n个正整数A0到A (n-1)，问有多少(i,j)0&lt;=i&lt;j&lt;n) ，Ai和Aj的差异值大于相似值.假设A=5，B=3;则A的二进制表示101;B的二进制表示011;则A与B的差异值二进制为110;<br>相似值二进制为001;<br>A与B的差异值十进制等于6，相似值十进制等于1，满足条件。输入描述</p><p>输入个n</p><p>接下来n个正整数数据范围: 1&lt;=n&lt;=10^5，1&lt;=A[i]&lt;2^30输出描述<br>输出<br>满足差异值大于相似值的对数<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>4<br>4 3 5 2<br>输出<br>4<br>说明<br>样例1解释<br>满足条件的分别是(0,1)(0,3)(1,2)(2,3)，共4对</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPairsWithDifference</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] ^ nums[j];</span><br><span class="line">            <span class="type">int</span> sim = nums[i] &amp; nums[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diff &gt; sim) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">countPairsWithDifference</span>(nums);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二思路：其实就是找规律，因为差异值大于相似值，其最高位的1必然不同，这样就会导致差异值的最高位为1，相似值的最高位为0。因此我们只要找到最高位的1的种类，然后相互组合即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str, string op)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(op) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(op);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(param_str);</span><br><span class="line"></span><br><span class="line">    string op_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, op_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(op_str);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bit_info</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">      <span class="function">bitset&lt;32&gt; <span class="title">num_binary</span><span class="params">(num)</span></span>;</span><br><span class="line">      string num_binary_str= num_binary.<span class="built_in">to_string</span>();</span><br><span class="line">      num_binary_str.<span class="built_in">erase</span>(<span class="number">0</span>,num_binary_str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">      <span class="type">int</span> len = num_binary_str.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> == num_binary_str) &#123;</span><br><span class="line">        bit_info[<span class="number">0</span>]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bit_info[num_binary_str.<span class="built_in">size</span>()]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bit_info.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; bit_info.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        res += bit_info[i] * bit_info[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="Excel单元格数值统计"><a href="#Excel单元格数值统计" class="headerlink" title="Excel单元格数值统计"></a>Excel单元格数值统计</h2><h2 id="相同数字的积木游戏"><a href="#相同数字的积木游戏" class="headerlink" title="相同数字的积木游戏"></a>相同数字的积木游戏</h2><h2 id="开放日活动"><a href="#开放日活动" class="headerlink" title="开放日活动"></a>开放日活动</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>其实题目很简单，就是设置一下 maxcapacity ，从大到小遍历即可，看每一轮消减小球个数后，能否满足条件。</p><p>二分法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="投篮大赛"><a href="#投篮大赛" class="headerlink" title="投篮大赛"></a>投篮大赛</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>你现在是一场采用特殊赛制投篮大赛的记录员。这场比赛由若干回合组成，过去几回合的得分口能会影响以后几回合的得分。<br>比赛开始时，记录是空白的。<br>你会得到一个记录操作的字符串列表 opsQ，其中ops是你需要记录的第i项操作，ops遵循下述规则:<br>。整数X-表示本回合新获得分数x<br>“+”- 表示本回合新获得的得分是前两次得分的总和<br>。“D”- 表示本回合新获得的得分是前一次得分的两倍<br>。“C”- 表示本回合没有分数，并且前一次得分无效，将其从记录中移除.<br>请你返回记录中所有得分的总和。<br>示例1:<br>输入: 52CD+<br>输出: 30<br>解释:<br>“5”-记录加5，记录现在是[5]<br>“2”-记录加2，记录现在是[5,2]<br>“C”-使前一次得分的记录无效并将其移除，记录现在是[5].<br>“D”-记录加2*5=10，记录现在是[5，10].<br>“+”-记录加5+10=15，记录现在是[5，10，15]所有得分的总和5+10+15=30</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    vector&lt;string&gt; params = <span class="built_in">split_str</span>(param_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四个分支，但其实有隐患</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;params.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params[i] == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(scores[scores.<span class="built_in">size</span>()<span class="number">-2</span>] + scores[scores.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(<span class="number">2</span>*scores[scores.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="built_in">accumulate</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="开心消消乐"><a href="#开心消消乐" class="headerlink" title="开心消消乐"></a>开心消消乐</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              
              </div>
            </details>
<h2 id="通信误码"><a href="#通信误码" class="headerlink" title="通信误码"></a>通信误码</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>信号传播过程中会出现一些误码，不同的数字表示不同的误码ID，取值范围为1~65535，用一个数组Q记录误码出现的情况，<br>每个误码出现的次数代表误码频度，请找出记录中包含频度最高误码的最小子 数组长度Q输入描述<br>误码总数目: 取值范围为0~255，取值为0表示没有误码的情况。误码出现频率数组: 误码ID范围为1~65535，数组长度为1~1000.输出描述<br>包含频率最高的误码最小子数组长度<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>5<br>1 2 2 4 1<br>输出<br>2<br>说明<br>频度最高的有1和2，他们的频度均为2<br>可能的记录数组为[2,2]和[1,2,2,4,1]<br>最短的长度为2.<br>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例入</p><p>7<br>1 2 2 4 2 1 1<br>输出<br>4<br>说明<br>最短的为[2,2,4,2]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string n_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, n_str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(n_str);</span><br><span class="line"></span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(param_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算频度最高的数字</span></span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_count.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">            num_count[nums[i]] = num_count[nums[i]] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num_count[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, num_count[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; max_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : num_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.second == max_count) &#123;</span><br><span class="line">            max_num.<span class="built_in">insert</span>(item.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到第一次和最后一次出现位置</span></span><br><span class="line">    <span class="type">int</span> result = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : max_num) &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[left] != i) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[right] != i) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(result, rig</span><br><span class="line">ht - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="最大报酬"><a href="#最大报酬" class="headerlink" title="最大报酬"></a>最大报酬</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>小明每周上班都会拿到自己的工作清单，工作清单内包含n项工作，每项工作都有对应的耗时时间（单位h）和报酬,</p><p>工作的总报酬为所有已完成工作的报酬之和，那么请你帮小明安排一下工作，保证小明在指定的工作时间内工作收入最大化。</p><p><strong>输入描述</strong></p><p>输入的第一行为两个正整数T，n。</p><p>T代表工作时长（单位h，0&lt;T&lt;1000000），n代表工作数量（1&lt;n≤3000）。</p><p>接下来是n行，每行包含两个整数t，w。</p><p>t代表该工作消耗的时长（单位h，t&gt;0）,w代表该项工作的报酬。</p><p><strong>输出描述</strong></p><p>输出小明制定工作时长内工作可获得的最大报酬。</p><p><strong>输入</strong></p><p>40 3</p><p>20 10</p><p>20 20</p><p>20 5</p><p><strong>输出</strong></p><p>30</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Cap, num;</span><br><span class="line">    cin&gt;&gt;Cap&gt;&gt;num;</span><br><span class="line">    <span class="type">int</span> weight[<span class="number">100</span>], value[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;weight[i]&gt;&gt;value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=weight[i]; j&lt;=Cap; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[num][Cap]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h2><h2 id="新学校选址"><a href="#新学校选址" class="headerlink" title="新学校选址"></a>新学校选址</h2><h2 id="寻找路径"><a href="#寻找路径" class="headerlink" title="寻找路径"></a>寻找路径</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>二叉树Q也可以用数组来存储，给定一个数组，树的根节点的值储存在下标1对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标2n和2*n+1.并且我们用-1代表一个节点为空。<br>给定一个数组存储的二叉树，试求从根节点到最小的 叶子节点Q 的路径，路径由节点的值组<br>成。<br>输入描述<br>输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分割。注意第一个元素即为根节点的值，即数组的第n元素对应下标n。下标0在树的表示中没有使用所以我们省略了。输入的树最多为7层。<br>输出描述<br>输出从根节点到最小叶子节点的路径上各个节点的值由空格分割用例保证最小叶子节点只有一个示例一<br>输入<br>3 5 7 -1 -1 2 4<br>输出<br>3 7 2<br>示例二<br>输入<br>5 9 8-1 -1 7 -1 -1-1-1 -1 6<br>输出<br>5 8 7 6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string operation_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, operation_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nodes = <span class="built_in">split</span>(operation_str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minValue = *<span class="built_in">max_element</span>(nodes.<span class="built_in">begin</span>(), nodes.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//找最小叶子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nodes.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i * <span class="number">2</span> + <span class="number">1</span> &lt;= nodes.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nodes[i * <span class="number">2</span> + <span class="number">1</span>] != <span class="number">-1</span>) || (i * <span class="number">2</span> + <span class="number">2</span> &lt;= nodes.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nodes[i * <span class="number">2</span> + <span class="number">2</span>] != <span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minValue &gt; nodes[i]) &#123;</span><br><span class="line">                minValue = nodes[i];</span><br><span class="line">                minPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往上遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    path.<span class="built_in">push_back</span>(minValue);</span><br><span class="line">    <span class="keyword">while</span> (minPos &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nodes[(minPos<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">        minPos = (minPos<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; path[i];</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>
              <div class='content'>
              <p>现有一个CPU和一些任务需要处理，已提前获知每个任务的任务ID、优先级、所需执行时间和到达时间。CPU同时只能运行一个任务，请编写一个任务调度程序，采用“可抢占优先权调度”调度算法进行任务调度，规则如下：</p><p>1：如果一个任务到来时，CPU是空闲的，则CPU可以运行该任务直到任务执行完毕。但是如果运行中有一个更高优先级的任务到来，则CPU必须暂停当前任务去运行这个优先级更高的任务；</p><p>2：如果一个任务到来时，CPU正在运行一个比他优先级更高的任务时，信道大的任务必须等待；</p><p>3：当CPU空闲时，如果还有任务在等待，CPU会从这些任务中选择一个优先级最高的任务执行，相同优先级的任务选择到达时间最早的任务。</p><p>输入描述</p><p>输入有若干行，每一行有四个数字（均小于10^8）,分别为任务ID，任务优先级，执行时间和到达时间。每个任务的任务ID不同，优先级数字越大优先级越高，并且相同优先级的任务不会同时到达。</p><p>输入的任务已按照到达时间从小到大排序，并且保证在任何时间，处于等待的任务不超过10000个。</p><p><strong>输出描述</strong></p><p>按照任务执行结束的顺序，</p><p>示例一</p><p><strong>输入</strong></p><p>1 3 5 1</p><p>2 1 5 10</p><p>3 2 7 12</p><p>4 3 2 20</p><p>5 4 9 21</p><p>6 4 2 22</p><p><strong>输出</strong></p><p>1 6</p><p>3 19</p><p>5 30</p><p>6 32</p><p>4 33</p><p>2 35</p>
              </div>
            </details></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.felixshen.top">Felix</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.felixshen.top/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/">https://www.felixshen.top/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.felixshen.top" target="_blank">Felix's Footprint</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/cover1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/" title="C++11-右值引用"><img class="cover" src="/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++11-右值引用</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/21/hello-world/" title="Hello World"><img class="cover" src="/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODQ4My8zNDk0Ng=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202305221617001.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Felix</div><div class="author-info__description">但行好事，莫问前程。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/felixshenblog"><i></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/FelixShenBlog" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hubery123698745@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>鸡汤</span></div><div class="announcement_content">You got a dream, you got to protect it.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E5%8C%96%E8%B5%84%E6%BA%90%E6%8E%A7%E5%88%B6%E6%88%90%E6%9C%AC"><span class="toc-number">1.</span> <span class="toc-text">1.最大化资源控制成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%8C%E7%BE%8E%E8%B5%B0%E4%BD%8D"><span class="toc-number">2.</span> <span class="toc-text">2.完美走位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BE%8A%E3%80%81%E7%8B%BC%E3%80%81%E5%86%9C%E5%A4%AB%E8%BF%87%E6%B2%B3"><span class="toc-number"></span> <span class="toc-text">3.羊、狼、农夫过河</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97"><span class="toc-number"></span> <span class="toc-text">4.字符串重新排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%A7%9F%E8%BD%A6%E9%AA%91%E7%BB%BF%E5%B2%9B"><span class="toc-number"></span> <span class="toc-text">5.租车骑绿岛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%97%A0%E5%90%91%E5%9B%BE%E6%9F%93%E8%89%B2"><span class="toc-number"></span> <span class="toc-text">6.无向图染色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="toc-number"></span> <span class="toc-text">7.单向链表中间节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%88%92%E5%88%86%E4%B8%BAk%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number"></span> <span class="toc-text">8.划分为k个相等的子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%9C%80%E5%A4%9A%E9%A2%9C%E8%89%B2%E7%9A%84%E8%BD%A6"><span class="toc-number"></span> <span class="toc-text">9.最多颜色的车</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%8D%E5%90%AB101%E7%9A%84%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">10.不含101的数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%BF%87%E6%BB%A4%E7%BB%84%E5%90%88%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number"></span> <span class="toc-text">11.过滤组合字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%AF%86%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">12.真正的密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%9C%80%E5%B0%8F%E8%B0%83%E6%95%B4%E9%A1%BA%E5%BA%8F%E6%AC%A1%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">13.最小调整顺序次数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%98%9F%E7%90%83%E7%A7%BB%E5%B1%85%E8%AE%A1%E5%88%92-n"><span class="toc-number"></span> <span class="toc-text">14.星球移居计划-n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E9%9C%80%E8%A6%81%E6%89%93%E5%BC%80%E5%A4%9A%E5%B0%91%E7%9B%91%E8%A7%86%E5%99%A8-n"><span class="toc-number"></span> <span class="toc-text">15.需要打开多少监视器-n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E4%BD%B3%E7%A7%8D%E6%A0%91%E8%B7%9D%E7%A6%BB-n"><span class="toc-number"></span> <span class="toc-text">16.最佳种树距离-n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%AF%BB%E5%AE%9D%E7%9B%92-n"><span class="toc-number"></span> <span class="toc-text">17.阿里巴巴寻宝盒-n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E9%80%89%E4%BF%AE%E8%AF%BE-n"><span class="toc-number"></span> <span class="toc-text">18.选修课-n</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E6%8E%A2%E7%B4%A2%E5%9C%B0%E5%9D%97%E5%BB%BA%E7%AB%8B"><span class="toc-number"></span> <span class="toc-text">19.探索地块建立</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%A8%A1%E6%8B%9F%E5%95%86%E5%9C%BA%E4%BC%98%E6%83%A0%E6%89%93%E6%8A%98"><span class="toc-number"></span> <span class="toc-text">20.模拟商场优惠打折</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%8C%BA%E9%97%B4%E8%A6%86%E7%9B%96"><span class="toc-number"></span> <span class="toc-text">21.区间覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%BA%8C%E5%85%83%E7%BB%84%E4%B8%AA%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">22.二元组个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%BF%9E%E6%8E%A5%E5%99%A8%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">23.连接器问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%89%93%E5%8D%B0%E6%9C%BA%E9%98%9F%E5%88%97"><span class="toc-number"></span> <span class="toc-text">24.打印机队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%A4%84%E7%90%86%E5%99%A8%E9%97%AE%E9%A2%98"><span class="toc-number"></span> <span class="toc-text">25.处理器问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%97%A5%E5%BF%97%E9%A6%96%E6%AC%A1%E4%B8%8A%E6%8A%A5%E6%9C%80%E5%A4%9A%E7%A7%AF%E5%88%86"><span class="toc-number"></span> <span class="toc-text">26.日志首次上报最多积分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E7%AE%80%E5%8D%95%E7%9A%84%E6%9B%9D%E5%85%89"><span class="toc-number"></span> <span class="toc-text">27.简单的曝光</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%9C%80%E5%A4%A7%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-number"></span> <span class="toc-text">27.最大版本号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B7%AE%E5%BC%82%E6%95%B0"><span class="toc-number"></span> <span class="toc-text">28.二进制差异数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Excel%E5%8D%95%E5%85%83%E6%A0%BC%E6%95%B0%E5%80%BC%E7%BB%9F%E8%AE%A1"><span class="toc-number"></span> <span class="toc-text">Excel单元格数值统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E6%95%B0%E5%AD%97%E7%9A%84%E7%A7%AF%E6%9C%A8%E6%B8%B8%E6%88%8F"><span class="toc-number"></span> <span class="toc-text">相同数字的积木游戏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E6%97%A5%E6%B4%BB%E5%8A%A8"><span class="toc-number"></span> <span class="toc-text">开放日活动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%95%E7%AF%AE%E5%A4%A7%E8%B5%9B"><span class="toc-number"></span> <span class="toc-text">投篮大赛</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%BF%83%E6%B6%88%E6%B6%88%E4%B9%90"><span class="toc-number"></span> <span class="toc-text">开心消消乐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E8%AF%AF%E7%A0%81"><span class="toc-number"></span> <span class="toc-text">通信误码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%8A%A5%E9%85%AC"><span class="toc-number"></span> <span class="toc-text">最大报酬</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="toc-number"></span> <span class="toc-text">机器人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%AD%A6%E6%A0%A1%E9%80%89%E5%9D%80"><span class="toc-number"></span> <span class="toc-text">新学校选址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E8%B7%AF%E5%BE%84"><span class="toc-number"></span> <span class="toc-text">寻找路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number"></span> <span class="toc-text">任务调度</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1C-%E7%AC%94%E8%AF%95/" title="记录一次C++笔试"><img src="/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记录一次C++笔试"/></a><div class="content"><a class="title" href="/2023/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1C-%E7%AC%94%E8%AF%95/" title="记录一次C++笔试">记录一次C++笔试</a><time datetime="2023-06-16T04:10:05.000Z" title="发表于 2023-06-16 12:10:05">2023-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/15/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Linux%E5%90%8E%E5%8F%B0/" title="如何让程序运行在Linux后台"><img src="/img/cover5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何让程序运行在Linux后台"/></a><div class="content"><a class="title" href="/2023/06/15/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Linux%E5%90%8E%E5%8F%B0/" title="如何让程序运行在Linux后台">如何让程序运行在Linux后台</a><time datetime="2023-06-15T14:02:45.000Z" title="发表于 2023-06-15 22:02:45">2023-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/15/%E9%9B%B7%E5%86%9B2022%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/" title="雷军2022年度演讲-如何度过人生三次低谷"><img src="/img/cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="雷军2022年度演讲-如何度过人生三次低谷"/></a><div class="content"><a class="title" href="/2023/06/15/%E9%9B%B7%E5%86%9B2022%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/" title="雷军2022年度演讲-如何度过人生三次低谷">雷军2022年度演讲-如何度过人生三次低谷</a><time datetime="2023-06-15T03:34:32.000Z" title="发表于 2023-06-15 11:34:32">2023-06-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><img src="/img/cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并查集"/></a><div class="content"><a class="title" href="/2023/06/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a><time datetime="2023-06-14T14:20:28.000Z" title="发表于 2023-06-14 22:20:28">2023-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/14/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="刷题小技巧"><img src="/img/cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="刷题小技巧"/></a><div class="content"><a class="title" href="/2023/06/14/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="刷题小技巧">刷题小技巧</a><time datetime="2023-06-14T14:15:24.000Z" title="发表于 2023-06-14 22:15:24">2023-06-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><div id="runtime"></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><div class="aplayer no-destroy" data-id="60198" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-autoplay="false" data-theme="transparent" data-lrctype="2"> </div><script async src="/js/diytitle.js"></script><script async src="/js/footerTime.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1s');
    arr[i].setAttribute('data-wow-delay', '0s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('pagination');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__backInUp');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>