<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STL常用算法</title>
      <link href="/2023/05/30/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/30/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="删除队列的某个元素"><a href="#删除队列的某个元素" class="headerlink" title="删除队列的某个元素"></a>删除队列的某个元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除字符串全部逗号</span></span><br><span class="line">    string s=<span class="string">&quot;1,3,4,5&quot;</span>;</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="built_in">remove</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">&#x27;,&#x27;</span>),s.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//删除vector中的某个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">3</span>),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++) cout&lt;&lt;v[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL双端队列</title>
      <link href="/2023/05/30/STL%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/05/30/STL%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//访问首尾元素</span></span><br><span class="line">    cout&lt;&lt;d.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*d.<span class="built_in">begin</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*(d.<span class="built_in">end</span>()<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;d[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d[<span class="number">3</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//添加头部元素</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//添加尾部元素</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//删除头部元素</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">//删除尾部元素</span></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//使用emplace_front和emplace_back更加节省时间</span></span><br><span class="line">    d.<span class="built_in">emplace_front</span>(<span class="number">0</span>);</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll</title>
      <link href="/2023/05/30/epoll/"/>
      <url>/2023/05/30/epoll/</url>
      
        <content type="html"><![CDATA[<h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><p><code>epoll_create</code></p><p><code>epoll_wait</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/05/29/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/05/29/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>举个简单的例子理解一下吧，比如pow(5,13)，正常算的话需要执行乘法15次吧。可是如果采用快速幂，只要进行只要四次运算就ok了。13的二进制为1101，每一位分别代表8,4,2,1。</p><script type="math/tex; mode=display">5^{13}=5^1*5^0*5^4*5^8</script><p>原理很简单，x每轮都自乘，若遇到当前二进制为1的话，就乘与x。有点词穷了，附上代码赋值理解吧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> b=n;</span><br><span class="line">        <span class="type">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果n小于0，等与pow(1/x,-n)</span></span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            b=-b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切才刚刚开始</title>
      <link href="/2023/05/28/%E4%B8%80%E5%88%87%E6%89%8D%E5%88%9A%E5%88%9A%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/05/28/%E4%B8%80%E5%88%87%E6%89%8D%E5%88%9A%E5%88%9A%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>记录一下今天，今天早上投了20多份简历，不过几乎都石沉大海了。心中难免浮出一片悲凉，感觉前路漫漫。于是和一位网友诉苦，她的一句话也确实点醒了我。她说，现在虽然没有稳定工作但是你最起码可以享受找工作的过程 可以有目标 ，如果你现在就稳定工作 可能你还是去了很多更好的机会 失去了过程中的快乐。听到这话我也有了一丝的宽慰，又想起来我那个倒霉蛋哥们，一年了也没收到几个offer。而我呢，还没找多久呢，怎么可以轻言失败呢。一切才刚刚开始呢。以下就是我网上找的鸡汤文。</p><p>当你以为一切都将要结束的时候，其实一切才刚刚开始。其实人生很多时候都不是如意的，很多时候都觉得现在特别难。不过仔细回想一下，当初你觉得很难，觉得不可能度过的那段时间，是不是也刷的一下过去了。现在回想起来甚至想不起来，当初为什么觉得那么难了。也许很多时候不能把时间放在无意义的内耗上，不妨走出去，呼吸一下新鲜空气，或许就有不同的感受了。</p><p>最后啊，再来晚毒鸡汤。当你觉得一切才刚刚开始的时候，挑战已经结束了。哈哈哈！</p>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位dp</title>
      <link href="/2023/05/28/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2023/05/28/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<h2 id="数位dp枚举0-n"><a href="#数位dp枚举0-n" class="headerlink" title="数位dp枚举0~n"></a>数位dp枚举0~n</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> limit, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) cout&lt;&lt;b[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> up=limit?a[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123;</span><br><span class="line">        b[p]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(p+<span class="number">1</span>,limit&amp;&amp;i==up,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        a[p++]=num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">begin</span>()+p);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">120</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带3的数"><a href="#带3的数" class="headerlink" title="带3的数"></a>带3的数</h2><p>思路：先求不带3的数，再减去</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> limit, <span class="type">int</span> length, vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> up=limit?a[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;f[p]!=<span class="number">0</span>) <span class="keyword">return</span> f[p];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(p+<span class="number">1</span>,limit&amp;&amp;i==up,length,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">    f[p]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> x=num;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: a) cout&lt;&lt;x;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span>-<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,a.<span class="built_in">size</span>(),a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">handle</span>(<span class="number">200</span>)-<span class="built_in">handle</span>(<span class="number">100</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带49的数"><a href="#带49的数" class="headerlink" title="带49的数"></a>带49的数</h2><p>思路：先求不带49的数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">22</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pre, <span class="type">bool</span> limit,vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;f[p][pre]) <span class="keyword">return</span> f[p][pre];</span><br><span class="line">    <span class="type">int</span> up=limit?v[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">4</span>&amp;&amp;i==<span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(p+<span class="number">1</span>,i,limit&amp;&amp;i==up,v,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[p][pre]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> x=num;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span>-<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,a,a.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">handle</span>(<span class="number">500</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">题目链接</a></p><p>题意概括：找下一个比当前元素大的数</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><p>栈存的是下标</p></li><li><p>如果每次存的都是比栈顶小的元素，找的就是比当前元素大的数</p></li><li><p>如果每次存的都是比栈顶大的元素，找的就是比当前元素小的数</p></li><li><p>单调栈记录的是遍历过的元素，栈顶和当前元素对比，再进行求值的过程</p></li></ul><h3 id="详细版代码"><a href="#详细版代码" class="headerlink" title="详细版代码"></a>详细版代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;temperatures.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i]&lt;temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temperatures[i]==temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//将栈内比当前元素小的元素全部弹出之后再push当前元素</span></span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;temperatures[i]&gt;temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()]=i-st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="精简版代码"><a href="#精简版代码" class="headerlink" title="精简版代码"></a>精简版代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 递增栈</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(T.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意栈不能为空</span></span><br><span class="line">                result[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/">题目链接</a></p><p>题意概括：相同的元素在另外一个数组找下一个更大元素</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先找nums2的下一个最大元素，存入result2数组。问题转化为为nums1中的每个下标找对应的result2元素。即是<code>nums1下标-&gt;result2元素</code>，解决方案为建立<code>nums2的元素-&gt;nums2的下标</code>，再通过<code>result2[m[nums1[i]]</code>访问result2的元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result2</span><span class="params">(nums2.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;nums2[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                result2[st.<span class="built_in">top</span>()]=nums2[i];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射麻烦,nums1下标-&gt;result2的结果</span></span><br><span class="line">        <span class="comment">//nums2元素-&gt;nums2下标 == nums2元素-&gt;result2下标 == nums1元素-&gt;result2下标</span></span><br><span class="line">        <span class="comment">//nums1元素-&gt;result2的下标-&gt;result2结果</span></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums2[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result1</span><span class="params">(nums1.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result1[i]=result2[m[nums1[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503.下一个更大元素 II"></a>503.下一个更大元素 II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">题目链接</a></p><p>题目概述：找下一个更大元素，但是环形</p><h3 id="思路1-开辟新数组"><a href="#思路1-开辟新数组" class="headerlink" title="思路1(开辟新数组)"></a>思路1(开辟新数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拼接一个新的nums</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 用新的nums大小来初始化result</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始单调栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后再把结果集即result数组resize到原数组大小</span></span><br><span class="line">        result.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-取模"><a href="#思路2-取模" class="headerlink" title="思路2(取模)"></a>思路2(取模)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) &#123; </span><br><span class="line">            <span class="comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>()); </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">题目链接</a></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>按列取雨水</p><ul><li><p>当前列雨水面积：min(左边柱子的最高高度，右边柱子的最高高度) - 当前柱子高度。</p></li><li><p>从左往右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p></li><li><p>从右往左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxLeft</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxRight</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> size = maxRight.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个柱子左边柱子最大高度</span></span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            maxLeft[i] = <span class="built_in">max</span>(height[i], maxLeft[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录每个柱子右边柱子最大高度</span></span><br><span class="line">        maxRight[size - <span class="number">1</span>] = height[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = <span class="built_in">max</span>(height[i], maxRight[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="built_in">min</span>(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) sum += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>按行取雨水</p><p>原理：找左边比当前元素大的数，找右边比当前元素大的数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 可以不加</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 存着下标，计算的时候用下标对应的柱子高度</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[st.<span class="built_in">top</span>()]) &#123;     <span class="comment">// 情况一</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">if</span> (height[i] == height[st.<span class="built_in">top</span>()]) &#123;  <span class="comment">// 情况二</span></span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 情况三</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意这里是while</span></span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>; <span class="comment">// 注意减一，只求中间宽度</span></span><br><span class="line">                        sum += h * w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">题目链接</a></p><p>题目概要：找左边比当前元素小的元素，找右边比当前元素小的元素。</p><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minLeftIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minRightIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> size = heights.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个柱子 左边第一个小于该柱子的下标</span></span><br><span class="line">        minLeftIndex[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 注意这里初始化，防止下面while死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不是用if，而是不断向左寻找的过程</span></span><br><span class="line">            <span class="keyword">while</span> (t &gt;= <span class="number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];</span><br><span class="line">            minLeftIndex[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录每个柱子 右边第一个小于该柱子的下标</span></span><br><span class="line">        minRightIndex[size - <span class="number">1</span>] = size; <span class="comment">// 注意这里初始化，防止下面while死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> t = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不是用if，而是不断向右寻找的过程</span></span><br><span class="line">            <span class="keyword">while</span> (t &lt; size &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];</span><br><span class="line">            minRightIndex[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - <span class="number">1</span>);</span><br><span class="line">            result = <span class="built_in">max</span>(sum, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><p>关键点</p><ul><li><p>首尾加0</p></li><li><p>栈内每次存的都是比栈顶元素大的数</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/05/27/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/05/27/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.哈希冲突</strong></p><ul><li><p>定义：在哈希表中，不同的键经过哈希函数计算后得到相同的哈希值，导致它们应该存储在哈希表的同一个位置上</p></li><li><p>链地址法（Chaining）：使用链表或其他数据结构，在哈希表的每个位置上维护一个链表，将哈希冲突的元素存储在同一个位置的链表中。当需要查找、插入或删除元素时，遍历对应位置的链表即可。这种方法简单且易于实现，但可能会造成额外的存储空间开销和链表的遍历操作。</p></li><li><p>开放地址法（Open Addressing）：当发生哈希冲突时，通过一定的规则在哈希表的其他位置寻找空槽来存储冲突元素。常见的开放地址法有线性探测、二次探测、双重哈希等。这种方法不需要额外的数据结构存储冲突元素，节省了存储空间，但可能导致聚集现象，即连续的冲突元素会聚集在一起，影响性能。</p></li><li><p>建立更好的哈希函数：改进哈希函数的设计，减少哈希冲突的发生。好的哈希函数能够尽可能地将键均匀地分布在哈希表的各个位置上，减少冲突的概率。通常，好的哈希函数应该具有均匀性、雪崩效应（即输入的微小变化会导致输出的巨大变化）等特性。</p></li><li><p>调整哈希表的负载因子：负载因子是指哈希表中已存储元素的数量与哈希表大小的比值。当负载因子过高时，哈希冲突的概率会增加。通过动态调整哈希表的大小，可以控制负载因子在一个合理的范围内，减少哈希冲突的发生。</p></li></ul>              </div>            </details><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.C++内存分布：</strong></p><ul><li><p>栈（stack）：栈是用于存储局部变量和函数调用信息的内存区域。它的分配和释放是由编译器自动完成的，遵循后进先出（LIFO）的原则。每当函数被调用时，函数的局部变量和参数被压入栈中，并在函数返回时被自动弹出。栈的大小通常是有限的，一般在编译时确定，超出栈大小的分配会导致栈溢出。</p></li><li><p>堆（heap）：堆是用于动态分配内存的区域。在堆上分配的内存需要手动进行管理，包括分配和释放。通常使用<code>new</code>操作符来分配内存，使用<code>delete</code>操作符来释放内存。堆上分配的内存在不需要时需要手动释放，否则可能导致内存泄漏。堆的大小一般比栈大，并且在运行时动态增长。</p></li><li><p>静态存储区（static storage area）：静态存储区用于存储全局变量、静态变量和静态常量。它在程序开始执行时被分配，并在程序结束时被释放。静态存储区的大小在编译时确定，存储区域在整个程序的执行期间都存在。</p></li><li><p>常量区（Constant Storage）：常量区用于存储常量数据，如字符串常量。这些数据在程序执行期间是只读的，无法修改。代码区（存储程序的机器指令）</p></li><li><p>程序代码区（Code Area）：程序代码区存储程序的指令代码。这部分内存是只读的，存储着程序的可执行指令。</p></li></ul><p><strong>2.什么是智能指针？为什么在C++中使用智能指针？</strong></p><p>智能指针是C++中的一种包装类，用于管理动态分配的对象的生命周期。它们提供了自动化的内存管理，可以避免内存泄漏和悬挂指针的问题。智能指针通过在对象上使用引用计数或其他技术来跟踪对象的引用，并在引用计数为零时自动释放对象的内存。</p><p><strong>3.C++中有哪些类型的智能指针？请简要描述它们的区别</strong></p><p>C++中有三种常用的智能指针类型：unique_ptr、shared_ptr和weak_ptr。</p><ul><li><p>unique_ptr：独占所有权的智能指针，不能共享所有权。它使用独占式所有权语义，确保只有一个指针可以访问所拥有的对象。</p></li><li><p>shared_ptr：允许多个指针共享同一个对象的智能指针。它使用引用计数来跟踪对象的引用，当引用计数为零时自动释放对象。</p></li><li><p>weak_ptr：用于解决shared_ptr可能引起的循环引用问题。weak_ptr可以观测shared_ptr，但不会增加引用计数，也不能直接访问所指向的对象。</p></li></ul><p><strong>3.如何创建和使用智能指针？</strong></p><p>可以使用<code>std::make_unique</code>、<code>std::make_shared</code>和<code>std::make_weak</code>等函数来创建智能指针。例如，使用<code>std::make_unique</code>创建unique_ptr。</p><p><strong>4.智能指针有什么缺点？</strong></p><p>答案：尽管智能指针提供了方便和安全的内存管理，但也存在一些缺点。其中一个主要的缺点是智能指针可能引起循环引用的问题，导致内存泄漏。为了避免这种情况，应该使用weak_ptr来打破循环引用。此外，智能指针相对于裸指针有一些额外的开销，包括引用计数的维护等。</p><p><a href="https://blog.csdn.net/qq_26538113/article/details/125796865">智能指针循环引用问题</a></p><p><strong>5.C++多态</strong></p><ul><li><p>什么是多态性（Polymorphism）：多态性是面向对象编程中的一个重要特性，它允许使用基类的指针或引用来访问派生类对象，实现代码的灵活性和可扩展性。</p></li><li><p>多态性的实现方式：两种主要的实现方式：静态多态性（静态绑定）和动态多态性（动态绑定）。静态多态性通过函数重载和模板实现，而动态多态性通过虚函数和继承实现。</p></li><li><p>虚函数和纯虚函数：虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，它可以在派生类中被重写，实现动态绑定。纯虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，但没有提供具体的实现，需要在派生类中实现。</p></li><li><p>虚函数表（Virtual Function Table）：虚函数表是一个特殊的数据结构，用于实现动态多态性。每个包含虚函数的类都有自己的虚函数表，该表存储了类的虚函数的地址，使得在运行时能够正确调用派生类的虚函数。</p></li><li><p>虚析构函数：虚析构函数的作用是确保在删除指向派生类对象的基类指针时，能够正确调用派生类的析构函数，防止内存泄漏。</p></li><li><p>多态性的优点和应用场景：多态性提供了代码的灵活性、可扩展性和可维护性。它使得代码可以更容易地适应变化和扩展，同时也提高了代码的可读性和重用性。</p></li><li><p>如何阻止派生类重写虚函数：可以在基类中使用<code>final</code>关键字来修饰虚函数，以阻止派生类对该虚函数进行重写。被标记为<code>final</code>的虚函数在派生类中不能被重写。</p></li></ul><p><strong>6.new/delete和malloc/free的区别</strong></p><ul><li>malloc/free是C/C++的库函数，需要stdlib.h；new/delete是C++的关键字；</li><li>都可用于申请动态内存和释放内存，new/delete在对象创建的时候自动执行构造函数，对象消亡前自动执行析构函数，底层实现其实也是malloc/free</li><li>new无需指定内存块的大小，编译器会根据类型信息自行计算；malloc需要显式地支持所需内存的大小</li><li>new返回<strong>指定类型</strong>的指针，无需进行类型转换；malloc默认返回类型为<strong>void*</strong>，必须强行转换为实际类型的指针</li><li>new内存分配失败时会抛出bad_alloc异常；malloc失败时返回NULL</li></ul><p><strong>7.static的用法</strong></p><ul><li><p>static修饰局部变量：使其变为<strong>静态存储方式</strong>（静态数据区），函数执行完成之后不会被释放，而是继续保存在内存中；</p></li><li><p>static修饰全局变量：使其只在本文件内部有效，其他文件不可链接或引用该变量；</p></li><li><p>static修饰函数：静态函数，即函数只在本文件内部有效，对其他文件不可见；避免同名干扰，同时保护</p></li></ul><p><strong>8.const的用法</strong></p><p>const起到<strong>强制保护</strong>的修饰作用，可以预防意外改动，提高程序的健壮性</p><ul><li><p>const修饰常量：定义时就初始化，以后不能更改；</p></li><li><p>const修饰形参：func(const int a); 该形参在函数里不能改变；</p></li><li><p>const修饰类成员函数：const类成员函数不能改变成员变量的数值</p></li></ul><p><strong>const常量和#define的区别</strong></p><ul><li>const定义的常量有类型名字，存放在内存的静态区域中，在编译时确定其值；</li><li><h1 id="define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；"><a href="#define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；" class="headerlink" title="define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；"></a>define定义的常量是没有类型的一个<strong>立即数</strong>，编译器会在预处理阶段将程序中所有使用到该常量的地方进行<strong>拷贝替换</strong>；</h1></li></ul><p><strong>9.全局变量和静态变量区别</strong></p><ul><li>存储方式上并无区别，都是静态存储方式</li><li>非静态全局变量作用域为整个源程序；当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，而静态全局变量则限制了其作用域，只在定义该变量的源文件内有效</li></ul>              </div>            </details><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.IO复用模型</strong></p><p>IO复用模型是一种用于实现高效的并发I/O操作的技术，它允许一个线程同时监视多个I/O事件，并在有事件发生时进行处理，避免了传统的阻塞式I/O中的线程阻塞和轮询等待。</p><p><strong>2.socket编程的流程</strong></p><ol><li><p>创建Socket：使用<code>socket()</code>系统调用创建一个Socket对象。需要指定网络协议、Socket类型和协议族。</p></li><li><p>绑定Socket：使用<code>bind()</code>系统调用将Socket绑定到一个特定的IP地址和端口号上。这一步是可选的，如果不绑定，操作系统会自动为Socket分配一个可用的端口。</p></li><li><p>监听连接请求（仅适用于服务器）：使用<code>listen()</code>系统调用将Socket设置为监听状态，以等待客户端的连接请求。服务器Socket需要指定可以同时处理的最大连接数。</p></li><li><p>接受连接（仅适用于服务器）：使用<code>accept()</code>系统调用接受客户端的连接请求，返回一个新的Socket对象用于与客户端进行通信。服务器Socket会一直阻塞，直到有客户端连接进来。</p></li><li><p>连接服务器（仅适用于客户端）：使用<code>connect()</code>系统调用连接到服务器的Socket。需要指定服务器的IP地址和端口号。</p></li><li><p>发送和接收数据：使用<code>send()</code>和<code>recv()</code>系统调用进行数据的发送和接收。可以根据具体需求进行数据的分割、组装和处理。</p></li><li><p>关闭连接：使用<code>close()</code>系统调用关闭Socket连接，释放相关资源。</p></li></ol><p><strong>3.TCP</strong></p><ul><li><p>TCP的基本概念：TCP是一种可靠的、面向连接的传输协议，它提供了可靠的数据传输、流量控制、拥塞控制和错误恢复机制等功能。</p></li><li><p>三次握手：包括客户端向服务器发送SYN（同步）请求，服务器回复SYN-ACK（同步-应答）确认，最后客户端发送ACK（应答）确认。</p></li><li><p>四次挥手：客户端或服务器发送FIN（结束）请求，对方回复ACK确认，然后再发送FIN请求，对方再次回复ACK确认</p></li></ul><p><strong>4.大小端</strong></p><ul><li><p>大端字节序（Big Endian）：在大端字节序中，高位字节存储在低地址，低位字节存储在高地址。小端字节序（Little Endian）：在小端字节序中，高位字节存储在高地址，低位字节存储在低地址。网络协议通常使用大端字节序来传输数据。</p></li><li><p>大小端转换</p><ul><li><p>使用联合体（Union）：可以定义一个联合体，其中包含相同的数据，但使用不同的字节序。通过将数据存储在一个字节序中，然后在另一个字节序中读取，可以实现大小端转换。</p></li><li><p>使用库函数：C++ 标准库或其他第三方库中可能提供了字节序转换的函数。例如，可以使用 <code>&lt;arpa/inet.h&gt;</code> 头文件中的 <code>ntohs()</code> 和 <code>htons()</code> 函数进行网络字节序和主机字节序之间的转换。</p></li></ul></li></ul><p><strong>5.select</strong></p><p>是什么：select 是一种基于IO复用的模型，是Unix系统提供的一种系统调用。它允许进程或线程同时监视多个文件描述符，并在其中的任何一个准备就绪时通知调用者。</p><p>使用 select 模型的基本流程如下：</p><ul><li><p>调用 select 函数，传入需要监视的文件描述符集合、超时时间等参数。</p></li><li><p>select 函数开始监视所有文件描述符，直到有一个或多个文件描述符准备就绪。</p></li><li><p>select 函数返回时，可以使用一些辅助函数（如FD_ISSET）来判断哪些文件描述符已经准备就绪。</p></li><li><p>对于准备就绪的文件描述符，进行相应的读取、写入或其他操作。</p></li><li><p>重复以上步骤，实现高效的并发IO处理。</p></li></ul><p>使用 select 模型的优点是：</p><ul><li><p>简单易用：相对于其他IO复用模型（如 epoll 和 kqueue），select 的接口更加简单，易于理解和使用。</p></li><li><p>跨平台性：select 是跨平台的，可以在不同的操作系统上使用。</p></li><li><p>支持多种类型的文件描述符：可以同时监视多种类型的文件描述符，如标准输入输出、套接字等。</p></li></ul><p>select 也存在一些缺点：</p><ul><li><p>扩展性有限：select 模型在处理大量文件描述符时性能较差，因为每次调用 select 都需要线性扫描整个文件描述符集合。</p></li><li><p>数量限制：不同操作系统对 select 函数支持的文件描述符数量有限制，通常是1024或更小。</p></li><li><p>低效的事件通知：当有文件描述符准备就绪时，select 只提供了一个整体的通知，需要使用额外的轮询来确定具体是哪些文件描述符准备就绪</p></li></ul><p><strong>6.poll</strong></p><p>poll 模型的基本原理是通过一个结构体数组来表示待监视的文件描述符集合，称为 pollfd 数组。每个 pollfd 结构体包含了一个文件描述符以及监视的事件类型。</p><p>使用 poll 模型的基本流程如下：</p><ul><li><p>创建一个 pollfd 数组，用于存储需要监视的文件描述符和事件类型。</p></li><li><p>使用 poll 函数，将 pollfd 数组传递给它，同时设置超时时间</p></li><li><p>poll 函数开始监视所有文件描述符，直到有一个或多个文件描述符准备就绪或超时。</p></li><li><p>poll 函数返回时，可以通过遍历 pollfd 数组来找到准备就绪的文件描述符。</p></li><li><p>对于准备就绪的文件描述符，进行相应的读取、写入或其他操作。</p></li><li><p>重复以上步骤，实现高效的并发IO处理</p></li></ul><p>优点：</p><ul><li><p>没有文件描述符数量限制：poll 模型没有对文件描述符数量的限制，可以处理更多的文件描述符。</p></li><li><p>提供更直观的事件通知：当有文件描述符准备就绪时，poll 可以提供具体的事件类型，使得处理更加方便和直观。</p></li></ul><p>缺点：</p><ul><li><p>poll 在内部实现上仍然需要遍历整个 pollfd 数组来确定准备就绪的文件描述符，对于大量的文件描述符会有性能问题。</p></li><li><p>跨平台兼容性：poll 不像 select 那样具有跨平台的特性，因此在不同的操作系统上可能存在差异。</p></li></ul><p><strong>7.epoll</strong></p><p>epoll 模型的基本原理是通过使用内核提供的 epoll 系统调用，将需要监视的文件描述符注册到一个事件表（event table）中。当文件描述符准备就绪时，内核会将事件通知给应用程序。</p><ul><li><p>支持较大数量的并发连接：epoll 模型使用基于事件驱动的方式，可以支持非常大的并发连接数，远远超过传统的 select 和 poll 模型的限制。</p></li><li><p>高效的事件通知机制：epoll 使用了回调机制，只有当事件发生时才进行通知，避免了轮询和线性扫描整个文件描述符集合的性能损耗。</p></li><li><p>高性能的数据结构：epoll 使用了红黑树（Red-Black Tree）和就绪列表（Ready List）等高效的数据结构，可以快速地查找和管理准备就绪的文件描述符。</p></li><li><p>较低的内存占用：epoll 模型使用了事件通知机制，只需维护准备就绪的文件描述符，而不需要维护整个文件描述符集合，因此占用的内存较少。</p></li><li><p>支持多种触发模式：epoll 提供了水平触发（Level-Triggered）和边缘触发（Edge-Triggered）两种模式，可以根据需求选择适合的模式。</p></li></ul><p>使用 epoll 模型的基本流程如下：</p><ul><li><p>创建 epoll 实例（epoll_create 或 epoll_create1 函数）</p></li><li><p>创建监听套接字，并设置为非阻塞模式。</p></li><li><p>将监听套接字添加到 epoll 实例的事件表中（epoll_ctl 函数，指定事件类型为 EPOLLIN）。</p></li><li><p>进入事件循环，调用 epoll_wait 函数等待事件发生。</p></li><li><p>当 epoll_wait 返回时，遍历就绪的事件列表，处理每个事件对应的文件描述符。</p></li><li><p>如果是监听套接字准备就绪，表示有新的连接请求，接受连接并将新的套接字添加到 epoll 实例的事件表中。</p></li><li><p>如果是已连接套接字准备就绪，进行读取或写入操作。</p></li></ul><p>边缘触发模式：</p><ul><li><p>精确的事件通知：边缘触发模式只在文件描述符状态发生变化时才进行通知，而不是像水平触发模式那样只要文件描述符可读或可写就会通知。这意味着应用程序只在真正发生状态变化时才会收到通知，避免了不必要的通知，减少了上下文切换和事件处理的开销。</p></li><li><p>适应高并发环境：边缘触发模式适用于高并发连接的场景，特别是在大规模并发连接的情况下，由于只在状态变化时进行通知，可以有效降低系统开销。边缘触发模式通常与非阻塞 I/O 配合使用，以更好地利用系统资源和处理并发连接。</p></li></ul><p>水平触发模式：</p><ul><li><p>持续通知：一旦文件描述符可读或可写，内核会持续通知应用程序，直到应用程序处理完相关事件或缓冲区不再可读或可写。这意味着应用程序需要在每次通知后重新处理 I/O 事件，否则可能会造成 CPU 资源的浪费。</p></li><li><p>适用于阻塞 I/O：水平触发模式通常与阻塞 I/O 结合使用。当文件描述符准备就绪时，应用程序可以直接进行 I/O 操作，如果数据未完全就绪或无法立即发送，则会阻塞在相应的读取或写入操作上，直到数据就绪或可写入</p></li></ul><p>两种模式和I/O的组合：<a href="https://www.cnblogs.com/JCpeng/p/15169423.html">epoll水平/边缘触发模式设置阻塞/非阻塞IO事件触发条件及次数 - Jcpeng_std - 博客园</a></p><ul><li>具体地说，采用边缘触发模式必须使用非阻塞IO，不然读缓冲区数据没有了，就会一直阻塞在recv()函数这里。（内核通知fd需要读取，不过却卡在了读取的路上）</li></ul>              </div>            </details><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.死锁的必要条件</strong></p><ul><li><p>互斥条件（Mutual Exclusion）</p></li><li><p>不可剥夺条件（No Preemption）</p></li><li><p>请求和保持条件（Hold and Wait)</p></li><li><p>循环等待条件（Circular Wait）</p></li></ul><p><strong>2.死锁的破坏</strong></p><ul><li><p>预防死锁（Deadlock Prevention）：</p><ul><li><p>互斥条件破坏：将某些资源设计为可共享的，多个进程可以同时访问。</p></li><li><p>请求与保持条件破坏：进程在申请资源时，要求一次性申请所需要的所有资源，而不是逐个申请。</p></li><li><p>不可剥夺条件破坏：允许操作系统在必要时剥夺进程已经占有的资源。</p></li><li><p>循环等待条件破坏：对系统中的资源进行全局排序，并规定进程按照序号递增的顺序申请资源。</p></li></ul></li><li><p>避免死锁（Deadlock Avoidance）：银行家算法（Banker’s Algorithm）和资源分配图（Resource Allocation Graph）。</p></li><li><p>检测和恢复死锁（Deadlock Detection and Recovery）：常见的死锁检测算法有图论算法、资源分配图算法等。恢复死锁可以采取一些策略，如终止某个或多个进程、抢占资源、回滚进程等。</p></li><li><p>忽略死锁（Deadlock Ignorance）：这种方法适用于死锁发生的概率极低，或者死锁发生后对系统造成的影响较小的场景。</p></li></ul><p><strong>3.进程通信方式</strong></p><ol><li><p>共享内存（Shared Memory）：多个进程可以访问和操作同一块共享内存区域，从而实现数据的共享和交换。进程可以直接读写内存，无需进行复制和传输。共享内存需要使用同步机制（如信号量）来避免多个进程同时访问导致的竞态条件。</p></li><li><p>管道（Pipe）：管道是一种半双工的通信方式，用于具有亲缘关系的进程间通信。一个进程可以将输出写入管道，另一个进程则可以从管道读取输入。管道可以是匿名管道（在进程创建时自动创建）或命名管道（通过文件系统中的路径名创建）。</p></li><li><p>命名管道（Named Pipe）：命名管道允许不具有亲缘关系的进程进行通信。与匿名管道不同，命名管道在文件系统中有一个关联的路径名，进程可以通过打开该路径名来进行通信。</p></li><li><p>消息队列（Message Queue）：消息队列是一种可以实现进程间异步通信的方式。进程可以将消息发送到队列中，其他进程则可以从队列中接收这些消息。消息队列允许不同进程之间以先进先出的顺序进行通信。</p></li><li><p>信号量（Semaphore）：信号量是一种用于进程间同步的机制。它可以用来保护临界区，限制资源的访问以及实现进程间的互斥和同步操作。进程可以通过等待（wait）和释放（signal）信号量来实现对共享资源的访问控制。</p></li><li><p>套接字（Socket）：套接字是一种用于网络通信的接口。它允许不同主机上的进程进行通信，实现了跨网络的进程间通信。</p></li><li><p>文件（File）：进程可以通过读写文件来进行通信。一个进程可以将数据写入文件，另一个进程则可以从文件中读取这些数据。</p></li></ol><p><strong>4.进程和线程的区别</strong></p><ul><li><p>定义：进程是程序的执行实例，是资源分配和调度的基本单位。它拥有独立的内存空间，包含程序代码、数据和执行状态。线程是进程内的一个执行单元，是进程的实际执行者。线程共享进程的内存空间和资源，可以看作是进程内的子任务。</p></li><li><p>资源占用：每个进程都有独立的内存空间和资源，包括文件描述符、环境变量、信号处理器等。不同进程之间的资源是相互隔离的，需要通过进程间通信机制来实现数据交换。而线程共享进程的内存空间和资源，可以直接读取和修改进程的数据。</p></li><li><p>切换开销：进程之间切换的开销较大，因为需要保存和恢复整个进程的状态信息，包括程序计数器、寄存器状态、内存映射等。线程切换的开销较小，因为线程共享进程的内存空间，只需要保存和恢复线程私有的寄存器状态即可。</p></li><li><p>通信和同步：进程间通信（IPC）是相对复杂的，需要使用进程间通信机制，如管道、消息队列、共享内存等。线程之间通信和同步较为简单，可以直接读写共享的内存空间，也可以使用线程间同步机制，如互斥锁、条件变量等，来保证数据的一致性和互斥访问。</p></li><li><p>安全性：由于每个进程有独立的内存空间，一个进程的崩溃不会影响其他进程。而在多线程编程中，一个线程的错误可能导致整个进程崩溃。</p></li></ul><p><strong>5.僵尸进程和孤儿进程</strong></p><ul><li><p>孤儿进程（Orphan Process）：当一个进程的父进程在其退出之前先退出或被终止时，该进程会成为孤儿进程。此时，孤儿进程将由 init 进程（进程 ID 为 1）接管，并成为 init 进程的子进程。init 进程负责回收孤儿进程的资源，并保持系统的稳定运行。孤儿进程不会成为僵尸进程，因为它的退出状态会被 init 进程处理。</p></li><li><p>僵尸进程（Zombie Process）：当一个进程终止（退出），但其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来获取子进程的退出状态时，子进程会变成僵尸进程。在这种状态下，僵尸进程的进程控制块（Process Control Block，PCB）仍然存在，但不再执行任何代码。僵尸进程占用一些系统资源，因此父进程应该及时回收子进程，以避免僵尸进程的累积。父进程可以通过调用适当的系统调用来获取子进程的退出状态，并释放僵尸进程的资源。</p></li></ul><p><strong>6.虚拟内存</strong></p><p>是什么：虚拟内存的主要目的是提供了一种抽象层，使得每个进程认为它拥有连续的、私有的地址空间，而不需要实际的物理内存支持。它通过使用页面（Page）或页面框（Page Frame）作为最小的内存单位，将进程的地址空间划分为固定大小的页面，并将这些页面映射到物理内存或磁盘上。</p><p>工作原理：</p><ul><li><p>地址空间划分：操作系统将进程的地址空间划分为多个页面（通常是固定大小的4KB或2MB），并将其映射到虚拟地址空间。</p></li><li><p>虚拟地址转换：当进程访问虚拟地址时，CPU会将虚拟地址转换为物理地址。这个转换过程是通过页表（Page Table）实现的，页表存储了虚拟页面和物理页面之间的映射关系。</p></li><li><p>页面置换：如果所需的页面不在物理内存中，操作系统会将页面从磁盘加载到内存中，并更新页表中的映射关系。如果内存不足，操作系统会根据页面置换算法将某些页面置换到磁盘上，以便为新页面腾出空间。</p></li></ul><p>虚拟内存的优势包括：</p><ul><li><p>扩展了物理内存：进程可以访问比物理内存更大的地址空间，允许运行更大的程序和处理更大的数据。</p></li><li><p>提供了地址空间隔离：每个进程拥有独立的地址空间，保护了进程之间的数据不受干扰，提高了系统的稳定性和安全性。</p></li><li><p>简化了内存管理：操作系统负责管理虚拟内存的分配和回收，减少了程序员对内存管理的复杂性。</p></li><li><p>支持页面置换和页面共享：通过页面置换算法，操作系统可以有效地管理内存资源。同时，多个进程可以共享同一物理页面，提高了内存利用率。</p></li></ul>              </div>            </details><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.单例模式</strong></p><p>涉及到类多个对象的操作函数：</p><ul><li><p>构造函数</p></li><li><p>拷贝构造函数</p></li><li><p>拷贝赋值操作符函数()</p></li></ul><p>为了把一个类可以实例化多个对象的路堵死：</p><ul><li><p>构造函数私有化</p></li><li><p>拷贝构造函数私有化或者禁用</p></li><li><p>拷贝赋值操作符函数私有化或者禁用</p></li></ul><p>要点：<code>静态成员的初始化要在类外</code></p><p>为了得到单例对象，需要定义一个静态的私有的类实例和静态的公共的访问函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分类：</p><ul><li><p>饿汉模式-&gt;定义类的时候已经创建单例对象(以上示例就是懒汉模式)</p></li><li><p>懒汉模式-&gt;使用的时候才创建单例对象(示例如下)</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程下：</p><ul><li><p>饿汉模式在多线程下没有线程安全问题，多线程可以同时访问</p></li><li><p>懒汉模式在多线程下有线程安全问题，可能创建多个类的实例</p></li></ul><p>解决懒汉模式在多线程下的线程安全问题</p><p>方案一：加互斥锁，不过多线程下是顺序执行的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ=<span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：双重检查锁定，一开始还未创建实例时是顺序执行的，创建后可以并行执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ=<span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二中m_taskQ = new TaskQueue执行过程中，正常过程如下：</p><ul><li><p>第一步：分配内存用于保存 TaskQueue 对象。</p></li><li><p>第二步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p></li><li><p>第三步：使用 m_taskQ 指针指向分配的内存。</p></li></ul><p>但是被重新排序以后执行顺序可能会变成这样：</p><ul><li><p>第一步：分配内存用于保存 TaskQueue 对象。</p></li><li><p>第二步：使用 m_taskQ 指针指向分配的内存。</p></li><li><p>第三步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p></li></ul><p>此时可能会出现这种情况，一个线程执行的顺序如上，执行到第二步时，m_taskQ不等于nullptr了，此时其他线程遇到第一个检查时就可以直接通过并返回指针，造成异常的访问情况</p><p>方案三：双重锁定+使用C++11的atomic规定指令执行顺序，使用原子操作可以使得机器指令按顺序执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TaskQueue* task = m_taskQ.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span>(task==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            task = m_taskQ.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span>(task==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                task=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">                m_taskQ.<span class="built_in">store</span>(task);</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//static TaskQueue* m_taskQ;</span></span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line">    <span class="type">static</span> atomic&lt;TaskQueue*&gt; m_taskQ;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TaskQueue* TaskQueue::m_taskQ=nullptr;</span></span><br><span class="line">atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案四：静态局部对象(懒汉模式多线程下最简单的方案)</p><p>原理:<code>如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> TaskQueue taskQ;</span><br><span class="line">        <span class="keyword">return</span> &amp;taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* queue = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    queue-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details> ]]></content>
      
      
      <categories>
          
          <category> 面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11-右值引用</title>
      <link href="/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>lvalue: 可以取地址</p><p>rvalue: 不可取地址</p><p>引用就是别名</p><p>只能通过左值去初始化左值引用，右值去初始化右值引用</p><p>常量的左值引用是万能的引用类型，可以用左值、左值引用、常量的右值引用</p><p>右值引用：延长临时变量的时间， A a=临时</p><p>左值引用：用来函数传递参数</p><p>移动构造函数-复用其他对象中的资源(堆内存)（浅拷贝+其他对象指针指向空）</p><p>右值引用：复用匿名对象所有资源</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为OD题库</title>
      <link href="/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/"/>
      <url>/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-最大化资源控制成本"><a href="#1-最大化资源控制成本" class="headerlink" title="1.最大化资源控制成本"></a>1.最大化资源控制成本</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决个任务混部问题: 有taskNum项任务，每个任务有开始时间 (startTime) ，结束时间(endTime)并行度(parallelism) 三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放(结束时刻不占用)。任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行请你计算完成这批任务混部最少需要多少服务器，从而最大最大化控制资源成本。<br><strong>输入描述:</strong><br>第一行输入为taskNum，表示有taskNum项任务接下来taskNum行，每行三个整数，表示每个任务的开始时间(startTime ) ，结束时间 (endTime ) ，并行度 (parallelism)<br><strong>输出描述:</strong><br>个整数，表示最少需要的服务器数量<br><strong>示例1</strong> 输入输出示例仅供调试，后台判断数据一般不包含示例输入<br>3<br>2 3 1<br>6 9 2<br>0 5 1<br><strong>输出</strong><br>2</p><p>说明共有三个任务，第一个任务在时间区间[2，3]运行，占用1个服务器，第二个任务在时间区间[6，9] 运行，占用2个服务器，第三个任务在时间区间[0，5]运行，占用1个服务器，需要最多服务器的时间区间为[2，3]和[6，9] ，需要2个服务器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];<span class="comment">//小顶堆,结束时间最早的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">task</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;task[i][<span class="number">0</span>]&gt;&gt;task[i][<span class="number">1</span>]&gt;&gt;task[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//priority_queue存放未完成的task</span></span><br><span class="line">    <span class="comment">//每次只需要比较堆顶的结束时间和当前任务的开始时间就可以得知当前任务是否可以加入</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务按照开始时间升序</span></span><br><span class="line">    <span class="built_in">sort</span>(task.<span class="built_in">begin</span>(),task.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> max_res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur_res=<span class="number">0</span>;<span class="comment">//优先队列里面的任务对应并发度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;task.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将结束时间小于当前任务开始时间的任务清空</span></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">top</span>()[<span class="number">0</span>]&lt;task[i][<span class="number">0</span>])&#123;</span><br><span class="line">                cur_res-=pq.<span class="built_in">top</span>()[<span class="number">1</span>];</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(vector&lt;<span class="type">int</span>&gt;&#123;task[i][<span class="number">1</span>],task[i][<span class="number">2</span>]&#125;);</span><br><span class="line">        cur_res+=task[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur_res&gt;max_res) max_res=cur_res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-完美走位"><a href="#2-完美走位" class="headerlink" title="2.完美走位"></a>2.完美走位</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>输入一个长度为4的倍数的字符串，字符串中仅包含WASD四个字母将这个字符串中的连续子串用同等长度的仅包含WASD的 字符串替换Q，如果替换后整个字符串中WASD四个字母出现的频数相同，那么我们称替换后的字符串是“完美走位”。求子串的最小长度。如果输入字符串已经平衡则输出0.<br><strong>二、输入</strong><br>一行字符表示给定的字符串s<br>数据范围:<br>1&lt;=n&lt;=10^5且n是4的倍数，字符串中仅包含WASD四个字母<br><strong>三、输出</strong><br>一个整数表示答案<br><strong>四、样例输入输出</strong><br>输入:<br>WASDAASD<br>输出:</p><p>1<br>说明:<br>将第二个A替换为W，即可得到完美走位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">滑动区间内为可自由变更的区间，若滑动区间的长度可以&gt;=最大值与各个字母的差</span></span><br><span class="line"><span class="comment">且二者的差值为4的整数倍，滑动区间满足</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char_count;</span><br><span class="line">    <span class="comment">//初始化不能省略</span></span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;S&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;D&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: str)</span><br><span class="line">    &#123;</span><br><span class="line">        char_count[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;A&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;S&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;D&#x27;</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//出现最多的字母</span></span><br><span class="line">    <span class="type">int</span> max_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空闲的字母数</span></span><br><span class="line">    <span class="type">int</span> surplus_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始时，滑动窗口的长度为1,滑动窗口外的相应字母--</span></span><br><span class="line">    char_count[str[<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;str.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要重新赋值，不然会保留最开始的最大值</span></span><br><span class="line">        max_char_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)&#123;</span><br><span class="line">            max_char_num=<span class="built_in">max</span>(max_char_num,x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;最大的字母数:&quot;&lt;&lt;max_char_num&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//滑动窗口的长度也是可自由分配字母的个数</span></span><br><span class="line">        length=right-left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//需要改变的字母数</span></span><br><span class="line">        <span class="type">int</span> required=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)</span><br><span class="line">        &#123;</span><br><span class="line">            required+=(max_char_num-x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;需要改变的字母数&quot;&lt;&lt;required&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;区间长度&quot;&lt;&lt;length&lt;&lt;&quot;,&quot;&lt;&lt;&quot;区间范围&quot;&lt;&lt;left&lt;&lt;&quot;,&quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        surplus_char_num=length-required;</span><br><span class="line">        <span class="comment">//区间满足，左指针左移</span></span><br><span class="line">        <span class="keyword">if</span>(surplus_char_num&gt;=<span class="number">0</span>&amp;&amp;surplus_char_num%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(length&lt;ans) ans=length;</span><br><span class="line">            char_count[str[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//区间不满足，右指针右移</span></span><br><span class="line">            <span class="comment">//右指针需要先右移</span></span><br><span class="line">            right++;</span><br><span class="line">            char_count[str[right]]--;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="3-羊、狼、农夫过河"><a href="#3-羊、狼、农夫过河" class="headerlink" title="3.羊、狼、农夫过河"></a>3.羊、狼、农夫过河</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。农夫有一艘容量固定的船，能够承载固定数量的动物。要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。<br>备注: 农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊农夫自身不占用船的容量。<br><strong>输入描述</strong><br>第一行输入为M，N，x，分别代表羊的数量，狼的数量，小船的容量.<br><strong>输出描述</strong><br>输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。(若无法满足条件则输出0)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> minTimes=INT_MAX;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transport</span><span class="params">(<span class="type">int</span> m0, <span class="type">int</span> n0, <span class="type">int</span> x, <span class="type">int</span> m1, <span class="type">int</span> n1, <span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=m0+n0)&#123;</span><br><span class="line">        <span class="keyword">if</span>(times+<span class="number">1</span>&lt;minTimes) minTimes=times+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层保证羊的数量小于容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m0 &amp;&amp; i&lt;=x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证羊+狼不超重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n0 &amp;&amp; i+j&lt;=x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证两岸的羊数量&gt;=狼(要么羊数量为0)</span></span><br><span class="line">            <span class="keyword">if</span>((m0-i==<span class="number">0</span>||m0-i&gt;n0-j)&amp;&amp;(m1+i==<span class="number">0</span>||m1+i&gt;n1+j))&#123;</span><br><span class="line">                <span class="built_in">transport</span>(m0-i,n0-j,x,m1+i,n1+j,times+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N,X;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;X;</span><br><span class="line">    <span class="built_in">transport</span>(M,N,X,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(minTimes==INT_MAX)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minTimes&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="4-字符串重新排列"><a href="#4-字符串重新排列" class="headerlink" title="4.字符串重新排列"></a>4.字符串重新排列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出</p><p>1、单词内部调整: 对每个单词字母重新按字典序排序<br>2、单词间顺序调整:<br>1)统计每个单词出现的次数，并按次数 降序排列Q<br>2)次数相同，按单词长度Q 升序排列<br>3)次数和单词长度均相同，按字典升序排列<br>请输出处理后的字符串，每个单词以一个空格分隔<br><strong>输入描述:</strong><br>一行字符串，每个字符取值范围:[a-ZA-z0-9] 以及空格，字符串长度范围:[1，1000]<br>例1:<br>输入<br>This is an apple<br>输出<br>an is This aelpp<br>例2:<br>输入:<br>My sister is in the house not in the yard<br>输出:<br>in in eht eht My is not adry ehosu eirsst</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a, pair&lt;string,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second!=b.second) <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.<span class="built_in">size</span>()!=b.first.<span class="built_in">size</span>()) <span class="keyword">return</span> a.first.<span class="built_in">size</span>()&lt;b.first.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pos = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="comment">//第一步，单词内部调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步，单词间调整</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; str_count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str_count.<span class="built_in">count</span>(v[i]))&#123;</span><br><span class="line">            str_count[v[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str_count[v[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">str_count_vec</span>(str_count.<span class="built_in">begin</span>(),str_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(str_count_vec.<span class="built_in">begin</span>(),str_count_vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : str_count_vec)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;item.second; i++) cout&lt;&lt;item.first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="5-租车骑绿岛"><a href="#5-租车骑绿岛" class="headerlink" title="5.租车骑绿岛"></a>5.租车骑绿岛</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，做最大载重M。给出部门每个人的体重，请问最多需要租用多少双人自行车</p><p><strong>输入描述:</strong><br>第一行两个数字m、n，分别代表自行车限重，部门总人数。第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。0&lt;me=200<br>0&lt;n&lt;=1000000<br><strong>输出描述:</strong><br>最小需要的双人自行车数量。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>34<br>3 2 2 1<br>输出</p><p>3</p><p><strong>思路</strong>：这个问题可以通过贪心算法来解决。首先，将所有人的体重从小到大排序。然后，从最轻的人开始，每次选择最轻的人和最重的人搭配在一起。如果两个人的体重之和不超过自行车的限重，则他们可以共用一辆自行车；否则，最重的人需要单独使用一辆自行车。重复这个过程，直到所有人都被安排好。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min_bikes</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> weights[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + n);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bikes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weights[left] + weights[right] &lt;= m) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bikes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> weights[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min_bikes</span>(m, n, weights) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="6-无向图染色"><a href="#6-无向图染色" class="headerlink" title="6.无向图染色"></a>6.无向图染色</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给一个无向图Q 染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方案?<br><strong>输入描述:</strong><br>第一行输入M(图中节点数) N(边数)<br>后续N行格式为: V1 V2表示一个V1到V2的边<br>数据范围: 1 &lt;= M &lt;= 15.0 &lt;= N &lt;= M3，不能保证所有节点都是连通的</p><p><strong>输出描述:</strong><br>输出一个数字表示染色方案的个数<br>示例1:<br>输入:<br>4 4<br>1 2<br>2 4<br>3 4<br>1 3<br><strong>输出:</strong></p><p>7<br>说明: 4个节点，4条边，1号节点和2号节点相连，2号节点和4号节点相连，3号节点和4号节点相连，1号节点和3号节点相连，若想必须保证相邻两个节点不能同时为红色，总共7种方案。</p><p><strong>思路</strong>：遍历所有的染色方案，再逐一判断每条边的两边是否都是红色</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//存入结点时，以0号结点开头</span></span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;a<span class="number">-1</span>,b<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0101表示0号结点为黑，1号结点为红，2号结点为黑，3号结点为红</span></span><br><span class="line"><span class="comment">    从右边往左边分别是0,1,2,3</span></span><br><span class="line"><span class="comment">    为了取得相应结点的颜色，需要右移0,1,2,3位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;m); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//检测所有边的两端</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: edges)&#123;</span><br><span class="line">            <span class="type">int</span> node1=i&gt;&gt;edge.first;</span><br><span class="line">            <span class="type">int</span> node2=i&gt;&gt;edge.second;</span><br><span class="line">            <span class="keyword">if</span>((node1&amp;<span class="number">1</span>) &amp;&amp; (node2&amp;<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="7-单向链表中间节点"><a href="#7-单向链表中间节点" class="headerlink" title="7.单向链表中间节点"></a>7.单向链表中间节点</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>求单向链表Q 中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。</p><p><strong>输入描述:</strong><br>第一行 链表头节点地址path 后续输入的节点数n后续输入每行表示一个节点，格式:”节点地址 节点值 下一个节点地址(-1表示空指针“输入保证链表不会出现环，并且可能存在一些节点不属于链表输出描述:<br>链表中间节点值。<br>测试用例:<br><strong>输入:</strong><br>00010 4<br>00000 3 -1<br>00010 5 12309<br>11451 6 00000<br>12309 7 11451<br>输出:<br>6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; node_value;</span><br><span class="line">    map&lt;string,string&gt; node_node;</span><br><span class="line">    string head;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;head&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string start,end;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin&gt;&gt;start&gt;&gt;val&gt;&gt;end;</span><br><span class="line">        node_value[start]=val;</span><br><span class="line">        node_node[start]=end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍求长度</span></span><br><span class="line">    string tmp=head;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(node_node[tmp]!=<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;node_value[tmp]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="8-划分为k个相等的子集"><a href="#8-划分为k个相等的子集" class="headerlink" title="8.划分为k个相等的子集"></a>8.划分为k个相等的子集</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定一个整数数组  <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>思路一：动态规划</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / k;</span><br><span class="line">    <span class="comment">//dp压缩状态，dp[i]表示状态i下是否可以划分为x个target</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举每一种状态，并由当前状态推导出后面的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>()); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第j位是否为1,即是否已经使用</span></span><br><span class="line">            <span class="type">int</span> flag=i&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;dp[i]+nums[j]&lt;=target)&#123;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=(dp[i]+nums[j])%target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>())<span class="number">-1</span>]==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二：回溯法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum%k!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target=sum/k;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,bucket,k,target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt;&amp; bucket, <span class="type">int</span> k, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//每个球有k个选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;bucket[i]==bucket[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]+nums[index]&gt;target) <span class="keyword">continue</span>;</span><br><span class="line">        bucket[i]+=nums[index];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">backtrack</span>(nums,index+<span class="number">1</span>,bucket,k,target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        bucket[i]-=nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="9-最多颜色的车"><a href="#9-最多颜色的车" class="headerlink" title="9.最多颜色的车"></a>9.最多颜色的车</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>在一个狭小的路口，每秒只能通过一辆车，假好车辆的颜色只有 3 种，找出N 秒内经过的最多颜色的车辆数量。<br>三种颜色编号为0，1，2<br><strong>输入描述</strong><br>第一行输入的是通过的车辆颜色信息<br>[0,1,1,2]代表4 秒钟通过的车辆颜色分别是 0，1，1，2</p><p>第二行输入的是统计时间窗，整型，单位为秒输出描述<br>输出指定时间窗内经过的最多颜色的车辆数量<br>样例<br>样例一:<br>输入<br>0 1 2 1<br>3<br>输出<br>2<br>样例解释<br>在 3 秒时间窗内，每个颜色最多出现 2 次。例为: [1,2,1]<br>样例二:<br>输入<br>0 1 2 1<br>2<br>输出</p><p>1<br>样例解释<br>在 2 秒时间窗内，每个颜色最多出现1 次</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="type">int</span> window;</span><br><span class="line">    cin&gt;&gt;window;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cars;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> found=input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,found)));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(found+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="comment">//初始化滑动窗口</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; car_count=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;window; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滑动窗口滑动</span></span><br><span class="line">    <span class="type">int</span> max_res=*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=window; i&lt;cars.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]++;</span><br><span class="line">        car_count[cars[i-window]]--;</span><br><span class="line">        max_res=<span class="built_in">max</span>(max_res,*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="10-不含101的数"><a href="#10-不含101的数" class="headerlink" title="10.不含101的数"></a>10.不含101的数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>小明在学习二进制时，发现了一类不含 101的数，也就是：将数字用二进制表示，不能出现 101 。现在给定一个整数区间 [l,r] ，请问这个区间包含了多少个不含 101 的数？</p><p><strong>输入描述</strong></p><p>输入的唯一一行包含两个正整数 l， r（ 1 ≤ l ≤ r ≤ 10^9）。</p><p><strong>输出描述</strong></p><p>输出的唯一一行包含一个整数，表示在 [l,r] 区间内一共有几个不含 101 的数。</p><p><strong>样例一：</strong></p><p><strong>输入</strong></p><p>1 10</p><p><strong>输出</strong></p><p>8</p><p>样例解释：区间 [1,10] 内， 5 的二进制表示为 101 ，10的二进制表示为 1010 ，因此区间 [ 1 , 10 ] 内有 10−2=8个不含 101的数。</p><p>思路一：暴力法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;64&gt; <span class="title">bit</span><span class="params">(num)</span></span>;</span><br><span class="line">    string bin=bit.<span class="built_in">to_string</span>();</span><br><span class="line">    cout&lt;&lt;bin&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(bin.<span class="built_in">find</span>(<span class="string">&quot;101&quot;</span>)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValid</span>(i))&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：数位dp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> p, <span class="type">bool</span> flag, vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; binary_dp, vector&lt;<span class="type">int</span>&gt; single_binary_nums, <span class="type">int</span> pre, <span class="type">int</span> prepre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == single_binary_nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag &amp;&amp; binary_dp[p][pre][prepre] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> binary_dp[p][pre][prepre];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = flag ? single_binary_nums[p] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; pre == <span class="number">0</span> &amp;&amp; prepre == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="built_in">search</span>(p + <span class="number">1</span>, flag &amp;&amp; i == index, binary_dp, single_binary_nums, i, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        binary_dp[p][pre][prepre] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 10 -&gt; [1,0,1,0,0]</span></span><br><span class="line">    bitset&lt;20&gt; number;</span><br><span class="line">    number = num;</span><br><span class="line">    string number_str=number.<span class="built_in">to_string</span>(); </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">single_binary_nums</span><span class="params">(number_str.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;number_str.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        single_binary_nums[i] = (<span class="type">int</span>)number_str[i]<span class="number">-48</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">binary_dp</span>(single_binary_nums.<span class="built_in">size</span>(), vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(<span class="number">0</span>, <span class="literal">true</span>, binary_dp, single_binary_nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> left, right;</span><br><span class="line">    cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(right)-<span class="built_in">dp</span>(left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="11-过滤组合字符串"><a href="#11-过滤组合字符串" class="headerlink" title="11.过滤组合字符串"></a>11.过滤组合字符串</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母<br>0关联”a””b””c”<br>1关联”d”,”e”,”?<br>2关联”g”,”h”””<br>3 关联”,”k”,””<br>4 关联”m””n””o”<br>5关联”p”,”q”””<br>6关联”s”,”t”<br>7 关联”u””v”<br>8关联”w””x”<br>9关联”y”,”z”<br>例如7关联”u””v”，8关联”x””w”，输入一个字符串例如“78”和一个屏蔽字符串“ux”,那么“78”可以组成多个字符串例如:“ux”，“uw”“vx”，“ww”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。<br>示例:<br>输入:<br>78<br>ux<br>输出:<br>uw vx vw<br>说明: ux完全包含屏蔽字符串ux，因此别除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">//0</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>,<span class="comment">//1</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,<span class="comment">//2</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,<span class="comment">//3</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,<span class="comment">//4</span></span><br><span class="line">    <span class="string">&quot;pqr&quot;</span>,<span class="comment">//5</span></span><br><span class="line">    <span class="string">&quot;st&quot;</span>,<span class="comment">//6</span></span><br><span class="line">    <span class="string">&quot;uv&quot;</span>,<span class="comment">//7</span></span><br><span class="line">    <span class="string">&quot;wx&quot;</span>,<span class="comment">//8</span></span><br><span class="line">    <span class="string">&quot;yz&quot;</span>,<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, string&amp; digits, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> digit = digits[index]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    string letters = letterMap[digit];<span class="comment">//取数字对应字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;letters.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(index+<span class="number">1</span>,digits,s+letters[i]);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符是否全部包含</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string str1, string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str1)</span><br><span class="line">    &#123;</span><br><span class="line">        set1.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str2)</span><br><span class="line">    &#123;</span><br><span class="line">        set2.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: set2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.<span class="built_in">count</span>(x)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string digits;</span><br><span class="line">    string filter;</span><br><span class="line">    cin&gt;&gt;digits&gt;&gt;filter;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,digits,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    string result_str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(filter,x))&#123;</span><br><span class="line">            result_str+=(x+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result_str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="12-真正的密码"><a href="#12-真正的密码" class="headerlink" title="12.真正的密码"></a>12.真正的密码</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>在一行中输入一个字符串数组Q，如果其中一个字符串的所有以索引0开头的子串在数组中都有，那么这个字符串就是潜在密码，在所有潜在密码中最长的是真正的密码，如果有多个长度相同的真正的密码，那么取字典序最大的为唯一的真正的密码，求唯一的真正的密码</p><p>示例1:<br>输入: h he hel hell hello o ok n ni nin ninj ninjaQ<br>输出: ninja说明:按要求，hello、ok、ninja都是潜在密码。检查长度，hello、ninja是真正的密码。检查字典序Q，ninja是唯一真正密码。<br>示例2:<br>输入:<br>a b c d f<br>输出:<br>说明: 按要求，a b c d f都是潜在密码。检查长度，a b c d f 是真正的密码。检查字典序，f是唯一真正密码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有字符串放入哈希集合</span></span><br><span class="line">    set&lt;string&gt; word_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        word_set.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的密码</span></span><br><span class="line">    string true_pass_word=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序检查每一个词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        <span class="comment">// 条件1：检查这个词所有以索引0开头的子串在数组中是否都有</span></span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 以索引0开头的子串</span></span><br><span class="line">            string sub_str=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(!word_set.<span class="built_in">count</span>(sub_str))&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">// 条件2：比较密码长度</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;true_pass_word.<span class="built_in">size</span>())</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            <span class="comment">// 条件3：比较密码字典排序</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()==true_pass_word.<span class="built_in">size</span>()&amp;&amp; s&gt;true_pass_word)&#123;</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; true_pass_word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="13-最小调整顺序次数"><a href="#13-最小调整顺序次数" class="headerlink" title="13.最小调整顺序次数"></a>13.最小调整顺序次数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_number;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_number);</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">stoi</span>(input_number);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; operations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>*number;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        operations.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否有序</span></span><br><span class="line">    <span class="type">bool</span> in_order = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;string&gt; operaion_str = operations[i];</span><br><span class="line">        <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;head&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size &gt; <span class="number">0</span> &amp;&amp; in_order) &#123;</span><br><span class="line">                in_order = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;tail&quot;</span>) &#123;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_order) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                in_order = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="14-星球移居计划-n"><a href="#14-星球移居计划-n" class="headerlink" title="14.星球移居计划-n"></a>14.星球移居计划-n</h2><h2 id="15-需要打开多少监视器-n"><a href="#15-需要打开多少监视器-n" class="headerlink" title="15.需要打开多少监视器-n"></a>15.需要打开多少监视器-n</h2><h2 id="16-最佳种树距离-n"><a href="#16-最佳种树距离-n" class="headerlink" title="16.最佳种树距离-n"></a>16.最佳种树距离-n</h2><h2 id="17-阿里巴巴寻宝盒-n"><a href="#17-阿里巴巴寻宝盒-n" class="headerlink" title="17.阿里巴巴寻宝盒-n"></a>17.阿里巴巴寻宝盒-n</h2><h2 id="18-选修课-n"><a href="#18-选修课-n" class="headerlink" title="18.选修课-n"></a>18.选修课-n</h2><h2 id="19-探索地块建立"><a href="#19-探索地块建立" class="headerlink" title="19.探索地块建立"></a>19.探索地块建立</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给一块n<em>m的地块，相当于n</em>m的二维数组，每个元素的值表示这个小地块的发电量;求在这块地上建立正方形的边长为c的发电站，发电量满足目标电量k的地块数量。输入描述:<br>第一行为四个按空格分隔的正整数，分别表示n,m,c k后面n行整数，表示每个地块的发电量输出描述:<br>输出满足条件的地块数量<br>示例:<br>输入:<br>2 5 2 6 // n m ck，下面每行是nm地块每格的发电量<br>1 3 4 5 8<br>2 3 6 7 1<br>输出:<br>4<br>说明:<br>满足条件的地块有以下几种<br>第一种:<br>1 3<br>2 3<br>第二种:<br>3 4<br>3 6<br>第三种:<br>4 5<br>6 7<br>第四种:<br>5 8<br>7 1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;P,<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P[x2][y2]-P[x1<span class="number">-1</span>][y2]-P[x2][y1<span class="number">-1</span>]+P[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_area_count</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> threshold, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//1、生成前缀和子矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="comment">//s[i][j]表示以[i,j]作为矩阵最右下角的最大矩阵的前缀和</span></span><br><span class="line">            <span class="comment">//解释：以点[i,j]作为作为最右下角的最大矩阵的前缀和需要加上点[i-1,j]和点[i,j-1]的前缀和，然而会重复多加一个点[i-1][j-1]的前缀和，所以要减一个</span></span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2、遍历前缀和矩阵，获得边长等于c的矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-c+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m-c+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getRect</span>(s,i,j,i+c<span class="number">-1</span>,j+c<span class="number">-1</span>)&gt;=threshold) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> c = params[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        matrix.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_area_count</span>(matrix, k, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="20-模拟商场优惠打折"><a href="#20-模拟商场优惠打折" class="headerlink" title="20.模拟商场优惠打折"></a>20.模拟商场优惠打折</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>模拟商场优惠打折，有三种 优惠券Q 可以用，满减券、打折券和无门槛券满减券: 满100减10，满200减20，满300减30，满400减40，以此类推不限制使用;打折券: 固定折扣92折，且打折之后向下取整Q，每次购物只能用1次:无门槛券: 一张券减5元，没有使用限制;<br>每个人结账使用优惠券时有以下限制: 每人每次只能用两种优惠券，并且同一种优惠券必须一次用完，不能跟别的穿插使用(比如用一张满减，再用一张打折，再用一张满减，这种顺序<br>不行)求不同使用顺序下每个人用完券之后得到的最低价格和对应使用优惠券的总数:如果两种顺序得到的价格一样低，就取使用优惠券数量较少的那个。输入描述:<br>第一行三个数字m,n,k，分别表示每个人可以使用的满减券、打折券和无门槛券的数量第二行一个数字x,表示有几个人购物<br>后面x行数字，依次表示是这几个人打折之前的商品总价输出描述:<br>输出每个人使用券之后的最低价格和对应使用优惠券的数量示例:<br>输入:<br>3 2 5<br>3<br>100<br>200<br>400<br>输出:<br>65 6<br>135 8<br>275 8</p><p>说明</p><p>第一个人使用 1 张满减券和5张无门槛券价格最低</p><p>第二个人使用 3 张满减券和5张无门槛券价格最低</p><p>第三个人使用 3 张满减券和5张无门槛券价格最低</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后打折</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_a</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后满减</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_b</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_c</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>; </span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_d</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first == b.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string input_params_x;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params_x);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">stoi</span>(input_params_x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> price = <span class="built_in">stoi</span>(input_str);</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_a</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_b</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_c</span>(price, m, k));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_d</span>(price, n, k));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照价格降序，用券数降序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), comp);</span><br><span class="line">        cout &lt;&lt; result[<span class="number">0</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; result[<span class="number">0</span>].second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="21-区间覆盖"><a href="#21-区间覆盖" class="headerlink" title="21.区间覆盖"></a>21.区间覆盖</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定坐标轴上的一组线段，线段的起点和终点均为整数并且长度不小于1，请你从中找到最少数量的线段，这些线段可以覆盖住所有线段。<br>输入描述<br>第一行输入为所有线段的数量，不超过10000，后面每行表示一条线段，格式为”x,y”x和y 分别表示起点和终点，取值范围是[-10^5，10^5]。输出描述<br>最少线段数量，为正整数。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>1,4<br>2,5<br>3,6<br>输出</p><p>2</p><p>思路<a href="https://www.programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%96%B9%E6%B3%95%E4%B8%80">代码随想录</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按左端点从小到大排 ,左端点相同，右端点大的在前面</span></span><br><span class="line">    <span class="keyword">if</span>(x.first!=y.first)</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;       </span><br><span class="line">    <span class="keyword">return</span> x.second&gt;y.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; range;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    range.first = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">    range.second = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="type">int</span> destiny=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        cin &gt;&gt; input_str;</span><br><span class="line">        destiny=<span class="built_in">max</span>(destiny,<span class="built_in">split</span>(input_str).second);</span><br><span class="line">        ranges.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp); </span><br><span class="line">    <span class="type">int</span> curDistance=ranges[<span class="number">0</span>].second;<span class="comment">//当前覆盖最远距离</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextDistance=ranges[<span class="number">0</span>].second;<span class="comment">//下一步覆盖最远距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(ranges[i].first&lt;=curDistance)&#123;</span><br><span class="line">           nextDistance=<span class="built_in">max</span>(nextDistance,ranges[i].second);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           i--;</span><br><span class="line">           ans++;</span><br><span class="line">           curDistance=nextDistance;</span><br><span class="line">           <span class="keyword">if</span>(nextDistance==destiny) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curDistance!=destiny) ans++;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="22-二元组个数"><a href="#22-二元组个数" class="headerlink" title="22.二元组个数"></a>22.二元组个数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定两个数组Qa，b，若l == ] 则称[,] 为一个二元组，求在给定的两个数组中，二元组的个数。输入描述:<br>第一行输入 m<br>第二行输入m个数，表示第一个数组<br>第三行输入 n<br>第四行输入n个数，表示第二个数组<br>输出描述:<br>二元组Q个数。<br>示例1:<br>输入:<br>d<br>1 2 34<br>输出:<br>说明: 二元组个数为 1个<br>示例2:<br>输入:<br>6<br>1 1 2 2 4 5<br>3<br>2 2 4<br>输出:<br>5<br>说明:二元组个数为 5 个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_a;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_a_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        nums_a.<span class="built_in">push_back</span>(a);</span><br><span class="line">        nums_a_count[a] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_b;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_b_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        nums_b.<span class="built_in">push_back</span>(b);</span><br><span class="line">        nums_b_count[b] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums_a_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums_b_count.<span class="built_in">count</span>(x.first)) &#123;</span><br><span class="line">            result += x.second * nums_b_count[x.first];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="23-连接器问题"><a href="#23-连接器问题" class="headerlink" title="23.连接器问题"></a>23.连接器问题</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>有一组区间[a0，b0]，[a1，b1]，… (a，b表示起点，终点) ，区间有可能重叠、相邻，重叠或相邻则可以合并为更大的区间;给定一组连接器[x1，x2，x3，…] (x表示连接器的最大可连接长度，即x&gt;=gapQ)，可用于将分离的区间连接起来，但两个分离区间之间只能使用1个连接器请编程实现使用连接器后，最少的区间数结果。<br>区间数量&lt;10000，ab均 &lt;=10000<br>连接器梳理&lt;10000; x &lt;= 10000<br>输入描述<br>区间组: [1,10],[15,201,[18,30],[33,40]</p><p>连接器组: [5,4,3,2]<br>输出描述</p><p>1<br>说明:<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。示例1 输入输出示例仅供调试，后台判题数据一般不包含示例入<br>[1,10],[15,20],[18,30],[33,40]<br>[5,4, 3, 2]<br>输出</p><p>1<br>说明<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    string range_str;</span><br><span class="line">    cin &gt;&gt; range_str;</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp_ranges = <span class="built_in">split</span>(range_str);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp_ranges.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; single_range;</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i<span class="number">-1</span>]);</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i]);</span><br><span class="line">            ranges.<span class="built_in">push_back</span>(single_range);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string conntetor_str;</span><br><span class="line">    cin &gt;&gt; conntetor_str;</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; connectors = <span class="built_in">split</span>(conntetor_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并区间</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merge_ranges;</span><br><span class="line">    merge_ranges.<span class="built_in">push_back</span>(ranges[<span class="number">0</span>]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; range_diffs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range1 = merge_ranges[merge_ranges.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range2 = ranges[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (range2[<span class="number">0</span>] &lt;= range1[<span class="number">1</span>]) &#123;</span><br><span class="line">            merge_ranges.<span class="built_in">pop_back</span>();</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;range1[<span class="number">0</span>], <span class="built_in">max</span>(range1[<span class="number">1</span>], range2[<span class="number">1</span>])&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            range_diffs.<span class="built_in">push_back</span>(range2[<span class="number">0</span>] - range1[<span class="number">1</span>]);</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(range2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range_diffs.<span class="built_in">begin</span>(), range_diffs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(connectors.<span class="built_in">begin</span>(), connectors.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = merge_ranges.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connectors.<span class="built_in">size</span>()&amp;&amp;idx&lt;range_diffs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectors[i] &gt;= range_diffs[idx]) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            result--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="24-打印机队列"><a href="#24-打印机队列" class="headerlink" title="24.打印机队列"></a>24.打印机队列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>有5台打印机打印文件，每台打印机有自己的待打印队列。因为打印的文件内容有轻重缓急之分，<br>所以队列中的文件有1~10不同的代先级，其中数宁越大优先级越高打印机会从自己的待打印队列中选择优先级最高的文件来打印。如果存在两个优先级一样的文件，则选择最早进入队列的那个文件现在请你来模拟这5台打印机的打印过程。<br>输入描述<br>每个输入包含1个测试用例，每个测试用例第一行给出发生事件的数量N (0 &lt; N&lt; 1000)。<br>接下来有 N 行，分别表示发生的事件。<br>共有如下两种事件:<br>1.“IN P NUM”，表示有一个拥有优先级 NUM 的文件放到了打印机 P 的待打印队列中。 (0&lt; P&lt;= 5, 0&lt; NUM &lt;= 10);<br>2.“OUT P”，表示打印机 P 进行了一次文件打印，同时该文件从待打印队列中取出。 (0&lt; P&lt;=57<br>输出描述<br>对于每个测试用例，每次”OUT P”事件，请在一行中输出文件的编号如果此时没有文件可以打印，请输出”NULL“。文件的编号定义为”IN P NUM”事件发生第 次，此处待打印文件的编号为x。编号从1开始.示例1 输入输出示例仅供调试，后台判断数据一般不包含示例<br>输入</p><p>7<br>IN 1 1<br>IN 1 2<br>IN 1 3<br>IN 2 1<br>OUT 1<br>OUT 2<br>OUT 2<br>输出</p><p>3</p><p>4</p><p>NULL</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(File a, File b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.priority-a.priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_count_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_count_str);</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">stoi</span>(input_count_str);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;File&gt;&gt; <span class="built_in">printers</span>(<span class="number">5</span>, <span class="built_in">vector</span>&lt;File&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        string temp_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,temp_str);</span><br><span class="line">        vector&lt;string&gt; operations = <span class="built_in">split</span>(temp_str);</span><br><span class="line">        string type = operations[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;IN&quot;</span> == type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">stoi</span>(operations[<span class="number">2</span>]);</span><br><span class="line">            flag++;</span><br><span class="line">            File file;</span><br><span class="line">            file.order = flag;</span><br><span class="line">            file.priority = num;</span><br><span class="line">            printers[p - <span class="number">1</span>].<span class="built_in">push_back</span>(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;OUT&quot;</span>==type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (printers[p<span class="number">-1</span>].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>(), printers[p<span class="number">-1</span>].<span class="built_in">end</span>(), comp);</span><br><span class="line">                File file = printers[p<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                cout&lt;&lt;file.order&lt;&lt;endl;</span><br><span class="line">                printers[p<span class="number">-1</span>].<span class="built_in">erase</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="25-处理器问题"><a href="#25-处理器问题" class="headerlink" title="25.处理器问题"></a>25.处理器问题</h2><h2 id="26-日志首次上报最多积分"><a href="#26-日志首次上报最多积分" class="headerlink" title="26.日志首次上报最多积分"></a>26.日志首次上报最多积分</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/21/hello-world/"/>
      <url>/2023/05/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无重复的最长字串</title>
      <link href="/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
      <url>/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>遍历字符串，找每个字符为首的最长子串。时间复杂度为O(n)*O(以首字符开始的字符串)，寻找首字符开始的字符串时间复杂度O(n^2)，总的时间复杂度为O(n^3)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//要考虑到空串的情况</span></span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i,j);<span class="comment">// 子串范围s[i,j)</span></span><br><span class="line">                <span class="keyword">if</span>(str.indexOf(s.charAt(j)) &lt; <span class="number">0</span>)&#123;<span class="comment">//indexOf也是O(n)的方法，所以总的时间复杂度时O(n^3)</span></span><br><span class="line">                    length ++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(length&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h2><p>用哈希表，可以减少找每个字符为首的最长子串的时间，那么就可以从最初的O(n^2)降低到O(n),总的时间复杂度就为O(n)*O(n)=0(n^2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length;<span class="comment">// 要考虑到空串的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(s.charAt(j))==<span class="literal">false</span>)&#123;</span><br><span class="line">                    length++;</span><br><span class="line">                    map.put(s.charAt(j),<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxLength&lt;length)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>万万没想到，本题的最佳时间复杂度竟然是O(n)，算法原理如下：<br>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。<br>我们不妨以示例一中的字符串<code>abcabcbb</code> 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><p>以<b>(a)bcabcbb</b>开始的最长字符串为<b>(abc)abcbb</b><br>以<strong>a(b)cabcbb</strong>开始的最长字符串为<strong>a(bca)bcbb</strong><br>以<strong>ab(c)abcbb</strong>开始的最长字符串为<strong>ab(cab)cbb</strong><br>以<strong>abc(a)bcbb</strong>开始的最长字符串为<strong>abc(abc)bb</strong><br>以<strong>abca(b)cbb</strong>开始的最长字符串为<strong>abca(bc)bb</strong><br>以<strong>abcab(c)bb</strong>开始的最长字符串为<strong>abcab(cb)b</strong><br>以<strong>abcabc(b)b</strong>开始的最长字符串为<strong>abcabc(b)b</strong><br>以<b>abcabcb(b)</b>开始的最长字符串为<b>abcabcb(b)</b></p><p>发现了子串的结束位置是非递减的，这里的原因在于，假设第k个字符作为起始位置，rk为终止位置。那么当我们选择第k+1个字符作为起始位置时，首先k+1到rk的位置显然是不重复的，并且我们还可以尝试继续增大rk(不必回到k+1的位置判断)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk &lt; n &amp;&amp; !occ.contains(s.charAt(rk ))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk-1 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234abc&quot;</span>;</span><br><span class="line"><span class="comment">// substring 左闭右开</span></span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 123 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf 可以求字符位置，也可以求字串位置</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">s.indexOf(<span class="string">&quot;23&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt(i) 求指定位置的字符    </span></span><br><span class="line">s.charAt(<span class="number">0</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line">occ.remove(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">occ.add(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 哈希集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><span id="more"></span><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><a href="https://leetcode.cn/problems/two-sum/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    ans[<span class="number">0</span>]=i;</span><br><span class="line">                    ans[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h3><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N)降低到O(1)。</p><p><strong>注意：</strong></p><p>创建一个哈希表，对于每一个 <code>x</code>，我们<strong>首先</strong>查询哈希表中是否存在 <code>target - x</code>，<strong>然后</strong>将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Java-Map接口"><a href="#Java-Map接口" class="headerlink" title="Java Map接口"></a>Java Map接口</h3><p>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的初始化</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//不限定键和值的类型</span></span><br><span class="line">Map&lt;Integer,Integer&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsKey</span></span><br><span class="line">m1.containsKey(<span class="number">3</span>); <span class="comment">//含有key(3)，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">m1.get(<span class="number">3</span>); <span class="comment">//返回指定键所映射的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line">m1.put(<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">//将键值对添加到表中</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>偶的第一篇博客就从markdown语法开始吧，主要参考的是<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a>。从中摘录了可能最常用的语法，并结合其他资源整合而成，那就让我们开始md之旅吧！。<br><span id="more"></span></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a name="Name">标题</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br></pre></td></tr></table></figure><h2 id="段落样式"><a href="#段落样式" class="headerlink" title="段落样式"></a>段落样式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">**粗体文本**</span><br><span class="line">***斜粗体文本***</span><br></pre></td></tr></table></figure><p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>斜粗体文本</em></strong></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~~Hell World~~</span><br></pre></td></tr></table></figure><p><del>Hell World</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><p><u>带下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[^名称]</span><br><span class="line">[^名称]: 解释名称</span><br><span class="line">例：</span><br><span class="line">我用Hexo[^<span class="number">1</span>]搭建了第一个博客</span><br><span class="line">[^<span class="number">1</span>]:一个很好用的博客框架</span><br></pre></td></tr></table></figure><p>我用Hexo<sup><a href="#fn_1" id="reffn_1">1</a></sup>搭建了第一个博客</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项：</span><br><span class="line">    * 第一项嵌套的第一个元素</span><br><span class="line">    * 第一项嵌套的第二个元素</span><br><span class="line"><span class="number">2.</span> 第二项：</span><br><span class="line">    * 第二项嵌套的第一个元素</span><br><span class="line">    * 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><ol><li><p>第一项：</p><ul><li><p>第一项嵌套的第一个元素</p></li><li><p>第一项嵌套的第二个元素</p></li></ul></li><li><p>第二项：</p><ul><li><p>第二项嵌套的第一个元素</p></li><li><p>第二项嵌套的第二个元素</p></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`printf()`</span><br></pre></td></tr></table></figure><h3 id="一段代码"><a href="#一段代码" class="headerlink" title="一段代码"></a>一段代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```加回车</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> [菜鸟教程](https://www.runoob.com)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> &lt;https://www.runoob.com&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> [百度][<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]:https:www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com">菜鸟教程</a></p><p><a href="https://www.runoob.com">https://www.runoob.com</a></p><p><a href="https:www.baidu.com">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png )</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png <span class="string">&quot;标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> [RUNOOB][<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]:http://static.runoob.com/images/runoob-logo.png </span><br></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB" title="标题"></p><p><a href="http://static.runoob.com/images/runoob-logo.png">RUNOOB</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="补充样式"><a href="#补充样式" class="headerlink" title="补充样式"></a>补充样式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;font size=<span class="number">5</span>&gt;&lt;/font&gt; 字体大小</span><br><span class="line">&lt;a style=<span class="string">&quot;color:black&quot;</span>&gt;&lt;/a&gt; 字体颜色</span><br><span class="line">&lt;a style=<span class="string">&quot;text-decoration:none&quot;</span>&gt;&lt;/a&gt; 取消链接下划线</span><br></pre></td></tr></table></figure><h3 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#Name&quot;</span>&gt;&lt;/a&gt; 跳转的起点</span><br><span class="line">&lt;a name=<span class="string">&quot;Name&quot;</span>&gt;&lt;/a&gt; 跳转的终点</span><br></pre></td></tr></table></figure><p><a href="#Name">跳转的起点</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
