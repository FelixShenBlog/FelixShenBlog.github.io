<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DJango教程</title>
      <link href="/2023/07/17/DJango%E6%95%99%E7%A8%8B/"/>
      <url>/2023/07/17/DJango%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Python虚拟环境"><a href="#Python虚拟环境" class="headerlink" title="Python虚拟环境"></a>Python虚拟环境</h2><ul><li>搭建虚拟环境</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m venv venv</span><br></pre></td></tr></table></figure><p>命令解释：m是module的缩写，第一个venv是python模块，用于创建虚拟环境。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230717203950.png" alt=""></p><ul><li>激活虚拟环境</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">venv\Scripts\activate.bat</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230717204418.png" alt=""></p><p>注意：使用cmd，而不是powershell。</p><ul><li>在虚拟环境下安装django</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install django</span><br></pre></td></tr></table></figure><ul><li>将当前Python虚拟环境中暗转的所有包及其版本信息导出到<code>requirements.txt</code>。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure><ul><li>创建Django项目</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django-admin startproject django_course .</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">根目录/</span><br><span class="line">    manage.py</span><br><span class="line">    django_course/</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure><h2 id="Module2"><a href="#Module2" class="headerlink" title="Module2"></a>Module2</h2><p>新建应用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python manage.py startapp core</span><br></pre></td></tr></table></figure><p>注册应用，修改project下的setting.py</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230717211722.png" alt=""></p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view是一个Python函数，用来接受一个网页请求并返回一个html的响应。需要去修改/core/views.py文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础查缺补漏</title>
      <link href="/2023/07/16/Python%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/"/>
      <url>/2023/07/16/Python%E5%9F%BA%E7%A1%80%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="is和-的区别"><a href="#is和-的区别" class="headerlink" title="is和==的区别"></a>is和==的区别</h2><ul><li><p><code>is</code>用于检查两个对象是否指向内存中的相同地址，即它们是否是同一个对象。</p></li><li><p>使用 <code>==</code> 运算符来比较两个对象的值是否相等</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a  <span class="comment"># b和a指向同一个对象</span></span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># c指向一个新的对象，虽然值相同但地址不同</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == b)  <span class="comment"># 输出 True，值相等</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)  <span class="comment"># 输出 True，同一个对象</span></span><br><span class="line"><span class="built_in">print</span>(a == c)  <span class="comment"># 输出 True，值相等</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> c)  <span class="comment"># 输出 False，不是同一个对象</span></span><br></pre></td></tr></table></figure><p>注意：在 Python 中，整数和短字符串等不可变对象的内存地址会被缓存，所有值相同的不变量指向的内存地址相同。不变量包括: <code>Number(数字)、String(字符串)、Tuple(元组)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple_1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tuple_2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">num_1 = <span class="number">1</span></span><br><span class="line">num_2 = <span class="number">1</span></span><br><span class="line">str_1 = <span class="string">&quot;hello&quot;</span></span><br><span class="line">str_2 = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(tuple_1 <span class="keyword">is</span> tuple_2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(num_1 <span class="keyword">is</span> num_2)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(str_1 <span class="keyword">is</span> str_2)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="type-和isinstance-的区别"><a href="#type-和isinstance-的区别" class="headerlink" title="type()和isinstance()的区别"></a>type()和isinstance()的区别</h2><ul><li><p>type()不会认为子类是一种父类类型。</p></li><li><p>isinstance()会认为子类是一种父类类型。</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(A(), A))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A()) == A)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(B(), A))  <span class="comment"># True,isinstance()认为子类是父类类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(B()) == A)  <span class="comment"># False,type不会认为子类是一种父类类型</span></span><br></pre></td></tr></table></figure><p>注意: Python3中, bool是int的子类。Python2中是没有布尔型的，0表示False，用1表示True。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(<span class="built_in">bool</span>, <span class="built_in">int</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p>使用<code>del</code>可以删除单个或者多个对象</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br><span class="line"><span class="keyword">del</span> var_a, var_b</span><br></pre></td></tr></table></figure><h2 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h2><p>复数由实数部分和虚数部分构成，可以用 <code>a + bj</code>，或者 <code>complex(a,b)</code> 表示， 复数的实部 <strong>a</strong> 和虚部 <strong>b</strong> 都是<code>浮点型</code>。</p><h2 id="可以用来连接列表"><a href="#可以用来连接列表" class="headerlink" title="+可以用来连接列表"></a>+可以用来连接列表</h2><p><code>list_1+list_2</code>等价于<code>list_1.extend(list_2)</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list_2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">list_1 = list_1 + list_2</span><br><span class="line"><span class="built_in">print</span>(list_1)</span><br></pre></td></tr></table></figure><h2 id="构建0个或1个元素的元组语法规则"><a href="#构建0个或1个元素的元组语法规则" class="headerlink" title="构建0个或1个元素的元组语法规则"></a>构建0个或1个元素的元组语法规则</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure><h2 id="集合的差集、并集和交集"><a href="#集合的差集、并集和交集" class="headerlink" title="集合的差集、并集和交集"></a>集合的差集、并集和交集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a - b)  <span class="comment"># a 和 b 的差集</span></span><br><span class="line"><span class="built_in">print</span>(a | b)  <span class="comment"># a 和 b 的并集</span></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)  <span class="comment"># a 和 b 的交集</span></span><br><span class="line"><span class="built_in">print</span>(a ^ b)  <span class="comment"># a 和 b 中不同时存在的元素</span></span><br></pre></td></tr></table></figure><h2 id="字典注意事项"><a href="#字典注意事项" class="headerlink" title="字典注意事项"></a>字典注意事项</h2><p>键(key)必须使用不可变类型。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul><li><p>eval(str) 用来计算在字符串中的有效Python表达式，并返回一个对象。</p></li><li><p>frozenset(s) 转换为<code>不可变</code>集合，因为集合中的元素需要是不可变的，当需要元素为集合时，需要先把集合转换为不可变集合。</p></li><li><p>chr(x) 将一个整数转换为一个字符，函数全称为character。</p></li><li><p>ord(x) 将一个字符转换为它的整数值，函数全称为ordinal sequence。</p></li></ul><h2 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h2><p><strong>f-string</strong> 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>&#x27;</span>)</span><br><span class="line">my_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;my_dict[<span class="string">&quot;name&quot;</span>]&#125;</span>,<span class="subst">&#123;my_dict[<span class="string">&quot;age&quot;</span>]&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><ul><li><p>del list[下标]</p></li><li><p>list.remove(值)</p></li></ul><h3 id="列表脚本操作符"><a href="#列表脚本操作符" class="headerlink" title="列表脚本操作符"></a>列表脚本操作符</h3><p><code>[&quot;Hi&quot;]*4</code>等价于<code>[&quot;Hi&quot;,&quot;Hi&quot;,&quot;Hi&quot;,&quot;Hi&quot;]</code></p><h2 id="while-循环使用-else-语句"><a href="#while-循环使用-else-语句" class="headerlink" title="while 循环使用 else 语句"></a>while 循环使用 else 语句</h2><p>如果 while 后面的条件语句为 false 时，则执行 else 的语句块。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot; 小于 5&quot;</span>)</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot; 大于或等于 5&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输出</span><br><span class="line"><span class="number">0</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">1</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">2</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">3</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">4</span>  小于 <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  大于或等于 <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="for…else"><a href="#for…else" class="headerlink" title="for…else"></a>for…else</h2><p>for…else 语句用于在循环结束后执行一段代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Finally finished!&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输出</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">Finally finished!</span><br></pre></td></tr></table></figure><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python字典判空方式</title>
      <link href="/2023/07/16/Python%E5%AD%97%E5%85%B8%E5%88%A4%E7%A9%BA%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/07/16/Python%E5%AD%97%E5%85%B8%E5%88%A4%E7%A9%BA%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="使用in关键字"><a href="#使用in关键字" class="headerlink" title="使用in关键字"></a>使用in关键字</h2><p>任务：将原字典列表转换为一个字典，相同关键字的值累加</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">origin_list = [&#123;<span class="string">&quot;Tom&quot;</span>: <span class="number">12</span>&#125;, &#123;<span class="string">&quot;Tom&quot;</span>: <span class="number">13</span>&#125;, &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">13</span>&#125;]</span><br><span class="line"></span><br><span class="line">result_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> origin_list:</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> item.items():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> result_dict:</span><br><span class="line">            result_dict[key] += value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result_dict)</span><br></pre></td></tr></table></figure><h2 id="使用try-except"><a href="#使用try-except" class="headerlink" title="使用try except"></a>使用try except</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">origin_list = [&#123;<span class="string">&quot;Tom&quot;</span>: <span class="number">12</span>&#125;, &#123;<span class="string">&quot;Tom&quot;</span>: <span class="number">13</span>&#125;, &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">25</span>&#125;, &#123;<span class="string">&quot;Alice&quot;</span>: <span class="number">13</span>&#125;]</span><br><span class="line"></span><br><span class="line">result_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> origin_list:</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> item.items():</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            result_dict[key] += value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            result_dict[key] = value</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result_dict)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/2023/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2023/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="初始对象"><a href="#初始对象" class="headerlink" title="初始对象"></a>初始对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设计类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    name = <span class="literal">None</span>  <span class="comment"># 记录学生姓名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建对象</span></span><br><span class="line">    stu_1 = Student()</span><br><span class="line">    stu_2 = Student()</span><br><span class="line">    <span class="comment"># 对象属性赋值</span></span><br><span class="line">    stu_1.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    stu_2.name = <span class="string">&quot;Jane&quot;</span></span><br></pre></td></tr></table></figure><h2 id="类的定义和使用"><a href="#类的定义和使用" class="headerlink" title="类的定义和使用"></a>类的定义和使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">类名称</span>:</span><br><span class="line">    类的属性</span><br><span class="line"></span><br><span class="line">    类的行为</span><br><span class="line"><span class="comment"># 创建类对象的语法</span></span><br><span class="line">对象 = 类名称()</span><br></pre></td></tr></table></figure><h2 id="成员方法的定义语法"><a href="#成员方法的定义语法" class="headerlink" title="成员方法的定义语法"></a>成员方法的定义语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">方法名</span>(<span class="params">self, 形参<span class="number">1</span>, ......, 形参N</span>):</span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure><p><code>self</code>关键字是成员方法定义的时候，必须填写的。</p><ul><li><p>它用来表示类对象自身的意思</p></li><li><p>当我们使用类对象调用方法的是，<code>self</code>会自动被python传入</p></li><li><p><code>在方法内部，想要访问类的成员变量，必须使用self</code></p></li><li><p><code>self</code>关键字，尽管在参数列表中，但是传参的时候可以忽略它</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">self, msg</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;大家好,我叫<span class="subst">&#123;self.name&#125;</span>.<span class="subst">&#123;msg&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    stu = Student()</span><br><span class="line">    stu.name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    stu.say_hi(<span class="string">&quot;很高兴认识你&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>注意事项：</p><ul><li><p>构造方法不要忘记<code>self</code>关键字</p></li><li><p>在方法内使用成员变量需要使用<code>self</code></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="comment"># 可以忽略</span></span><br><span class="line">    name = <span class="literal">None</span></span><br><span class="line">    age = <span class="literal">None</span></span><br><span class="line">    tel = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, tel</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.tel = tel</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Student类创建了一个对象&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu = Student(<span class="string">&quot;Joy&quot;</span>, <span class="number">31</span>, <span class="string">&quot;110&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="其他类内置方法"><a href="#其他类内置方法" class="headerlink" title="其他类内置方法"></a>其他类内置方法</h2><p><code>__init__</code>构造方法，是Python类内置的方法之一。这些内置方法也称为：<code>魔术方法</code></p><h2 id="str-字符串方法"><a href="#str-字符串方法" class="headerlink" title="__str__ 字符串方法"></a>__str__ 字符串方法</h2><p>当对象需要被转换为字符串后，会输出<code>内存地址</code>。</p><p>内存地址没有多大作用，我们可以通过<code>__str__</code>方法，控制类转换为字符串的行为。</p><h3 id="改变前"><a href="#改变前" class="headerlink" title="改变前"></a>改变前</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(student)  <span class="comment"># 结果为内存地址,&lt;__main__.Student object at 0x000001B0FAD52220&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(student))  <span class="comment"># 结果为内存地址,&lt;__main__.Student object at 0x000001B0FAD52220&gt;</span></span><br></pre></td></tr></table></figure><h3 id="改变后"><a href="#改变后" class="headerlink" title="改变后"></a>改变后</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;name=<span class="subst">&#123;self.name&#125;</span>,age=<span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">student = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">11</span>)</span><br><span class="line"><span class="built_in">print</span>(student)  <span class="comment"># 结果: name=Tom,age=11</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(student))  <span class="comment"># 结果: name=Tom,age=11</span></span><br></pre></td></tr></table></figure><h2 id="lt-小于符号比较方法"><a href="#lt-小于符号比较方法" class="headerlink" title="__lt__ 小于符号比较方法"></a>__lt__ 小于符号比较方法</h2><p>直接对2个对象进行比较式不可以的，但是在类中实现<code>__lt__</code>方法，即可同时完成：<code>小于符号 和 大于符号 2种比较</code>。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方法名: __lt__</span><br><span class="line">传入参数: other, 另外一个类对象</span><br><span class="line">返回值: <span class="literal">True</span> 或 <span class="literal">False</span></span><br><span class="line">内容: 自行定义</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">11</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;Jane&quot;</span>,<span class="number">13</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1 &lt; stu2)  <span class="comment"># 结果: True</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &gt; stu2)  <span class="comment"># 结果: False</span></span><br></pre></td></tr></table></figure><h2 id="le-小于等于比较符号方法"><a href="#le-小于等于比较符号方法" class="headerlink" title="__le__ 小于等于比较符号方法"></a>__le__ 小于等于比较符号方法</h2><p><code>&gt;=</code>符号实现的魔法方法是: <code>__ge__</code>。不过，实现了<code>__le__</code>，<code>__ge__</code>就没必要实现了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.age &lt; other.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu1 = Student(<span class="string">&quot;Tom&quot;</span>, <span class="number">11</span>)</span><br><span class="line">stu2 = Student(<span class="string">&quot;Jane&quot;</span>, <span class="number">13</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1 &lt;= stu2)  <span class="comment"># 结果: True</span></span><br><span class="line"><span class="built_in">print</span>(stu1 &gt;= stu2)  <span class="comment"># 结果: False</span></span><br></pre></td></tr></table></figure><h2 id="eq-比较运算符实现方法"><a href="#eq-比较运算符实现方法" class="headerlink" title="__eq__ 比较运算符实现方法"></a>__eq__ 比较运算符实现方法</h2><ul><li><p>不实现<code>__eq__</code>方法，对象之间可以不交，但是是比较内存地址，也就是不同对象 == 比较一定是False结果。</p></li><li><p>实现了<code>__eq__</code>方法，就可以按照自己的想法来决定2个对象是否相等。</p></li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>私有成员：</p><ul><li><p>私有成员变量:变量名以__开头(2个下划线)</p></li><li><p>私有成员方法:方法名以__开头(2个下划线)</p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">父类名</span>):</span><br><span class="line">    类内容体</span><br></pre></td></tr></table></figure><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>注意事项：多个父类中，如果有同名的成员，那么<code>默认</code>以继承顺序(从左到右)为优先级。即：先继承的保留，后继承的被覆盖。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(父类<span class="number">1</span>, 父类<span class="number">2</span>, ......, 父类N):</span><br><span class="line">    类内容体</span><br></pre></td></tr></table></figure><h3 id="pass关键字"><a href="#pass关键字" class="headerlink" title="pass关键字"></a>pass关键字</h3><p>pass 是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思。</p><h3 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h3><p>子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写。即：在子类中重新定义同名的属性或方法即可。</p><p>注意：只可以在<code>子类内部</code>调用父类的同名成员，子类的<code>实体类对象</code>调用默认是<br>调用子类复写的。</p><ul><li>方法一：调用父类成员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用成员变量: 父类名.成员变量</span><br><span class="line">使用成员方法: 父类名.成员方法(self)</span><br></pre></td></tr></table></figure><ul><li>方法二：使用super()调用父类成员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">使用成员变量: <span class="built_in">super</span>().成员变量</span><br><span class="line">使用成员方法: <span class="built_in">super</span>().成员方法()</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Phone&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPhone</span>(<span class="title class_ inherited__">Phone</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 方式一</span></span><br><span class="line">        Phone.Info(self)</span><br><span class="line">        <span class="comment"># 方式二</span></span><br><span class="line">        <span class="built_in">super</span>().Info()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;My_Phone&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_phone = MyPhone()</span><br><span class="line">my_phone.Info()</span><br></pre></td></tr></table></figure><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2><p>类型注解：在代码中涉及数据交互的地方，提供数据类型的注解（显式的说明）。</p><p>主要功能：</p><ul><li><p>帮助第三方 IDE 工具（如 PyCharm ）对代码进行类型推断，协助做代码提示</p></li><li><p>帮助开发者自身对变量进行类型注释</p></li></ul><p>支持：</p><ul><li><p>变量的类型注解</p></li><li><p>函数（方法）形参列表和返回值的类型注解</p></li></ul><h3 id="为变量设置类型注解"><a href="#为变量设置类型注解" class="headerlink" title="为变量设置类型注解"></a>为变量设置类型注解</h3><p>基础语法: <code>变量: 类型 = 值</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础数据类型注解</span></span><br><span class="line">var_1: <span class="built_in">int</span> = <span class="number">10</span></span><br><span class="line">var_2: <span class="built_in">float</span> = <span class="number">3.14</span></span><br><span class="line">var_3: <span class="built_in">bool</span> = <span class="literal">True</span></span><br><span class="line">var_4: <span class="built_in">str</span> = <span class="string">&quot;Tom&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 类对象类型注解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">stu: Student = Student()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础容器类型注解</span></span><br><span class="line">my_list: <span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_tuple: <span class="built_in">tuple</span> = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_set: <span class="built_in">set</span> = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">my_dict: <span class="built_in">dict</span> = &#123;<span class="string">&quot;it&quot;</span>: <span class="number">666</span>&#125;</span><br><span class="line">my_str: <span class="built_in">str</span> = <span class="string">&quot;Tom&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 容器类型详细注解</span></span><br><span class="line">my_list: <span class="built_in">list</span>[<span class="built_in">int</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_tuple: <span class="built_in">tuple</span>[<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>] = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">my_set: <span class="built_in">set</span>[<span class="built_in">int</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">my_dict: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">int</span>] = &#123;<span class="string">&quot;it&quot;</span>: <span class="number">666</span>&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>元组类型设置类型详细注解，需要将每一个元素都标记出来</p></li><li><p>字典类型设置类型详细注解，需要2个类型，第一个是key，第二个是value。</p></li></ul><h3 id="注释中进行类型注解"><a href="#注释中进行类型注解" class="headerlink" title="注释中进行类型注解"></a>注释中进行类型注解</h3><p>语法: <code># type: 类型</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1 = random.randint(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># type: <span class="built_in">int</span></span></span><br></pre></td></tr></table></figure><h3 id="类型注解的限制"><a href="#类型注解的限制" class="headerlink" title="类型注解的限制"></a>类型注解的限制</h3><p>类型注解主要功能在于:</p><ul><li><p>帮助第三方 IDE 工具（如 PyCharm ）对代码进行类型推断，协助做代码提示</p></li><li><p>帮助开发者自身对变量进行类型注释（备注）</p></li></ul><p>并不会真正的对类型做验证和判断。也就是，类型注解仅仅是提示性的，不是决定性的。以下代码不会报错！</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">var_1: <span class="built_in">int</span> = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">var_2: <span class="built_in">str</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="函数-方法-的类型注解"><a href="#函数-方法-的类型注解" class="headerlink" title="函数(方法)的类型注解"></a>函数(方法)的类型注解</h2><h3 id="形参注解"><a href="#形参注解" class="headerlink" title="形参注解"></a>形参注解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>(<span class="params">形参名: 类型, 形参名: 类型, ......</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="返回值注解"><a href="#返回值注解" class="headerlink" title="返回值注解"></a>返回值注解</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数方法名</span>() -&gt; 返回值类型:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="Union类型"><a href="#Union类型" class="headerlink" title="Union类型"></a>Union类型</h3><p>如何让类型注解描述混合的数据类型，那就要需要用到<code>Union</code>数据类型了。</p><p><code>注意</code>：使用前需要先导入typing模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line">my_list: <span class="built_in">list</span>[<span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;number&quot;</span>]</span><br><span class="line">my_dict: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">int</span>]] = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Joy&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">31</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类：含有抽象方法的类称之为抽象类。</p><p>抽象方法：方法体是空实现的(pass)称之为抽象方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;汪汪汪&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;喵喵喵&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表的sort方法</title>
      <link href="/2023/07/15/%E5%88%97%E8%A1%A8%E7%9A%84sort%E6%96%B9%E6%B3%95/"/>
      <url>/2023/07/15/%E5%88%97%E8%A1%A8%E7%9A%84sort%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p><code>列表.sort(key=选择排序依据的函数,reverse=True|False)</code></p><ul><li><p>参数key,要求传入一个函数，作为排序的依据</p></li><li><p>参数reverse，是否反转排序结果，True表示降序，False表示升序。</p></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [[<span class="string">&quot;a&quot;</span>, <span class="number">33</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">55</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义排序方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">choose_sort_key</span>(<span class="params">element</span>):</span><br><span class="line">    <span class="keyword">return</span> element[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list.sort(key=choose_sort_key, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#  [[&#x27;b&#x27;,55],[&#x27;a&#x27;,33],[&#x27;c&#x27;,11]]</span></span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure><h3 id="lambda形式"><a href="#lambda形式" class="headerlink" title="lambda形式"></a>lambda形式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [[<span class="string">&quot;a&quot;</span>, <span class="number">33</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">55</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">11</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list.sort(key=<span class="keyword">lambda</span> element: element[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#  [[&#x27;b&#x27;,55],[&#x27;a&#x27;,33],[&#x27;c&#x27;,11]]</span></span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国内如何无需魔法访问chatgpt</title>
      <link href="/2023/07/15/%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E6%97%A0%E9%9C%80%E9%AD%94%E6%B3%95%E8%AE%BF%E9%97%AEchatgpt/"/>
      <url>/2023/07/15/%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E6%97%A0%E9%9C%80%E9%AD%94%E6%B3%95%E8%AE%BF%E9%97%AEchatgpt/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Web应用程序通过云函数中继用户输入的文本请求，云函数通过API密钥在云端调用ChatGPT的API，然后将生成的响应返回给Web应用程序。这种方式实现了在本地通过Web应用程序访问部署在云端的ChatGPT的目的。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><p>chatgpt的API key - 调用chatgpt服务的通行证</p></li><li><p>腾讯云的云函数 - 利用部署在美国的服务器调用chatgpt</p></li><li><p>chatgpt的对话应用 - 一个web程序用来发送和接收云函数请求和响应</p></li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="API-key"><a href="#API-key" class="headerlink" title="API key"></a>API key</h3><p>chatgpt的API key地址: <a href="https://platform.openai.com/account/api-keys">OpenAI Platform</a></p><h3 id="腾讯云函数"><a href="#腾讯云函数" class="headerlink" title="腾讯云函数"></a>腾讯云函数</h3><h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715143504.png" alt=""></p><h4 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h4><p>nodejs包下载地址：<a href="https://github.com/Ice-Hazymoon/openai-scf-proxy/releases/tag/0.0.3">点击zip下载</a></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715144116.png" alt=""></h4><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715144254.png" alt=""></p><h4 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h4><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715144735.png" alt=""></p><h3 id="对话应用"><a href="#对话应用" class="headerlink" title="对话应用"></a>对话应用</h3><p><a href="https://chrome.google.com/webstore/detail/chathub-all-in-one-chatbo/iaakpnchhognanibcahlpcplchdfmgma">ChatHub - All-in-one chatbot client - Chrome Web Store</a></p><p>API Host保留到com就好了</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715145739.png" alt=""></p><h2 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h2><p>API的使用是有限额的，国外充值是个问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python可视化</title>
      <link href="/2023/07/10/Python%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
      <url>/2023/07/10/Python%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON数据格式"><a href="#JSON数据格式" class="headerlink" title="JSON数据格式"></a>JSON数据格式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li><p>JSON是一种轻量级的数据交互格式。可以按照JSON指定的格式去组织和封装数据</p></li><li><p>JSON本质上是一个带有特定格式的<code>字符串</code>。</p></li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>为了让不同的语言都能够相互通用的传递数据，JSON就是一种非常良好的中转数据格式。</p><h3 id="Python中数据结构和JSON的关系"><a href="#Python中数据结构和JSON的关系" class="headerlink" title="Python中数据结构和JSON的关系"></a>Python中数据结构和JSON的关系</h3><ul><li><p>python中的字典转成字符串就是JSON</p></li><li><p>python中的列表(列表中的元素是字典)转成字符串就是JSON</p></li></ul><h3 id="Python数据和Json数据的相互转换"><a href="#Python数据和Json数据的相互转换" class="headerlink" title="Python数据和Json数据的相互转换"></a>Python数据和Json数据的相互转换</h3><p><code>Python数据-&gt;JSON数据</code>(dumps())</p><p>ensure_ascii=False表明不使用ASCII去转换它，而是把它内容直接输出出去。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备列表，列表中的每一个元素都是字典，将其转换为JSON</span></span><br><span class="line">data = [&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">20</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Mike&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">10</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用dumps()，将字典转换为JSON</span></span><br><span class="line">json_str = json.dumps(data,ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(json_str))</span><br><span class="line"><span class="built_in">print</span>(json_str)</span><br></pre></td></tr></table></figure><p><code>JSON数据-&gt;Python数据</code>(loads())</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON数据</span></span><br><span class="line">s = <span class="string">&#x27;[&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20&#125;, &#123;&quot;name&quot;: &quot;Mike&quot;, &quot;age&quot;: 10&#125;]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON数据转Python数据 list</span></span><br><span class="line">l = json.loads(s)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(l))  <span class="comment"># list</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON数据</span></span><br><span class="line">s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;:20&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON数据转成Python数据 dict</span></span><br><span class="line">l = json.loads(s)  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(l))  <span class="comment"># dict</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure><h2 id="pyecharts模块"><a href="#pyecharts模块" class="headerlink" title="pyecharts模块"></a>pyecharts模块</h2><p><a href="https://pyecharts.org/#/zh-cn/intro">官方文档</a></p><p><a href="https://gallery.pyecharts.org/#/README">示例图</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pyecharts</span><br></pre></td></tr></table></figure><h3 id="基本折线图"><a href="#基本折线图" class="headerlink" title="基本折线图"></a>基本折线图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导包，导入Line功能构建折线图对象</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到折线图对象</span></span><br><span class="line">line = Line()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加x轴数据</span></span><br><span class="line">line.add_xaxis([<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;美国&quot;</span>,<span class="string">&quot;英国&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加y轴数据</span></span><br><span class="line">line.add_yaxis(<span class="string">&quot;GDP&quot;</span>,[<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成图表</span></span><br><span class="line">line.render()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230710123050.png" alt=""></p><h3 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h3><ul><li>全局配置，主要是通用的配置，包括标题、Legends、工具箱、视觉映射等</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;GDP展示&quot;</span>,pos_left=<span class="string">&quot;center&quot;</span>,pos_bottom=<span class="string">&quot;1%&quot;</span>),</span><br><span class="line">    legend_opts=LegendOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    toolbox_opts=ToolboxOpts(is_show=<span class="literal">True</span>),</span><br><span class="line">    visualmap_opts=VisualMapOpts(is_show=<span class="literal">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>系列配置选项，不同的折线可以设置不同属性</li></ul><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p><a href="http://www.ab173.com/gongju/json/jsonviewernew.php(">JSON视图</a></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Line</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts, LabelOpts</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">return</span> file.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_line_chart</span>(<span class="params">x_data, y_data, name</span>):</span><br><span class="line">    line.add_xaxis(x_data)</span><br><span class="line">    line.add_yaxis(name, y_data, label_opts=LabelOpts(is_show=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">us_data = read_file(<span class="string">&quot;美国.txt&quot;</span>)</span><br><span class="line">jp_data = read_file(<span class="string">&quot;日本.txt&quot;</span>)</span><br><span class="line">in_data = read_file(<span class="string">&quot;印度.txt&quot;</span>)</span><br><span class="line"><span class="comment"># json转字典</span></span><br><span class="line">us_dict = json.loads(us_data)</span><br><span class="line">jp_dict = json.loads(jp_data)</span><br><span class="line">in_dict = json.loads(in_data)</span><br><span class="line"><span class="comment"># 取出需要属性</span></span><br><span class="line">us_trend_data = us_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line">jp_trend_data = jp_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line">in_trend_data = in_dict[<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;trend&#x27;</span>]</span><br><span class="line"><span class="comment"># x,y轴数据</span></span><br><span class="line">us_x_data = us_trend_data[<span class="string">&#x27;updateDate&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">us_y_data = us_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">jp_y_data = jp_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line">in_y_data = in_trend_data[<span class="string">&#x27;list&#x27;</span>][<span class="number">0</span>][<span class="string">&#x27;data&#x27;</span>][:<span class="number">314</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化折线图</span></span><br><span class="line">line = Line()</span><br><span class="line">line.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;2020年美日印确诊人数对比折线图&quot;</span>, pos_left=<span class="string">&quot;center&quot;</span>, pos_bottom=<span class="string">&quot;1%&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 填充x,y轴数据</span></span><br><span class="line">generate_line_chart(us_x_data, us_y_data, <span class="string">&quot;美国确诊人数&quot;</span>)</span><br><span class="line">generate_line_chart(us_x_data, jp_y_data, <span class="string">&quot;日本确诊人数&quot;</span>)</span><br><span class="line">generate_line_chart(us_x_data, in_y_data, <span class="string">&quot;印度确诊人数&quot;</span>)</span><br><span class="line">line.render()</span><br></pre></td></tr></table></figure><p><img title="" src="file:///C:/Blog/source/images/3317117327bdbb5b70573fd2bbad7c00a03c071e.png" alt="" data-align="inline"></p><h2 id="基本地图"><a href="#基本地图" class="headerlink" title="基本地图"></a>基本地图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> VisualMapOpts</span><br><span class="line"><span class="comment"># 准备地图对象</span></span><br><span class="line"><span class="built_in">map</span> = Map()</span><br><span class="line"><span class="comment"># 准备数据</span></span><br><span class="line">data = [</span><br><span class="line">    (<span class="string">&quot;北京市&quot;</span>,<span class="number">99</span>),</span><br><span class="line">    (<span class="string">&quot;上海市&quot;</span>,<span class="number">199</span>),</span><br><span class="line">    (<span class="string">&quot;湖南省&quot;</span>,<span class="number">299</span>),</span><br><span class="line">    (<span class="string">&quot;台湾省&quot;</span>,<span class="number">399</span>),</span><br><span class="line">    (<span class="string">&quot;广东省&quot;</span>,<span class="number">499</span>)</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line"><span class="built_in">map</span>.add(<span class="string">&quot;测试地图&quot;</span>,data,<span class="string">&quot;china&quot;</span>)</span><br><span class="line"><span class="comment"># 设置全局选项</span></span><br><span class="line"><span class="built_in">map</span>.set_global_opts(</span><br><span class="line">    visualmap_opts=VisualMapOpts(</span><br><span class="line">        is_show=<span class="literal">True</span>,</span><br><span class="line">        is_piecewise=<span class="literal">True</span>,  <span class="comment"># 分段</span></span><br><span class="line">        pieces=[</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">1</span>,<span class="string">&quot;max&quot;</span>:<span class="number">9</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;1-9&quot;</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;#CCFFFF&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">10</span>,<span class="string">&quot;max&quot;</span>:<span class="number">99</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;10-99&quot;</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;#FF6666&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;min&quot;</span>:<span class="number">100</span>,<span class="string">&quot;max&quot;</span>:<span class="number">500</span>,<span class="string">&quot;label&quot;</span>:<span class="string">&quot;100-500&quot;</span>,<span class="string">&quot;color&quot;</span>:<span class="string">&quot;#990033&quot;</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line"><span class="built_in">map</span>.render()</span><br></pre></td></tr></table></figure><p><img src="C:\Blog\source\images\76302042e55972bcac2bc5a6dd1d72638ce46748.png" alt=""></p><h2 id="全国省份疫情确诊图"><a href="#全国省份疫情确诊图" class="headerlink" title="全国省份疫情确诊图"></a>全国省份疫情确诊图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts, VisualMapOpts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;疫情.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串json转换为Python的字典</span></span><br><span class="line">data_dict = json.loads(data)</span><br><span class="line">province_data_list = data_dict[<span class="string">&quot;areaTree&quot;</span>][<span class="number">0</span>][<span class="string">&quot;children&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理省份名称的逻辑</span></span><br><span class="line">city = [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;重庆&quot;</span>]</span><br><span class="line">province = [<span class="string">&quot;河北&quot;</span>, <span class="string">&quot;山西&quot;</span>, <span class="string">&quot;黑龙江&quot;</span>, <span class="string">&quot;吉林&quot;</span>, <span class="string">&quot;辽宁&quot;</span>, <span class="string">&quot;江苏&quot;</span>, <span class="string">&quot;浙江&quot;</span>, <span class="string">&quot;安徽&quot;</span>, <span class="string">&quot;福建&quot;</span>, <span class="string">&quot;江西&quot;</span>, <span class="string">&quot;山东&quot;</span>, <span class="string">&quot;河南&quot;</span>, <span class="string">&quot;湖北&quot;</span>, <span class="string">&quot;湖南&quot;</span>, <span class="string">&quot;广东&quot;</span>, <span class="string">&quot;海南&quot;</span>, <span class="string">&quot;四川&quot;</span>,</span><br><span class="line">            <span class="string">&quot;贵州&quot;</span>, <span class="string">&quot;云南&quot;</span>, <span class="string">&quot;陕西&quot;</span>, <span class="string">&quot;甘肃&quot;</span>, <span class="string">&quot;青海&quot;</span>, <span class="string">&quot;台湾&quot;</span>]</span><br><span class="line">municipality = [<span class="string">&quot;内蒙古&quot;</span>, <span class="string">&quot;西藏&quot;</span>, <span class="string">&quot;宁夏&quot;</span>, <span class="string">&quot;新疆&quot;</span>, <span class="string">&quot;广西&quot;</span>]</span><br><span class="line">specialty = [<span class="string">&quot;香港&quot;</span>, <span class="string">&quot;澳门&quot;</span>]</span><br><span class="line"></span><br><span class="line">data_list = []</span><br><span class="line"><span class="keyword">for</span> province_data <span class="keyword">in</span> province_data_list:</span><br><span class="line">    province_name = province_data[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">    <span class="keyword">if</span> province_name <span class="keyword">in</span> city:</span><br><span class="line">        province_name += <span class="string">&quot;市&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> province_name <span class="keyword">in</span> province:</span><br><span class="line">        province_name += <span class="string">&quot;省&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> province_name <span class="keyword">in</span> municipality:</span><br><span class="line">        province_name += &#123;</span><br><span class="line">            <span class="string">&quot;内蒙古&quot;</span>: <span class="string">&quot;自治区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;西藏&quot;</span>: <span class="string">&quot;自治区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;宁夏&quot;</span>: <span class="string">&quot;回族自治区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;新疆&quot;</span>: <span class="string">&quot;维吾尔自治区&quot;</span>,</span><br><span class="line">            <span class="string">&quot;广西&quot;</span>: <span class="string">&quot;壮族自治区&quot;</span>,</span><br><span class="line">        &#125;.get(province_name)</span><br><span class="line">    data_list.append((province_name, province_data[<span class="string">&quot;total&quot;</span>][<span class="string">&quot;confirm&quot;</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建地图对象</span></span><br><span class="line">map_chart = Map()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">map_chart.add(<span class="string">&quot;各省份确诊人数&quot;</span>, data_list, <span class="string">&quot;china&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局配置，定制分段的视觉映射</span></span><br><span class="line">visual_map = VisualMapOpts(</span><br><span class="line">    is_show=<span class="literal">True</span>,</span><br><span class="line">    is_piecewise=<span class="literal">True</span>,</span><br><span class="line">    pieces=[</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1~99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#CCFFFF&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100~999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FFFF99&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">4999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1000~4999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FF9966&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">9999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;5000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FF6666&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">10000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;10000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#CC3333&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100000</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100000+&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局配置</span></span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;全国疫情地图&quot;</span>),</span><br><span class="line">    visualmap_opts=visual_map</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">map_chart.render(<span class="string">&quot;全国疫情地图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230710232244.png" alt=""></p><h2 id="省级图形绘制"><a href="#省级图形绘制" class="headerlink" title="省级图形绘制"></a>省级图形绘制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Map</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> TitleOpts, VisualMapOpts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;疫情.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;UTF-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取河南省数据</span></span><br><span class="line">data_dict = json.loads(data)</span><br><span class="line">cities_data = data_dict[<span class="string">&quot;areaTree&quot;</span>][<span class="number">0</span>][<span class="string">&quot;children&quot;</span>][<span class="number">3</span>][<span class="string">&quot;children&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据为元组并放入列表</span></span><br><span class="line">data_list = []</span><br><span class="line"><span class="keyword">for</span> city_data <span class="keyword">in</span> cities_data:</span><br><span class="line">    city_name = city_data[<span class="string">&quot;name&quot;</span>] + <span class="string">&quot;市&quot;</span></span><br><span class="line">    city_confirm = city_data[<span class="string">&quot;total&quot;</span>][<span class="string">&quot;confirm&quot;</span>]</span><br><span class="line">    data_list.append((city_name, city_confirm))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动添加济源市的数据</span></span><br><span class="line">data_list.append((<span class="string">&quot;济源市&quot;</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建地图对象</span></span><br><span class="line">map_chart = Map()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加数据</span></span><br><span class="line">map_chart.add(<span class="string">&quot;河南省疫情分布&quot;</span>, data_list, <span class="string">&quot;河南&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置全局选项</span></span><br><span class="line">visual_map = VisualMapOpts(</span><br><span class="line">    is_show=<span class="literal">True</span>,</span><br><span class="line">    is_piecewise=<span class="literal">True</span>,</span><br><span class="line">    pieces=[</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1~99人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#CCFFFF&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100</span>, <span class="string">&quot;max&quot;</span>: <span class="number">999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100~9999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FFFF99&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">1000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">4999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;1000~4999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FF9966&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">5000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">9999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;5000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#FF6666&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">10000</span>, <span class="string">&quot;max&quot;</span>: <span class="number">99999</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;10000~99999人&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#CC3333&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;min&quot;</span>: <span class="number">100000</span>, <span class="string">&quot;label&quot;</span>: <span class="string">&quot;100000+&quot;</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#990033&quot;</span>&#125;,</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">map_chart.set_global_opts(</span><br><span class="line">    title_opts=TitleOpts(title=<span class="string">&quot;河南省疫情地图&quot;</span>),</span><br><span class="line">    visualmap_opts=visual_map</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">map_chart.render(<span class="string">&quot;河南省疫情地图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="C:\Blog\source\images\7d4d25181e13d839cc28dc6c6e1e8bfdd3cbdaa8.png" alt=""></p><h2 id="基础柱状图"><a href="#基础柱状图" class="headerlink" title="基础柱状图"></a>基础柱状图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">演示基础柱状图的开发</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> LabelOpts</span><br><span class="line"><span class="comment"># 使用Bar构建基础柱状图</span></span><br><span class="line">bar = Bar()</span><br><span class="line"><span class="comment"># 添加x轴的数据</span></span><br><span class="line">bar.add_xaxis([<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>])</span><br><span class="line"><span class="comment"># 添加y轴数据, 将标签放在右边</span></span><br><span class="line">bar.add_yaxis(<span class="string">&quot;GDP&quot;</span>, [<span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>], label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line"><span class="comment"># 反转x和y轴</span></span><br><span class="line">bar.reversal_axis()</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">bar.render(<span class="string">&quot;基础柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230714222708.png" alt=""></p><h2 id="基础时间线柱状图"><a href="#基础时间线柱状图" class="headerlink" title="基础时间线柱状图"></a>基础时间线柱状图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar, Timeline</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> LabelOpts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_bar_chart</span>(<span class="params">x_data, y_data, label_position=<span class="string">&quot;right&quot;</span></span>):</span><br><span class="line">    bar = Bar()</span><br><span class="line">    bar.add_xaxis(x_data)</span><br><span class="line">    bar.add_yaxis(<span class="string">&quot;GDP&quot;</span>, y_data, label_opts=LabelOpts(position=label_position))</span><br><span class="line">    bar.reversal_axis()</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">countries = [<span class="string">&quot;中国&quot;</span>, <span class="string">&quot;美国&quot;</span>, <span class="string">&quot;英国&quot;</span>]</span><br><span class="line">gdp_data = [</span><br><span class="line">    [<span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>],</span><br><span class="line">    [<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>],</span><br><span class="line">    [<span class="number">70</span>, <span class="number">60</span>, <span class="number">60</span>]</span><br><span class="line">]</span><br><span class="line">points = [<span class="string">&quot;点1&quot;</span>, <span class="string">&quot;点2&quot;</span>, <span class="string">&quot;点3&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建时间线对象</span></span><br><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个添加柱状图到时间线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(points)):</span><br><span class="line">    bar = create_bar_chart(countries, gdp_data[i])</span><br><span class="line">    timeline.add(bar, points[i])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动播放设置</span></span><br><span class="line">timeline.add_schema(</span><br><span class="line">    play_interval=<span class="number">1000</span>,  <span class="comment"># 自动播放的时间间隔，单位毫秒</span></span><br><span class="line">    is_timeline_show=<span class="literal">True</span>,  <span class="comment"># 是否在自动播放的时候显示时间线</span></span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成最终的HTML文件</span></span><br><span class="line">timeline.render(<span class="string">&quot;基础时间线柱状图.html&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230714223958.png" alt=""></p><h2 id="动态GDP柱形图绘制"><a href="#动态GDP柱形图绘制" class="headerlink" title="动态GDP柱形图绘制"></a>动态GDP柱形图绘制</h2><p>效果图中需要</p><ol><li><p>GDP数量处理为亿级别</p></li><li><p>有时间轴，按照年份为时间轴的点</p></li><li><p>x轴和y轴反转，同时每一年的数据只要前8名</p></li><li><p>有标题，标题的年份动态更改</p></li><li><p>设置主题为LIGHT</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">演示第三个图表：GDP动态柱状图开发</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Bar, Timeline</span><br><span class="line"><span class="keyword">from</span> pyecharts.options <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;1960-2019全球GDP数据.csv&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">data_lines = f.readlines()</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 删除第一条数据</span></span><br><span class="line">data_lines.pop(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将数据转换为字典存储，格式为：</span></span><br><span class="line"><span class="comment"># &#123; 年份: [ [国家, gdp], [国家,gdp], ......  ], 年份: [ [国家, gdp], [国家,gdp], ......  ], ...... &#125;</span></span><br><span class="line"><span class="comment"># &#123; 1960: [ [美国, 123], [中国,321], ......  ], 1961: [ [美国, 123], [中国,321], ......  ], ...... &#125;</span></span><br><span class="line"><span class="comment"># 先定义一个字典对象</span></span><br><span class="line">data_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> data_lines:</span><br><span class="line">    year = <span class="built_in">int</span>(line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>])      <span class="comment"># 年份</span></span><br><span class="line">    country = line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]        <span class="comment"># 国家</span></span><br><span class="line">    gdp = <span class="built_in">float</span>(line.split(<span class="string">&quot;,&quot;</span>)[<span class="number">2</span>])     <span class="comment"># gdp数据</span></span><br><span class="line">    <span class="comment"># 如何判断字典里面有没有指定的key呢？</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        data_dict[year].append([country, gdp])</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        data_dict[year] = []</span><br><span class="line">        data_dict[year].append([country, gdp])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建时间线对象</span></span><br><span class="line">timeline = Timeline(&#123;<span class="string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)</span><br><span class="line"><span class="comment"># 排序年份</span></span><br><span class="line">sorted_year_list = <span class="built_in">sorted</span>(data_dict.keys())</span><br><span class="line"><span class="keyword">for</span> year <span class="keyword">in</span> sorted_year_list:</span><br><span class="line">    <span class="comment"># 列表排序</span></span><br><span class="line">    data_dict[year].sort(key=<span class="keyword">lambda</span> element: element[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 取出本年份前8名的国家</span></span><br><span class="line">    year_data = data_dict[year][<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line">    x_data = []</span><br><span class="line">    y_data = []</span><br><span class="line">    <span class="keyword">for</span> country_gdp <span class="keyword">in</span> year_data:</span><br><span class="line">        x_data.append(country_gdp[<span class="number">0</span>])   <span class="comment"># x轴添加国家</span></span><br><span class="line">        y_data.append(country_gdp[<span class="number">1</span>] / <span class="number">100000000</span>)   <span class="comment"># y轴添加gdp数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构建柱状图</span></span><br><span class="line">    bar = Bar()</span><br><span class="line">    x_data.reverse()</span><br><span class="line">    y_data.reverse()</span><br><span class="line">    bar.add_xaxis(x_data)</span><br><span class="line">    bar.add_yaxis(<span class="string">&quot;GDP(亿)&quot;</span>, y_data, label_opts=LabelOpts(position=<span class="string">&quot;right&quot;</span>))</span><br><span class="line">    <span class="comment"># 反转x轴和y轴</span></span><br><span class="line">    bar.reversal_axis()</span><br><span class="line">    <span class="comment"># 设置每一年的图表的标题</span></span><br><span class="line">    bar.set_global_opts(</span><br><span class="line">        title_opts=TitleOpts(title=<span class="string">f&quot;<span class="subst">&#123;year&#125;</span>年全球前8GDP数据&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">    timeline.add(bar, <span class="built_in">str</span>(year))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环每一年的数据，基于每一年的数据，创建每一年的bar对象</span></span><br><span class="line"><span class="comment"># 在for中，将每一年的bar对象添加到时间线中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间线自动播放</span></span><br><span class="line">timeline.add_schema(</span><br><span class="line">    play_interval=<span class="number">1000</span>,</span><br><span class="line">    is_timeline_show=<span class="literal">True</span>,</span><br><span class="line">    is_auto_play=<span class="literal">True</span>,</span><br><span class="line">    is_loop_play=<span class="literal">False</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">timeline.render(<span class="string">&quot;1960-2019全球GDP前8国家.html&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230715202356.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块和包</title>
      <link href="/2023/07/09/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
      <url>/2023/07/09/Python%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p><code>定义</code>：Python 模块(Module)，是一个 Python 文件，以 .py 结尾.  模块能定义函数，类和变量，模块里也能包含可执行的代码。</p><h3 id="模块的导入方式"><a href="#模块的导入方式" class="headerlink" title="模块的导入方式"></a>模块的导入方式</h3><p><code>语法</code>：<code>[from 模块名] import [模块|类|变量|函数|*] [as 别名]</code></p><p><code>常用组合</code>：</p><ul><li><p>import 模块名</p></li><li><p>from 模块名 import 类、变量、方法等</p></li><li><p>from 模块名 import *</p></li><li><p>import 模块名 as 别名</p></li><li><p>from 模块名 import 功能名 as 别名</p></li></ul><h3 id="import-模块名"><a href="#import-模块名" class="headerlink" title="import 模块名"></a>import 模块名</h3><p>基本语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 模块名</span><br><span class="line"><span class="keyword">import</span> 模块名<span class="number">1</span>，模块名<span class="number">2</span></span><br><span class="line"></span><br><span class="line">模块名.功能名()</span><br></pre></td></tr></table></figure><p>案例：导入time模块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入时间模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line"><span class="comment"># 让程序睡眠1秒(阻塞)</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="from-模块名-import-功能名"><a href="#from-模块名-import-功能名" class="headerlink" title="from 模块名 import 功能名"></a>from 模块名 import 功能名</h3><p>基本语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能名</span><br><span class="line"></span><br><span class="line">功能名()</span><br></pre></td></tr></table></figure><p>案例：导入time模块中的sleep方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入时间模块中的sleep方法</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始&quot;</span>)</span><br><span class="line"><span class="comment"># 让程序睡眠1秒(阻塞)</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="as定义别名"><a href="#as定义别名" class="headerlink" title="as定义别名"></a>as定义别名</h3><p>基本语法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块定义别名</span></span><br><span class="line"><span class="keyword">import</span> 模块名 <span class="keyword">as</span> 别名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能定义别名</span></span><br><span class="line"><span class="keyword">from</span> 模块名 <span class="keyword">import</span> 功能 <span class="keyword">as</span> 别名</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块别名</span></span><br><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> tt</span><br><span class="line">tt.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 功能别名</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep <span class="keyword">as</span> sl</span><br><span class="line">sl(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="自定义模块"><a href="#自定义模块" class="headerlink" title="自定义模块"></a>自定义模块</h2><p>每个Python文件都可以作为一个模块，模块的名字就是文件的名字。</p><h3 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h3><p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息。此时会出现一个问题，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>test</code>函数的调用。</p><p><code>解决方案</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test (<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>注意事项</code>：当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能</p><h3 id="all-变量"><a href="#all-变量" class="headerlink" title="__all__ 变量"></a><code>__all__</code> 变量</h3><p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素</p><p><img src="C:\Blog\source\images\3fda7a35bce95ee0afc3d2cad315654ca2d3dad9.png" alt=""></p><p><img src="C:\Blog\source\images\844833479d1e199e8b2fdfdc25e61f4bd86f7b86.png" alt=""></p><h2 id="Python包"><a href="#Python包" class="headerlink" title="Python包"></a>Python包</h2><p>定义：从物理上看，包就是一个文件夹，在该文件夹下包含了一个 <code>__init__.py</code> 文件，该文件夹可用于包含多个模块文件。从逻辑上看，包的本质依然是模块。</p><p>作用：当我们的模块文件越来越多时,包可以帮助我们管理这些模块, 包的作用就是包含多个模块，但包的本质依然是模块</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230709205707.png" alt=""></p><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><p>步骤：</p><ul><li><p>新建包<code>my_package</code></p></li><li><p>新建包内模块：<code>my_module1</code> 和 <code>my_module2</code></p></li><li><p>在模块内补充代码</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230716102131.png" alt=""></p><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><ul><li>方式一</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名.模块名</span><br><span class="line">包名.模块名.目标</span><br></pre></td></tr></table></figure><ul><li>方式二</li></ul><p>注意：必须在<code>__init__.py</code>文件中添加<code>__all__ = []</code>，控制允许导入的模块列表。 <code>__all__</code>针对的是<code>from ... import *</code>这种方式，对 <code>import xxx</code>这种方式无效</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> 包名 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python异常</title>
      <link href="/2023/07/09/Python%E5%BC%82%E5%B8%B8/"/>
      <url>/2023/07/09/Python%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h2><h3 id="捕获常规异常"><a href="#捕获常规异常" class="headerlink" title="捕获常规异常"></a>捕获常规异常</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure><h3 id="捕获特定异常"><a href="#捕获特定异常" class="headerlink" title="捕获特定异常"></a>捕获特定异常</h3><p>如果尝试执行的代码的异常类型和要捕获异常类型不一致，则无法捕获异常。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name变量名称未定义错误&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="捕获多个异常"><a href="#捕获多个异常" class="headerlink" title="捕获多个异常"></a>捕获多个异常</h3><p>当捕获多个异常时，可以把要捕获的异常类型的名字，放到except 后，并使用元组的方式进行书写。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivision错误...&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="捕获异常并输出描述信息"><a href="#捕获异常并输出描述信息" class="headerlink" title="捕获异常并输出描述信息"></a>捕获异常并输出描述信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h2 id="捕获所有异常"><a href="#捕获所有异常" class="headerlink" title="捕获所有异常"></a>捕获所有异常</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h3 id="异常else"><a href="#异常else" class="headerlink" title="异常else"></a>异常else</h3><p>else表示的时如果没有异常要执行的代码。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我是else，是没有异常的时候执行的代码&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="异常的finally"><a href="#异常的finally" class="headerlink" title="异常的finally"></a>异常的finally</h3><p>finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有异常，真开心&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><h2 id="异常的传递"><a href="#异常的传递" class="headerlink" title="异常的传递"></a>异常的传递</h2><ul><li><p>当所有函数都没有捕获异常的时候，程序就会报错。</p></li><li><p>利用异常传递性的特点，当我们想要保证程序不会因为异常奔溃的时候，就可以在<code>main</code>函数这种设置异常捕捉，由于无论在整个程序哪里发生异常，最终都会传递到<code>main</code>函数中。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2023/07/09/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/07/09/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p><code>open(name,mode,encoding)</code></p><ul><li><p>name:是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。</p></li><li><p>mode:设置打开文件的模式(访问模式)：只读、写入、追加等。</p></li><li><p>encoding:编码格式（推荐使用UTF-8）</p></li></ul><p>例子：<code>f=open(&#39;python.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;)</code>,encoding的顺序不是第三位，所以不能使用位置参数，用<code>关键字参数</code>直接指定。</p><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td>只读模式，文件指针在文件开头。这是默认模式。</td></tr><tr><td style="text-align:center">w</td><td>从头开始编辑，原有内容会被删除。<code>如果不存在，创建新文件</code></td></tr><tr><td style="text-align:center">a</td><td>如果文件存在，新内容会被写入到已有内容之后。<code>如果不存在，创建性文件。</code></td></tr></tbody></table></div><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><ul><li><p><code>read(num)方法</code>：num表示要从文件中读取的数据的长度，如果没有传入num，那么就表示读取文件中所有的数据。如果文件是以文本模式(非二进制模式)打开的，则read()函数会<code>逐个字符</code>进行读取；反之，如果文件以二进制模式打开，则read()函数会<code>逐个字节</code>进行读取。</p></li><li><p><code>readlines()方法</code>: 可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个<code>列表</code>，其中每一行的数据为一个元素。<code>换行符也会被读取</code>。</p></li><li><p><code>readline()方法</code>：一次读取一行内容，<code>换行符也会被读取</code>。当readline的返回值为空时，代表已经读到末尾了。</p></li><li><p>for循环读取文件行</p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(line)文件关闭 </span><br></pre></td></tr></table></figure><h2 id="文件关闭"><a href="#文件关闭" class="headerlink" title="文件关闭"></a>文件关闭</h2><ol><li><p><code>f.close()</code></p></li><li><p>使用with open的语句块对文件进行操作，可以在操作完后自动close文件，避免遗忘掉close方法。</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.readlines()</span><br></pre></td></tr></table></figure><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>案例演示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment"># 内容刷新</span></span><br><span class="line">f.flush() </span><br></pre></td></tr></table></figure><p><code>注意：</code></p><ul><li><p>直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区</p></li><li><p>当调用flush的时候，内容会真正写入文件</p></li><li><p>这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）</p></li></ul><h2 id="文件追加"><a href="#文件追加" class="headerlink" title="文件追加"></a>文件追加</h2><p>案例演示</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```python</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">f.write(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="comment"># 内容刷新</span></span><br><span class="line">f.flush() </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据容器</title>
      <link href="/2023/07/08/Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/07/08/Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="空列表定义"><a href="#空列表定义" class="headerlink" title="空列表定义"></a>空列表定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名称 = []</span><br><span class="line">变量名称 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><h3 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">1</span>])  <span class="comment"># Rose</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">2</span>])  <span class="comment"># Lily</span></span><br><span class="line"><span class="built_in">print</span>(name_list[-<span class="number">3</span>])  <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure><h3 id="查询下标"><a href="#查询下标" class="headerlink" title="查询下标"></a>查询下标</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.index(<span class="string">&quot;t&quot;</span>)</span><br></pre></td></tr></table></figure><p>查找指定元素在列表的下标，如果找不到，报错ValueError。</p><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br></pre></td></tr></table></figure><h3 id="追加元素1"><a href="#追加元素1" class="headerlink" title="追加元素1"></a>追加元素1</h3><p>将指定元素，追加列表的尾部</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.append(<span class="string">&quot;Jerry&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name_list) <span class="comment"># [&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, &#x27;Jerry&#x27;]</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.append([<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(name_list) <span class="comment"># [&#x27;Tom&#x27;, &#x27;Lily&#x27;, &#x27;Rose&#x27;, [&#x27;a&#x27;, &#x27;b&#x27;]]</span></span><br></pre></td></tr></table></figure><h3 id="追加元素2"><a href="#追加元素2" class="headerlink" title="追加元素2"></a>追加元素2</h3><p>将其他数据容器的内容取出，依次追加到列表尾部</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.extend([<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><ol><li>del 列表[下标]</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line"><span class="keyword">del</span> name_list[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br></pre></td></tr></table></figure><ol><li>列表.pop(下标)</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Lily&quot;</span>, <span class="string">&quot;Rose&quot;</span>]</span><br><span class="line">name_list.<span class="comment">##pop(0)</span></span><br><span class="line"><span class="built_in">print</span>(name_list)</span><br></pre></td></tr></table></figure><h3 id="删除列表中的第一个匹配项"><a href="#删除列表中的第一个匹配项" class="headerlink" title="删除列表中的第一个匹配项"></a>删除列表中的第一个匹配项</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">my_list.remove(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 结果 [1,3,2]</span></span><br></pre></td></tr></table></figure><h3 id="清空列表内容"><a href="#清空列表内容" class="headerlink" title="清空列表内容"></a>清空列表内容</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">my_list.clear()</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 结果 []</span></span><br></pre></td></tr></table></figure><h3 id="统计某元素在列表内的数量"><a href="#统计某元素在列表内的数量" class="headerlink" title="统计某元素在列表内的数量"></a>统计某元素在列表内的数量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(my_list.count(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h2 id="统计个数"><a href="#统计个数" class="headerlink" title="统计个数"></a>统计个数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(my_list))</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><h3 id="定义空元组"><a href="#定义空元组" class="headerlink" title="定义空元组"></a>定义空元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名称=()</span><br><span class="line">变量名称=<span class="built_in">tuple</span>()</span><br></pre></td></tr></table></figure><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><div class="table-container"><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>index()</td><td>查找下标，不存在报错</td></tr><tr><td>count()</td><td>统计 某个数据出现个数</td></tr><tr><td>len(元组)</td><td>统计元组内的元素个数</td></tr></tbody></table></div><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><p>不可以修改元组的内容，否则会直接报错</p></li><li><p>可以修改元素内list的内容(修改元素、增加、删除、反转等)</p></li><li><p>不可以替换list为其他list或其他类型</p></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><code>注意</code>:字符串是一个<code>无法修改</code>的数据容器。</p><p>以下操作均无法完成：</p><ul><li><p>修改指定下标的字符(如：字符串[0]=’a’ ）</p></li><li><p>移除特定下标的字符 (如：del 字符串[0]、字符串.remove()、字符串.pop()等 )</p></li><li><p>追加字符等(如：字符串.append() )</p></li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container"><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>index()</td><td>查找下标</td></tr><tr><td>replace(“字符串1”,”字符串2”)</td><td>字符串内的全部：字符串1，替换为字符串2。<code>注意</code>：不是修改字符串本身，而是得到了一个新的字符串。</td></tr><tr><td>split(“ “)</td><td>按照指定的分隔字符串，将字符串划分为多个字符串，并存入列表对象。</td></tr><tr><td>strip()</td><td>去除前后空格</td></tr><tr><td>strip(字符串)</td><td>去前后指定字符串 例: print(“1255521”.strip(“12”)) # 结果 555</td></tr><tr><td>count(字符串)</td><td>字符串的出现次数</td></tr><tr><td>len(字符串)</td><td>字符串长度</td></tr></tbody></table></div><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>定义：从一个序列中，取出一个子序列。</p><p>序列定义：列表、元组、字符串</p><p><code>语法</code>：序列[开始下标:结束下标:步长]，左闭右开，[开始下标,结束下标)。</p><ul><li><p>开始可以省略，省略从头开始</p></li><li><p>结束可以省略，省略到尾结束</p></li><li><p>步长可以省略，省略步长为1(可以为负数，表示倒序执行)</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>因为要对元素做去重处理，所以无法保证顺序和创建的时候一致。</p><h3 id="定义空集合"><a href="#定义空集合" class="headerlink" title="定义空集合"></a>定义空集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量名称=<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h3 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>add(元素)</td><td>添加元素</td></tr><tr><td>remove(元素)</td><td>将指定元素移除</td></tr><tr><td>pop()</td><td>随机去除一个元素，同时集合被修改</td></tr><tr><td>clear()</td><td>本身被清空</td></tr><tr><td>集合1.difference(集合2)</td><td>取集合1和集合2的差集，集合1-集合2。集合1不变</td></tr><tr><td>集合1.difference_update(集合2)</td><td>在集合1内，删除和集合2相同的元素。<code>集合1被修改，集合2不变</code></td></tr><tr><td>集合1.intersection(集合2)</td><td>求集合1和集合2的交集</td></tr><tr><td>集合1.union(集合2)</td><td>将集合1和集合2组合成新集合。集合不变</td></tr><tr><td>len(集合)</td><td>统计长度</td></tr></tbody></table></div><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="定义空字典"><a href="#定义空字典" class="headerlink" title="定义空字典"></a>定义空字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_dict=&#123;&#125;</span><br><span class="line">my_dict=<span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><h3 id="嵌套字典"><a href="#嵌套字典" class="headerlink" title="嵌套字典"></a>嵌套字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stu_score = &#123;</span><br><span class="line">    <span class="string">&quot;王丽红&quot;</span>: &#123;<span class="string">&quot;语文&quot;</span>: <span class="number">77</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">66</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">55</span>&#125;,</span><br><span class="line">    <span class="string">&quot;周杰轮&quot;</span>: &#123;<span class="string">&quot;语文&quot;</span>: <span class="number">88</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">99</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">33</span>&#125;,</span><br><span class="line">    <span class="string">&quot;林军阶&quot;</span>: &#123;<span class="string">&quot;语文&quot;</span>: <span class="number">99</span>, <span class="string">&quot;数学&quot;</span>: <span class="number">88</span>, <span class="string">&quot;英语&quot;</span>: <span class="number">77</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(stu_score[<span class="string">&quot;王丽红&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(stu_score[<span class="string">&quot;王丽红&quot;</span>][<span class="string">&quot;语文&quot;</span>])</span><br></pre></td></tr></table></figure><h3 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h3><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>字典[key]=val</td><td>新增元素</td></tr><tr><td>字典[key]=val</td><td>更新元素</td></tr><tr><td>字典.pop(key)</td><td>删除元素</td></tr><tr><td>字典.clear()</td><td>元素被清空</td></tr><tr><td>字典.keys()</td><td>得到全部key</td></tr><tr><td>len(字典)</td><td>求全部的键值对</td></tr></tbody></table></div><h2 id="数据的通用统计功能"><a href="#数据的通用统计功能" class="headerlink" title="数据的通用统计功能"></a>数据的通用统计功能</h2><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>len(容器)</td><td>长度</td></tr><tr><td>max(容器)</td><td>统计最大元素</td></tr><tr><td>list(容器)</td><td>转换为列表</td></tr><tr><td>str(容器)</td><td>转换为字符串</td></tr><tr><td>tuple(容器)</td><td>转换为元组</td></tr><tr><td>set(容器)</td><td>转换为集合</td></tr><tr><td>sorted(容器,[reverse=True])</td><td>将给定容器进行排序，<code>返回一个新的序列</code></td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数</title>
      <link href="/2023/07/08/Python%E5%87%BD%E6%95%B0/"/>
      <url>/2023/07/08/Python%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">传入参数</span>):</span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></table></figure><h2 id="函数的说明文档"><a href="#函数的说明文档" class="headerlink" title="函数的说明文档"></a>函数的说明文档</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    两数相加</span></span><br><span class="line"><span class="string">    :param x: 相加的数字1</span></span><br><span class="line"><span class="string">    :param y: 相加的数字2</span></span><br><span class="line"><span class="string">    :return: 返回相加的结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><p>在Python编写代码，可以通过鼠标悬停，查看调用函数的说明文档。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230708175913.png" alt=""></p><h2 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_return</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x, y = test_return()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure><h2 id="函数多种传参方式"><a href="#函数多种传参方式" class="headerlink" title="函数多种传参方式"></a>函数多种传参方式</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>调用函数时根据函数定义的参数位置来传递参数，传递的参数和定义的参数的顺序及个数必须一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>函数调用时通过“键=值”形式传递参数，可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_info(gender=<span class="string">&#x27;男&#x27;</span>,age=<span class="number">20</span>,name=<span class="string">&#x27;Tom&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><p>当调用函数时没有传递参数，就会使用默认是用缺省参数对应的值。默认值的参数必须定义在最后。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">name, age, gender=<span class="string">&#x27;男&#x27;</span></span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;您的名字是<span class="subst">&#123;name&#125;</span>,年龄是<span class="subst">&#123;age&#125;</span>,性别是<span class="subst">&#123;gender&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_info(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">user_info(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>当调用函数时不确认参数个数时，可以使用不定长参数</p><ul><li>位置传递</li></ul><p>传进的所有参数都会被args变量手机，它会根据传进参数的位置合并为一个元组(tuple),args是<code>元组</code>类型，这就是位置传参。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;Tom&#x27;,20)</span></span><br><span class="line">user_info(<span class="string">&#x27;Tom&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># (&#x27;Jerry&#x27;,15,&#x27;女’)</span></span><br><span class="line">user_info(<span class="string">&#x27;Jerry&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;女&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>关键字传参</li></ul><p>参数是<code>键=值</code>形式的情况下，所有的<code>键=值</code>都会被kwargs接受，同时会根据<code>键=值</code></p><p>组成<code>字典</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">user_info</span>(<span class="params">**args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;:&#x27;Tom&#x27;,&#x27;age&#x27;:12&#125;</span></span><br><span class="line">user_info(name=<span class="string">&quot;Tom&quot;</span>, age=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>语法：<code>lambda 传入参数: 函数体(一行代码)</code></p><p>冒号后面的的表达式时函数的返回值</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python小知识点</title>
      <link href="/2023/07/08/Python%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/07/08/Python%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<ul><li><p>input()获取的数据类型永远是字符串类型。</p></li><li><p>基本数据类型</p></li></ul><ol><li><p>整数（int）：表示整数值，例如：1、10、-5等。</p></li><li><p>浮点数（float）：表示带有小数部分的数值，例如：3.14、2.0、-0.5等。</p></li><li><p>布尔值（bool）：表示真（True）或假（False）的值。</p></li><li><p>字符串（str）：表示一串字符，用引号（单引号或双引号）括起来，例如：”Hello”、’World’等。</p></li><li><p>列表（list）：表示一组有序的元素，用方括号括起来并用逗号分隔，例如：[1, 2, 3]、[‘a’, ‘b’, ‘c’]等。</p></li><li><p>元组（tuple）：表示一组有序的元素，用圆括号括起来并用逗号分隔，例如：(1, 2, 3)、(‘a’, ‘b’, ‘c’)等，<code>不可变</code>。</p></li><li><p>集合（set）：表示一组无序的唯一元素，用花括号括起来并用逗号分隔，例如：{1, 2, 3}、{‘a’, ‘b’, ‘c’}等。</p></li><li><p>字典（dict）：表示一组键值对，用花括号括起来，键值对之间用冒号分隔，例如：{‘name’: ‘John’, ‘age’: 25}等。</p></li></ol><ul><li><p>print(“Hello”, end=’’)，可以输出不换行</p></li><li><p>while循环和for循环的不同点</p><ul><li><p>for循环只能从被处理的数据集中，依次取出内容进行处理</p></li><li><p>for循环无法定义循环条件，理论上无法构建无线循环</p></li></ul></li><li><p>range(num)获取一个从0开始，到num结束的数字序列。左闭右开！</p></li><li><p>range(num1,num2)获得一个从num1开始，到num2结束的数字序列。左闭右开。</p></li><li><p>range(num1,num2,step)获得一个从num1开始，到num2结束的数字序列。数字之间的步长以step为准。</p></li><li><p>函数没有使用return也有返回值，返回值是<code>None</code>这个自变量，类型是NoneType。<code>None</code>可以主动使用return返回，效果等同于return语句。</p></li><li><p>None类型的应用场景</p><ul><li><p>用在函数无返回值上</p></li><li><p>在if判断上，None等同于<code>False</code></p></li><li><p>用于声明无内容的变量上。定义变量时，但暂时不需要变量有具体值，可以用None来代替。</p></li></ul></li><li><p>使用<code>global</code>关键字可以在函数内部声明变量为全局变量</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-运算符</title>
      <link href="/2023/07/08/Python-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/07/08/Python-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>/</code>: 除法，用于将一个值除以另一个值，结果为浮点数。</p><p><code>//</code>: 整除，用于将一个值除以另一个值，结果为整数(向下取整)。</p><p><code>**</code>: 幂运算，用于将一个值的指数幂。<code>2**3</code>表示<code>2的3次方</code></p><h2 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h2><p><code>in</code>：如果指定的值在序列中存在，则返回 True。</p><p><code>not in</code>：如果指定的值在序列中不存在，则返回 True。</p><h2 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h2><p><code>is</code>：如果两个变量引用同一个对象，则返回 True。</p><p><code>is not</code>：如果两个变量引用的不是同一个对象，则返回 True。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x == y)   <span class="comment"># True，x 和 y 的值相等</span></span><br><span class="line"><span class="built_in">print</span>(x <span class="keyword">is</span> y)   <span class="comment"># False，x 和 y 引用不同的对象</span></span><br></pre></td></tr></table></figure><p>即使两个对象的值相等，但它们可能是不同的对象。在Python中，对象的身份是由对象在<code>内存中的地址</code>表示的，而对象的值是对象所包含的数据。当我们使用 <code>is</code> 运算符时，它比较的是对象的身份，而不仅仅是对象的值。</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p><code>&lt;&lt;</code>：左移，将一个数的二进制表示向左移动指定的位数。</p><p><code>&gt;&gt;</code>：右移，将一个数的二进制表示向右移动指定的位数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 格式化输出</title>
      <link href="/2023/07/08/Python-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"/>
      <url>/2023/07/08/Python-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;&#125; and I&#x27;m &#123;&#125; years old.&quot;</span>.<span class="built_in">format</span>(name, age))</span><br></pre></td></tr></table></figure><p>在这个例子中，大括号 <code>&#123;&#125;</code> 作为占位符，<code>format()</code> 方法中的参数按照顺序填充到占位符的位置。</p><h2 id="指定参数顺序"><a href="#指定参数顺序" class="headerlink" title="指定参数顺序"></a>指定参数顺序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;1&#125; and I&#x27;m &#123;0&#125; years old.&quot;</span>.<span class="built_in">format</span>(age, name))</span><br></pre></td></tr></table></figure><p>通过在占位符中使用索引号，可以指定参数的顺序。在这个例子中，<code>&#123;1&#125;</code> 表示第二个参数 <code>name</code>，<code>&#123;0&#125;</code> 表示第一个参数 <code>age</code>。</p><h2 id="指定参数名"><a href="#指定参数名" class="headerlink" title="指定参数名"></a>指定参数名</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is &#123;n&#125; and I&#x27;m &#123;a&#125; years old.&quot;</span>.<span class="built_in">format</span>(n=name, a=age))</span><br></pre></td></tr></table></figure><h2 id="格式设置"><a href="#格式设置" class="headerlink" title="格式设置"></a>格式设置</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="number">3.14159</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;The value is &#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(value))</span><br></pre></td></tr></table></figure><p>使用 <code>:</code> 可以进行进一步的格式设置。在这个例子中，<code>:.2f</code> 表示保留两位小数的浮点数格式。</p><h2 id="对齐和填充"><a href="#对齐和填充" class="headerlink" title="对齐和填充"></a>对齐和填充</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Left aligned: &#123;:&lt;10&#125;&quot;</span>.<span class="built_in">format</span>(text))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Right aligned: &#123;:&gt;10&#125;&quot;</span>.<span class="built_in">format</span>(text))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Center aligned: &#123;:^10&#125;&quot;</span>.<span class="built_in">format</span>(text))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Filled: &#123;:_^10&#125;&quot;</span>.<span class="built_in">format</span>(text))</span><br></pre></td></tr></table></figure><p>通过使用 <code>&lt;</code>、<code>&gt;</code> 和 <code>^</code> 可以对文本进行左对齐、右对齐和居中对齐。在这个例子中，<code>&#123;:&lt;10&#125;</code> 表示左对齐，占位符长度为 10；<code>&#123;:&gt;10&#125;</code> 表示右对齐；<code>&#123;:^10&#125;</code> 表示居中对齐；<code>&#123;:_^10&#125;</code> 表示在文本两侧填充下划线，使其长度为 10。</p><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="%格式化输出"></a>%格式化输出</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">age = <span class="number">12</span></span><br><span class="line">height = <span class="number">1.83</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;My name is %s, I am %d years old, I am %.2f meters&quot;</span> % (name, age, height))</span><br></pre></td></tr></table></figure><h2 id="精度控制"><a href="#精度控制" class="headerlink" title="%精度控制"></a>%精度控制</h2><p>可以使用<code>m.n</code>来控制数据的宽度和精度</p><ul><li><p>m，用来控制宽度，<code>设置的宽度小于数字自身，不生效</code></p></li><li><p>n，用来控制小数点精度，要求是数字，会进行小数的<code>四舍五入</code></p></li></ul><p>示例：</p><p><code>%5d</code>:表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成[空格][空格][空格]11,用三个空格补足宽度</p><p><code>%7.2f</code>:表示将宽度控制为7，将小数点精度设置为2.小数点也算入宽度计算。如，对11.345设置了<code>%7.2f</code>后，结果是：[空格][空格][空格]11.35。两个空格补足宽度。</p><p><code>%.2f</code>:表示不限制宽度，只是设置小数点精度为2,。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串消消乐</title>
      <link href="/2023/07/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B6%88%E6%B6%88%E4%B9%90/"/>
      <url>/2023/07/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B6%88%E6%B6%88%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>消除相邻重复元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">removeConsecutiveDuplicates</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="comment">//如果原数组当前元素左右两个元素不同，将当前元素加入result</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || arr[i] != arr[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == arr.<span class="built_in">size</span>()<span class="number">-1</span> || arr[i] != arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size=arr.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result = <span class="built_in">removeConsecutiveDuplicates</span>(arr);</span><br><span class="line">    <span class="type">int</span> after_size=result.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(size!=after_size)</span><br><span class="line">    &#123;</span><br><span class="line">    size=result.<span class="built_in">size</span>();</span><br><span class="line">result=<span class="built_in">removeConsecutiveDuplicates</span>(result);</span><br><span class="line">after_size=result.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消除相邻重复元素大于k的字母</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>删除有序数组重复项通解</title>
      <link href="/2023/07/05/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E9%80%9A%E8%A7%A3/"/>
      <url>/2023/07/05/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E9%87%8D%E5%A4%8D%E9%A1%B9%E9%80%9A%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">work</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(autonum : nums)</span><br><span class="line">            <span class="keyword">if</span>(len &lt; k || nums[len-k] != num)</span><br><span class="line">                nums[len++] = num;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">work</span>(nums, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>链表相加</title>
      <link href="/2023/07/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/07/05/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/add-two-numbers/">链接</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *cur = pre;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n1 = l1 ? l1-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n2 = l2 ? l2-&gt;val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1)</span><br><span class="line">            &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2)</span><br><span class="line">            &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程同步</title>
      <link href="/2023/07/04/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2023/07/04/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="声明一把互斥锁"><a href="#声明一把互斥锁" class="headerlink" title="声明一把互斥锁"></a>声明一把互斥锁</h3><p><code>注意</code>：互斥锁是一个全局变量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span>  mutex;</span><br></pre></td></tr></table></figure><h3 id="初始化和释放"><a href="#初始化和释放" class="headerlink" title="初始化和释放"></a>初始化和释放</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"> <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 线程销毁之后, 再去释放互斥锁</span></span><br><span class="line"> <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br></pre></td></tr></table></figure><h3 id="加锁-amp-解锁"><a href="#加锁-amp-解锁" class="headerlink" title="加锁&amp;解锁"></a>加锁&amp;解锁</h3><p><code>pthread_mutex_lock(&amp;mutex)</code>:</p><ul><li><p>没有被锁定，是打开的，这个线程可以加锁成功，这个这个锁中会记录是哪个线程加锁成功了</p></li><li><p>如果被锁定了，其他线程加锁就失败了，这些线程都会<strong>阻塞</strong>在这把锁上</p></li><li><p>当这把锁被解开之后，这些阻塞在锁上的线程就解除阻塞了，并且这些线程是通过竞争的方式对这把锁加锁，没抢到锁的线程继续阻塞</p></li></ul><p><code>pthread_mutex_trylock(&amp;mutex)</code>:</p><ul><li><p>如果这把锁没有被锁定是打开的，线程加锁成功</p></li><li><p>如果锁变量被锁住了，调用这个函数加锁的线程，<strong>不会被阻塞</strong>，加锁失败直接返回错误号</p></li></ul><p><code>pthread_mutex_unlock(&amp;mutex)</code>:</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>定义：读写锁是互斥锁的升级版，在做读操作的时候可以提高程序的执行效率，如果所有的线程都是做读操作, 那么读是并行的，但是使用互斥锁，读操作也是串行的。</p><p>特征：</p><ul><li><p>使用读写锁的读锁锁定了临界区，线程对临界区的访问是并行的，读锁是共享的。</p></li><li><p>使用读写锁的写锁锁定了临界区，线程对临界区的访问是串行的，写锁是独占的。</p></li><li><p>使用读写锁分别对两个临界区加了读锁和写锁，两个线程要同时访问者两个临界区，访问写锁临界区的线程继续运行，访问读锁临界区的线程阻塞，因为写锁比读锁的优先级高。</p></li></ul><h3 id="声明一把读写锁"><a href="#声明一把读写锁" class="headerlink" title="声明一把读写锁"></a>声明一把读写锁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_rwlock_t</span> rwlock;</span><br></pre></td></tr></table></figure><h3 id="初始化-amp-释放"><a href="#初始化-amp-释放" class="headerlink" title="初始化&amp;释放"></a>初始化&amp;释放</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 销毁读写锁</span></span><br><span class="line"><span class="built_in">pthread_rwlock_destroy</span>(&amp;rwlock)</span><br></pre></td></tr></table></figure><h3 id="加锁-amp-解锁-1"><a href="#加锁-amp-解锁-1" class="headerlink" title="加锁&amp;解锁"></a>加锁&amp;解锁</h3><ul><li><p><code>pthread_rwlock_rdlock(&amp;rwlock)</code>：调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数的线程会被<strong>阻塞</strong>。</p></li><li><p><code>pthread_rwlock_tryrdlock(&amp;rwlock)</code>:调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作，调用这个函数依然可以加锁成功，因为读锁是共享的；如果读写锁已经锁定了写操作，调用这个函数加锁失败，对应的线程<strong>不会被阻塞</strong>，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p></li><li><p><code>pthread_rwlock_wrlock(&amp;rwlock)</code>:调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数的线程会被阻塞。</p></li><li><p><code>pthread_rwlock_trywrlock(&amp;rwlock)</code>:调用这个函数，如果读写锁是打开的，那么加锁成功；如果读写锁已经锁定了读操作或者锁定了写操作，调用这个函数加锁失败，但是线程不会阻塞，可以在程序中对函数返回值进行判断，添加加锁失败之后的处理动作。</p></li><li><p><code>pthread_rwlock_unlock(&amp;rwlock)</code>:解锁, 不管锁定了读还是写都可用解锁。</p></li></ul><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><h3 id="声明一个条件变量"><a href="#声明一个条件变量" class="headerlink" title="声明一个条件变量"></a>声明一个条件变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br></pre></td></tr></table></figure><h3 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_cond_init</span>(&amp;cond,<span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">pthread_cond_destroy</span>(&amp;cond)</span><br></pre></td></tr></table></figure><h3 id="wait操作"><a href="#wait操作" class="headerlink" title="wait操作"></a>wait操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutex) </span><br></pre></td></tr></table></figure><ul><li><p>在阻塞线程时候，如果线程已经对互斥锁 mutex 上锁，那么会将这把锁打开，这样做是为了避免死锁</p></li><li><p>当线程解除阻塞的时候，函数内部会帮助这个线程再次将这个 mutex 互斥锁锁上，继续向下访问临界区</p></li></ul><h3 id="唤醒操作"><a href="#唤醒操作" class="headerlink" title="唤醒操作"></a>唤醒操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 至少有一个被解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒阻塞在条件变量上的线程, 被阻塞的线程全部解除阻塞</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="声明一个信号量"><a href="#声明一个信号量" class="headerlink" title="声明一个信号量"></a>声明一个信号量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> sem;</span><br></pre></td></tr></table></figure><h3 id="初始化和释放-1"><a href="#初始化和释放-1" class="headerlink" title="初始化和释放"></a>初始化和释放</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 信号量初始化</span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;psem, <span class="number">0</span>, <span class="number">5</span>);    <span class="comment">// 5个生产者可以同时生产</span></span><br><span class="line"><span class="built_in">sem_init</span>(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);    <span class="comment">// 消费者线程没有资源, 因此不能消费</span></span><br><span class="line"><span class="comment">// 信号销毁</span></span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;psem);</span><br><span class="line"><span class="built_in">sem_destroy</span>(&amp;csem);</span><br></pre></td></tr></table></figure><h3 id="wait操作-1"><a href="#wait操作-1" class="headerlink" title="wait操作"></a>wait操作</h3><ul><li><p><code>sem_wait(&amp;sem)</code>:当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，因此线程也就被阻塞了。</p></li><li><p><code>sem_trywait(&amp;sem)</code>:当线程调用这个函数，并且 sem 中的资源数 &gt;0，线程不会阻塞，线程会占用 sem 中的一个资源，因此资源数 - 1，直到 sem 中的资源数减为 0 时，资源被耗尽，但是线程不会被阻塞，直接返回错误号，因此可以在程序中添加判断分支，用于处理获取资源失败之后的情况。</p></li></ul><h3 id="唤醒操作-1"><a href="#唤醒操作-1" class="headerlink" title="唤醒操作"></a>唤醒操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sem_post</span>(&amp;sem)</span><br></pre></td></tr></table></figure><p>调用该函数会将 sem 中的资源数 +1，如果有线程在调用 sem_wait、sem_trywait、sem_timedwait 时因为 sem 中的资源数为 0 被阻塞了，这时这些线程会解除阻塞，获取到资源之后继续向下运行。</p><h3 id="查看资源个数"><a href="#查看资源个数" class="headerlink" title="查看资源个数"></a>查看资源个数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看信号量 sem 中的整形数的当前值, 这个值会被写入到sval指针对应的内存中</span></span><br><span class="line"><span class="comment">// sval是一个传出参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure><p>通过这个函数可以查看 sem 中现在拥有的资源个数，通过第二个参数 sval 将数据传出，也就是说第二个参数的作用和返回值是一样的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/2023/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/07/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程函数汇总"><a href="#线程函数汇总" class="headerlink" title="线程函数汇总"></a>线程函数汇总</h2><h3 id="返回当前线程的线程ID"><a href="#返回当前线程的线程ID" class="headerlink" title="返回当前线程的线程ID`"></a>返回当前线程的线程ID`</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="type">void</span>)</span></span>;    </span><br></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p><code>重要结论</code>:在没有人为干预的情况下，虚拟地址空间的生命周期和主线程是一样的，与子线程无关。如果要让子线程执行完毕，主线程在推出，可以在主线程中添加<code>sleep()</code>。</p><h3 id="线程退出"><a href="#线程退出" class="headerlink" title="线程退出"></a>线程退出</h3><p>作用：终止线程，并返回结果。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="回收子线程数据"><a href="#回收子线程数据" class="headerlink" title="回收子线程数据"></a>回收子线程数据</h3><p>如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>使用子线程栈</code>：如果多个线程共用同一个虚拟地址空间，每个线程在栈区都有一块属于自己的内存，相当于栈区被这几个线程平分了，当线程退出，线程在栈区的内存也就被回收了，因此随着子线程的退出，写入到栈区的数据也就被释放了。</p></li><li><p><code>使用全局变量</code>：位于同一虚拟地址空间中的线程，虽然不能共享栈区数据，但是可以共享<code>全局数据区</code>和<code>堆区数据</code>，因此在子线程退出的时候可以将传出数据存储到全局变量、静态变量或者堆内存中。</p></li><li><p><code>使用主线程栈</code>：虽然每个线程都有属于自己的栈区空间，但是位于同一个地址空间的多个线程是可以相互访问对方的栈空间上的数据的。由于很多情况下还需要在主线程中回收子线程资源，所以主线程一般都是最后退出，基于这个原因在下面的程序中将子线程返回的数据保存到了主线程的栈区。</p></li></ul><h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><p>问题：在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，调用<code>pthread_join()</code> 只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。</p><p>解决：在线程库函数中为我们提供了线程分离函数 pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。线程分离之后在主线程中使用 pthread_join() 就回收不到子线程资源了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><p>线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：</p><ol><li><p>在线程 A 中调用线程取消函数 <code>pthread_cancel</code>，指定杀死线程 B，这时候线程 B 是死不了的。</p></li><li><p>在线程 B 中进程一次系统调用（从用户区切换到内核区），否则线程 B 可以一直运行。</p></li></ol><h2 id="线程ID比较"><a href="#线程ID比较" class="headerlink" title="线程ID比较"></a>线程ID比较</h2><p>返回值：如果两个线程 ID 相等返回非 0 值，如果不相等返回 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="type">pthread_t</span> t1, <span class="type">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常考设计模式</title>
      <link href="/2023/07/04/%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/07/04/%E5%B8%B8%E8%80%83%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>岛屿问题模板</title>
      <link href="/2023/07/03/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/07/03/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;grid, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断边界是否合适</span></span><br><span class="line">    <span class="type">int</span> row=grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> col=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(!(r&gt;=<span class="number">0</span>&amp;&amp;r&lt;row&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;col)) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断这个格子是不是岛屿</span></span><br><span class="line">    <span class="keyword">if</span>(grid[r][c]!=<span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将格子标记为已经遍历</span></span><br><span class="line">    grid[r][c]=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问上、下、左、右四个相邻结点</span></span><br><span class="line">    <span class="built_in">dfs</span>(grid,r<span class="number">-1</span>,c);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,r+<span class="number">1</span>,c);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,r,c<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(grid,r,c+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针模板</title>
      <link href="/2023/07/02/%E5%8F%8C%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF/"/>
      <url>/2023/07/02/%E5%8F%8C%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> N= s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>; </span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; counter; <span class="comment">//用于统计 子数组/子区间 是否有效</span></span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>; <span class="comment">//保存最大的满足题目要求的子数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> right=<span class="number">0</span>; right&lt;N; right++)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[s[right]]++;<span class="comment">//增加右边指针的计数</span></span><br><span class="line">        <span class="keyword">while</span>() <span class="comment">//[left,right]区间不满足题意</span></span><br><span class="line">        &#123;</span><br><span class="line">            counter[s[left]]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当while结束时，找到了一个符合要求的子串</span></span><br><span class="line">        res=<span class="built_in">max</span>(res,right-left+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>埃氏筛法</title>
      <link href="/2023/07/02/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"/>
      <url>/2023/07/02/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h2><p>一种求质数的高级算法</p><p><img src="https://pic.leetcode-cn.com/1606932458-HgVOnW-Sieve_of_Eratosthenes_animation.gif" alt=""></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n=<span class="number">1000</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n,<span class="literal">true</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isPrime_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i*i; j&lt;n; j+=i)</span><br><span class="line">            &#123;</span><br><span class="line">                isPrime[j]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">isPrime_func</span>();</span><br><span class="line">    cout&lt;&lt;isPrime[<span class="number">17</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>左值引用和右值引用</title>
      <link href="/2023/07/01/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/07/01/%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="左值引用与右值引用的区别"><a href="#左值引用与右值引用的区别" class="headerlink" title="左值引用与右值引用的区别"></a>左值引用与右值引用的区别</h2><p><code>定义</code>：左值引用是对左值的引用。右值引用是对右值的引用。</p><p><code>功能差异</code>:</p><ul><li><p>左值引用(避免对象拷贝)</p><ul><li><p>函数传参</p></li><li><p>函数返回值(拷贝赋值函数)</p></li></ul></li><li><p>右值引用</p><ul><li><p>移动语义</p></li><li><p>完美转发</p></li></ul></li></ul><h2 id="左值和右值的区别"><a href="#左值和右值的区别" class="headerlink" title="左值和右值的区别"></a>左值和右值的区别</h2><p>左值的特性：</p><ul><li><p>可以放在<code>=</code>的左边</p></li><li><p>能够取地址</p></li><li><p>具备名字(可以有<code>左</code>引用)</p></li></ul><p>左值举例：</p><ul><li><p>变量名</p></li><li><p>返回值为引用的函数调用</p></li><li><p>前置自增/前置自减</p></li><li><p>赋值运算符或复合赋值运算</p></li><li><p>解引用</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先自增再赋值给i，再进行一个返回。所以++i这个表达式返回的还是i本身，可以取地址</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    ++i=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值运算符|复合赋值运算</span></span><br><span class="line">    (i=<span class="number">9</span>)=<span class="number">100</span>;</span><br><span class="line">    (i+=<span class="number">10</span>)=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解引用</span></span><br><span class="line">    <span class="type">int</span> *num = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    *num=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>右值的特性：</p><ul><li><p>只能在<code>=</code>右边</p></li><li><p>不能取地址</p></li><li><p>不具备名字(不能有<code>左</code>引用)</p></li></ul><p>右值类型：</p><ul><li><p>纯右值(不具备标识符的临时对象或表达式)</p><ul><li><p>字面值</p></li><li><p>返回非引用类型的函数调用</p></li><li><p>后置自增/后置自减</p></li><li><p>算术表达式/逻辑表达式</p></li></ul></li><li><p>将亡值：</p><ul><li><p>可以用来触发移动构造或者移动赋值构造，并进行资源转移。</p></li><li><p>将亡值是一种特殊的纯右值，具有右值引用类型，可以进行修改和转移的对象。(因为只有右值引用类型才能触发移动构造或者移动赋值构造)。</p></li><li><p>move()主要用于将对象转换为右值引用，以便实现移动语义和资源的转移操作。</p></li><li><p><code>将亡值是一种要被移动的右值</code>，它允许对资源进行转移，以实现高效的资源管理。</p></li></ul></li></ul><h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>作用：对象赋值时，避免资源的重新分配。</p><p>实现：移动构造以及移动拷贝构造</p><p>STL应用：由于实现了移动语义，效率大幅增高。例如insert，erase。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p><code>定义</code>：函数模板可以将自己的参数可以完美地转发给内部调用的其他函数，其中完美是指不仅能够转发参数的值，还能保证被转发的参数左右值属性不变。</p><p><code>万能引用</code>：通过引用的方式接收左右属性的值(T&amp;&amp;)，使用万能引用可以保证正确的参数接收。</p><p><code>引用折叠规则</code>：参数为左值或左值引用，T&amp;&amp;将转换为int &amp;；参数为右值或右值引用，T&amp;&amp;将转换为int&amp;&amp;。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revoke</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">revoke</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(n));</span><br><span class="line"><span class="type">int</span> &amp; &amp;&amp;t =&gt; <span class="type">int</span> &amp;t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">revoke</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(m));</span><br><span class="line"><span class="type">int</span>&amp;&amp; &amp;&amp;t =&gt; <span class="type">int</span> &amp;&amp; t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">revoke</span>(n);</span><br><span class="line"><span class="type">int</span> &amp;&amp; t =&gt; <span class="type">int</span> &amp; t;</span><br></pre></td></tr></table></figure><p><code>std:forward&lt;T&gt;(v)</code>T为左值引用，v将转换成T类型的左值；T为右值引用，v将转换为T类型的右值。</p><h2 id="大杂烩"><a href="#大杂烩" class="headerlink" title="大杂烩"></a>大杂烩</h2><p>左值引用能否指向右值，右值引用能否指向左值？</p><ul><li><p>const左值引用能指向右值，局限是不能修改这个值</p></li><li><p>右值引用可以通过move()指向左值</p></li><li><p>声明出的左值引用和右值引用是左值</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试</title>
      <link href="/2023/06/30/GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2023/06/30/GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 10</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;参数个数：&quot;</span>&lt;&lt;argc&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;参数 &quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;: &quot;</span>&lt;&lt;argv[i]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;宏变量 &quot;</span>&lt;&lt;NUM&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gdb调试准备"><a href="#gdb调试准备" class="headerlink" title="gdb调试准备"></a>gdb调试准备</h2><p>要进行调试首先要生成带调试信息的可执行文件，命令为<code>g++ -g app.cpp -o app_g</code>。通过列表查看带调试信息的可执行文件大小比较大。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230630200329.png" alt=""></p><h2 id="gdb启动和退出"><a href="#gdb启动和退出" class="headerlink" title="gdb启动和退出"></a>gdb启动和退出</h2><p>注意gdb启动时，程序并没有运行</p><p><code>gdb app_g</code>启动GDB命令行界面</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出gdb</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">quit == q</span></span><br><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure><h2 id="gdb传参"><a href="#gdb传参" class="headerlink" title="gdb传参"></a>gdb传参</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置参数</span></span><br><span class="line">(gdb) set args 1 2 3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示参数</span></span><br><span class="line">(gdb) show args</span><br></pre></td></tr></table></figure><h2 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行到main的第一行阻塞</span></span><br><span class="line">(gdb) start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行到断点位置或者将程序运行完</span></span><br><span class="line">(gdb) run</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂停的程序继续运行，直到遇到一个断点或者程序结束</span></span><br><span class="line">(gdb) continue</span><br></pre></td></tr></table></figure><h2 id="使用list查看文件中的代码"><a href="#使用list查看文件中的代码" class="headerlink" title="使用list查看文件中的代码"></a>使用list查看文件中的代码</h2><p> 默认情况下<code>list</code>查看到代码信息位于程序入口函数<code>main</code>对应的那个文件中，因此如果不进行文件切换<code>main</code>函数所在的文件就是<strong>当前文件</strong>，如果进行了文件切换，切换到哪个文件就是<strong>当前文件</strong>。</p><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认显示10行</span></span><br><span class="line">(gdb) list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看更多内容</span></span><br><span class="line">(gdb) 回车</span><br></pre></td></tr></table></figure><h3 id="切换文件"><a href="#切换文件" class="headerlink" title="切换文件"></a>切换文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到指定文件，并查看指定行号的上下文，默认显示10行</span></span><br><span class="line">(gdb) list 文件名:行号</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到指定文件，并查看指定函数的上下文，默认显示10行</span></span><br><span class="line">(gdb) list 文件名:函数名</span><br></pre></td></tr></table></figure><h3 id="设置显示的行数"><a href="#设置显示的行数" class="headerlink" title="设置显示的行数"></a>设置显示的行数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以下两个命令中的listsize都可以写成list</span></span><br><span class="line">(gdb) set listsize 行数</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前list一次显示的函数</span></span><br><span class="line">(gdb) show listsize</span><br></pre></td></tr></table></figure><h2 id="设置和查看断点"><a href="#设置和查看断点" class="headerlink" title="设置和查看断点"></a>设置和查看断点</h2><h3 id="设置普通断点"><a href="#设置普通断点" class="headerlink" title="设置普通断点"></a>设置普通断点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前文件的某一行上设置断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">break</span> == b</span></span><br><span class="line">(gdb) b 行号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停在函数的第一行</span></span><br><span class="line">(gdb) b 函数名  </span><br></pre></td></tr></table></figure><h3 id="设置条件断点"><a href="#设置条件断点" class="headerlink" title="设置条件断点"></a>设置条件断点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须要满足某个条件，程序才会停在这个断点的位置上</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常在循环中使用条件断点</span></span><br><span class="line"></span><br><span class="line">(gdb) b 行号 变量名==某个值</span><br></pre></td></tr></table></figure><h3 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">info == i</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看设置的断点信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">info <span class="built_in">break</span></span></span><br><span class="line">(gdb) i b  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230630221230.png" alt=""></p><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">delete == del == d</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要 info b 查看断点的信息，第一列就是编号</span></span><br><span class="line">(gdb) d 断点的编号</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除第1个断点</span></span><br><span class="line">(gdb) d 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除第2,4,6个断点</span></span><br><span class="line">(gdb) d 2 4 6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除范围内的断点</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除第1个到第5个断点</span></span><br><span class="line">(gdb) d 1-5</span><br></pre></td></tr></table></figure><h3 id="设置断点状态"><a href="#设置断点状态" class="headerlink" title="设置断点状态"></a>设置断点状态</h3><h4 id="设置断点无效"><a href="#设置断点无效" class="headerlink" title="设置断点无效"></a>设置断点无效</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">disable</span> == dis</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者几个断点无效</span></span><br><span class="line">(gdb) dis 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个区间断点无效</span></span><br><span class="line">(gdb) dis 断点1编号-断点n编号</span><br></pre></td></tr></table></figure><h4 id="让无效的断点生效"><a href="#让无效的断点生效" class="headerlink" title="让无效的断点生效"></a>让无效的断点生效</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">enable</span> == ena</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个或者几个断点无效</span></span><br><span class="line">(gdb) ena 断点1的编号 [断点2的编号 ...]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置某一个区间断点无效</span></span><br><span class="line">(gdb) ena 断点1编号-断点n编号</span><br></pre></td></tr></table></figure><h2 id="打印变量和变量类型"><a href="#打印变量和变量类型" class="headerlink" title="打印变量和变量类型"></a>打印变量和变量类型</h2><div class="table-container"><table><thead><tr><th style="text-align:center">格式化字符(/fmt)</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>/x</code></td><td style="text-align:center">十六进制</td></tr><tr><td style="text-align:center"><code>/d</code></td><td style="text-align:center">有符号，十进制</td></tr><tr><td style="text-align:center"><code>/u</code></td><td style="text-align:center">无符号、十进制</td></tr><tr><td style="text-align:center"><code>/o</code></td><td style="text-align:center">八进制</td></tr><tr><td style="text-align:center"><code>/t</code></td><td style="text-align:center">二进制</td></tr><tr><td style="text-align:center"><code>/f</code></td><td style="text-align:center">浮点数</td></tr><tr><td style="text-align:center"><code>/c</code></td><td style="text-align:center">字符型</td></tr></tbody></table></div><h3 id="打印变量名"><a href="#打印变量名" class="headerlink" title="打印变量名"></a>打印变量名</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">print</span> == p</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以十进制格式</span></span><br><span class="line">(gdb) p 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以十六进制格式</span></span><br><span class="line">(gdb) p/x 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以八进制格式</span></span><br><span class="line">(gdb) p/o 变量名</span><br></pre></td></tr></table></figure><h3 id="打印变量类型"><a href="#打印变量类型" class="headerlink" title="打印变量类型"></a>打印变量类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ptype 变量名</span><br></pre></td></tr></table></figure><h2 id="跟踪变量"><a href="#跟踪变量" class="headerlink" title="跟踪变量"></a>跟踪变量</h2><p><code>display</code>命令可以跟踪<code>变量</code>或者<code>表达式</code>的值，每单程序暂停执行(例如单步执行时)，GDB调试器就会自动帮我们打印出来。</p><h3 id="设置变量自动显示"><a href="#设置变量自动显示" class="headerlink" title="设置变量自动显示"></a>设置变量自动显示</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在变量的有效取值范内, 自动打印变量的值(设置一次, 以后就会自动显示)</span></span><br><span class="line">(gdb) display 变量名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以指定的整形格式打印变量的值, 关于 <span class="built_in">fmt</span> 的取值, 请参考 <span class="built_in">print</span> 命令</span></span><br><span class="line">(gdb) display/fmt 变量名</span><br></pre></td></tr></table></figure><h3 id="查看自动显示列表"><a href="#查看自动显示列表" class="headerlink" title="查看自动显示列表"></a>查看自动显示列表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">info == i</span></span><br><span class="line">(gdb) info display</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230630231043.png" alt=""></p><h3 id="取消自动显示-删除"><a href="#取消自动显示-删除" class="headerlink" title="取消自动显示(删除)"></a>取消自动显示(删除)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) undisplay num [num1 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) undisplay num1-numN</span><br><span class="line"></span><br><span class="line">(gdb) delete display num [num1 ...]</span><br><span class="line">(gdb) delete display num1-numN</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="取消自动显示-禁用"><a href="#取消自动显示-禁用" class="headerlink" title="取消自动显示(禁用)"></a>取消自动显示(禁用)</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) disable display num [num1 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) disable display num1-numN</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启用被禁用的变量"><a href="#启用被禁用的变量" class="headerlink" title="启用被禁用的变量"></a>启用被禁用的变量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令中的 num 是通过 info display 得到的编号, 编号可以是一个或者多个</span></span><br><span class="line">(gdb) enable  display num [num1 ...]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">num1 - numN 表示一个范围</span></span><br><span class="line">(gdb) enable display num1-numN</span><br></pre></td></tr></table></figure><h2 id="单步调试"><a href="#单步调试" class="headerlink" title="单步调试"></a>单步调试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">step若当前行是函数，进入函数内部</span></span><br><span class="line">step == s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若通过step进入到函数内部，想要跳出函数体，可以执行finish</span></span><br><span class="line">(gdb) finish</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">next不会进入函数内部</span></span><br><span class="line">next == n</span><br></pre></td></tr></table></figure><p><code>注意</code>：若函数内部有断点，使用<code>finish</code>无法跳出函数，会执行到断点的位置。所以说<code>finish</code>和<code>continue</code>在程度上有很相似的作用。</p><h2 id="使用until跳出循环体"><a href="#使用until跳出循环体" class="headerlink" title="使用until跳出循环体"></a>使用until跳出循环体</h2><p>生效条件：</p><ul><li><p>循环体内不能有有效的断点，否者无法跳出循环体</p></li><li><p>必须在循环体的开始/结束执行该命令</p></li></ul><h2 id="设置变量值"><a href="#设置变量值" class="headerlink" title="设置变量值"></a>设置变量值</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以在循环中使用, 直接设置循环因子的值</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设某个变量的值在程序中==90的概率是5%, 这时候可以直接通过命令将这个变量值设置为90</span></span><br><span class="line">(gdb) set var 变量名=值</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀树</title>
      <link href="/2023/06/30/%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/2023/06/30/%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li><p>高效存储和检索字符串数据集中的键</p></li><li><p>前缀搜索和拼写检查</p></li></ul><h2 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h2><p>插入<code>Insert</code>: O(1)-&gt;O(N)</p><p>搜索<code>Search</code>:O(N)</p><p>前缀搜索 <code>startWith</code>:O(NM)</p><h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Tire，又称前缀树或字典树，是一颗有根树，每个结点包含以下字段。</p><ul><li><p>指向子节点的指针数组<code>children</code>,对于26字母而言，数组长度为26。此时children[0]对应a，children[1]对应b，……，children[25]对应z。</p></li><li><p>布尔字段<code>isEnd</code>,表示该结点是否为字符串的结尾</p></li></ul><h3 id="数据结构图"><a href="#数据结构图" class="headerlink" title="数据结构图"></a>数据结构图</h3><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230630183523.png" alt=""></p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>k为字符串长度</strong></p><p>插入<code>Insert</code>: O(k)</p><p>搜索<code>Search</code>:O(k)</p><p>前缀搜索 <code>startWith</code>:O(k)</p><h3 id="数据结构实现"><a href="#数据结构实现" class="headerlink" title="数据结构实现"></a>数据结构实现</h3><ol><li><p>插入字符串</p><p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p><ul><li><p>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</p></li><li><p>子节点不存在。创建一个新的子节点，记录在 children 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符</p></li></ul><p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p></li><li><p>查找前缀/字符串</p><p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p><ul><li><p>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</p></li><li><p>子节点不存在。说明字典树中不包含该前缀，返回空指针。</p></li></ul><p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <code>isEnd</code>为真，则说明字典树中存在该字符串。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TrieNode*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isWord;</span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>), <span class="built_in">children</span>(<span class="number">26</span>, <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; c : children)</span><br><span class="line">            <span class="keyword">delete</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> a : word) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i])</span><br><span class="line">                p-&gt;children[i] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> a : word) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode* p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> a : prefix) &#123;</span><br><span class="line">            <span class="type">int</span> i = a - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;children[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            p = p-&gt;children[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="力扣题"><a href="#力扣题" class="headerlink" title="力扣题"></a>力扣题</h3><ul><li><p>208 实现Trie</p></li><li><p>720 词典中最长的单词</p></li><li><p>692 前k个高频单词</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀树 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux设置开机自启动</title>
      <link href="/2023/06/29/Linux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
      <url>/2023/06/29/Linux%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="在rc-local文件中添加自启动命令"><a href="#在rc-local文件中添加自启动命令" class="headerlink" title="在rc.local文件中添加自启动命令"></a>在rc.local文件中添加自启动命令</h2><ol><li><p>执行命令，编辑<code>/etc/rc.local</code></p><p><code>vim /etc/rc.local</code></p></li><li><p>在文件最后一行添加要执行的命令</p><p><code>cd /home/ubuntu/projects/tinyHTTP &amp;&amp; nohup sudo ./httpd &amp;</code></p></li><li><p>添加完后设置rc.local可执行权限</p><p><code>chmod +x /etc/rc.local</code></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VisualStudio调试</title>
      <link href="/2023/06/28/VisualStudio%E8%B0%83%E8%AF%95/"/>
      <url>/2023/06/28/VisualStudio%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h2><p>错误：<code>&#39;scanf&#39;: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</code></p><p>解决方案：</p><p>1.在写代码的前面加上如下宏定义</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230628105901.png" alt=""></p><p>2.关闭SDL检查</p><p>SDL(Security Development Lifecycle)是指安全开发生命周期，是一个安全保证的过程。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230628110317.png" alt=""></p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a>动态调试</h2><ol><li><p>设置断点(鼠标左键点击代码左侧)</p></li><li><p>开始调试</p><ol><li><p><code>F5</code>可以运行到断点或者程序结束(没有断点)</p></li><li><p><code>F11</code>单步进入到程序第一行代码</p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230628123419.png" alt="F5执行效果"></p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230628123533.png" alt="F10执行效果"></p></li><li><p>调试中</p><ol><li><p><code>F5</code>继续运行直到下一个断点</p></li><li><p><code>F11</code>单步执行，遇到函数进入[没有调试源码的不进入]。</p></li><li><p><code>shift+F11</code>进入函后的跳出指令，</p></li><li><p><code>F10</code>单步跳过，遇到函数不进入。</p></li></ol></li><li><p>查看调试变量</p><ol><li><p>自动窗口：查看执行代码周围的变量(比如当前执行代码的上下三行内)</p></li><li><p>局部变量：当前作用域内的变量</p></li><li><p>监视：可以监视<code>变量</code>或者<code>表达式</code></p></li></ol></li><li><p>查看函数调用层次(调用堆栈)</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2023/06/25/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/06/25/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/course-schedule/description/">207.课程表</a></p><p>[1,0]表示0-&gt;1</p><p>数据结构：</p><ul><li><p>入度表 <code>vector&lt;int&gt;</code></p></li><li><p>邻接表 <code>map&lt;int,vector&lt;int&gt;&gt;</code></p></li><li><p>队列 <code>queue&lt;int&gt;</code> 存储入度为0的结点</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1-&gt;2</span></span><br><span class="line"><span class="comment">        1-&gt;3</span></span><br><span class="line"><span class="comment">        得到1-&gt;2,3</span></span><br><span class="line"><span class="comment">        将1弹出时，2的入度和3的入度--</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inDegree</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        map&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;prerequisites.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            inDegree[prerequisites[i][<span class="number">0</span>]]++;</span><br><span class="line">            map[prerequisites[i][<span class="number">1</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>) que.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> selected=que.<span class="built_in">front</span>();<span class="comment">//当前选的课</span></span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            count++;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; next_course=map[selected];<span class="comment">//后序课</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;next_course.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                inDegree[next_course[i]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[next_course[i]]==<span class="number">0</span>) que.<span class="built_in">push</span>(next_course[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++输出格式</title>
      <link href="/2023/06/25/C-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/06/25/C-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="对输出小数精度控制"><a href="#对输出小数精度控制" class="headerlink" title="对输出小数精度控制"></a>对输出小数精度控制</h2><p>头文件:<code>&lt;iomanip&gt;</code></p><p>注意：不加fixed，<code>setprecisioin()会控制有效数字的位数，而不是小数点的位数</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> pi=<span class="number">3.14159</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;pi&lt;&lt;endl;<span class="comment">//3.14</span></span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">3</span>)&lt;&lt;pi&lt;&lt;endl;<span class="comment">//3.142</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>移动测试“</title>
      <link href="/2023/06/24/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/06/24/%E7%A7%BB%E5%8A%A8%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><p>功能测试:查看功能是否正常</p></li><li><p>安装卸载测试</p></li><li><p>升级测试</p></li><li><p>兼容性测试</p><ul><li><p>Android系统版本</p></li><li><p>厂商二次开发版本</p></li><li><p>不同的分辨率</p></li><li><p>不同的网络</p></li></ul></li><li><p>网络切换、中断测试<br>使用中来电话、短信<br>横竖屏切换<br>健壮性:耗电量、流量消耗、崩满回复</p></li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>java sdk</p><ol><li><p>安装</p></li><li><p>配置JAVA_HOME和PATH</p></li></ol></li><li><p>Android SDK</p><ol><li><p>解压</p></li><li><p>配置ANDROID_HOME和PATH</p></li></ol></li><li><p>安装虚拟机/真机的开发者模式</p></li><li><p>appium client(Python)</p></li><li><p>appium server</p></li></ol><h2 id="adb命令"><a href="#adb命令" class="headerlink" title="adb命令"></a>adb命令</h2><p><code>adb devices</code>：测试连接是否成功</p><p><code>adb devices -l</code>：查看deviceName</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230624185600.png" alt=""></p><p>model后面就是设备名</p><p><code>adb shell</code>: 进入安卓内核</p><p><code>adb shell getprop ro.build.version.release</code>:获取安卓版本</p><p><code>adb shell dumpsys window | findstr mCurrentFocus</code> 查看运行的apk和界面</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230624184002.png" alt=""></p><p><code>/</code>前是包名，<code>/</code>后是app当前的活动</p><h2 id="appium连接真机"><a href="#appium连接真机" class="headerlink" title="appium连接真机"></a>appium连接真机</h2><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230624190646.png" alt=""></p><p><code>注意</code>：</p><ol><li><p>Remote Path必须填/wd/hub; </p></li><li><p>SSL不要勾选</p></li></ol><h2 id="appium工作原理"><a href="#appium工作原理" class="headerlink" title="appium工作原理"></a>appium工作原理</h2><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230624194620.png" alt=""></p><p>Appium客户端和Appium服务器之间通过<code>HTTP</code>协议和<code>JSON</code>数据格式进行通信，客户端发送测试命令，服务器执行操作并返回结果。Appium服务器通过ADB与连接到计算机的Android设备进行通信，使用ADB命令执行与设备相关的操作。这样，整个测试流程就实现了客户端、服务器和设备之间的交互和通信。</p><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>通过<code>xpath</code>定位</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>driver</p><ul><li><p>close_app()</p></li><li><p>install_app()</p></li><li><p>remove_app()</p></li></ul></li><li><p>element</p><ul><li><p>text 获取元素文本内容</p></li><li><p>click() 点击对应元素</p></li><li><p>get_attribute() 获取属性值</p></li><li><p>location</p></li><li><p>size 获取宽高</p></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>map排序</title>
      <link href="/2023/06/22/map%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/06/22/map%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="map对于key-键-的排序"><a href="#map对于key-键-的排序" class="headerlink" title="map对于key(键)的排序"></a>map对于key(键)的排序</h2><h3 id="map中的key-默认排序"><a href="#map中的key-默认排序" class="headerlink" title="map中的key 默认排序"></a>map中的key 默认排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对于map中的key的默认排序</span></span><br><span class="line"> </span><br><span class="line">map&lt;<span class="type">int</span>,string&gt;m;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m[<span class="number">1</span>]=<span class="string">&quot;iui&quot;</span>;</span><br><span class="line">m[<span class="number">87</span>]=<span class="string">&quot;sjddd&quot;</span>;</span><br><span class="line">m[<span class="number">2</span>]=<span class="string">&quot;jsd&quot;</span>;</span><br><span class="line">m[<span class="number">67</span>]=<span class="string">&quot;yuuuu&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item: m)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;item.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="key的自定义排序"><a href="#key的自定义排序" class="headerlink" title="key的自定义排序"></a>key的自定义排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rule</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string&amp; a,<span class="type">const</span> string&amp; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;<span class="comment">//对于键是string型按照从大到小排</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//map中的第三个参数其实就是排序规则，之前不写就会默认成默认排序</span></span><br><span class="line">map&lt;string,<span class="type">int</span>,rule&gt;m;</span><br><span class="line">m[<span class="string">&quot;a&quot;</span>]=<span class="number">199</span>;</span><br><span class="line">m[<span class="string">&quot;c&quot;</span>]=<span class="number">99</span>;</span><br><span class="line">m[<span class="string">&quot;b&quot;</span>]=<span class="number">878</span>;</span><br><span class="line">m[<span class="string">&quot;ab&quot;</span>]=<span class="number">1515</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item: m)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;item.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="key是结构体-仿函数"><a href="#key是结构体-仿函数" class="headerlink" title="key是结构体(仿函数)"></a>key是结构体(仿函数)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//按照键是结构体的排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rule</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.score==b.score)&#123;</span><br><span class="line"><span class="keyword">return</span> a.name&gt;b.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序规则是按照成绩大的在前面，相同按照名字降序</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">node stu;</span><br><span class="line">map&lt;node,<span class="type">int</span>,rule&gt;m;</span><br><span class="line">stu.name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">stu.score=<span class="number">88</span>;</span><br><span class="line">m[stu]=<span class="number">1212</span>;</span><br><span class="line">stu.name=<span class="string">&quot;acd&quot;</span>;</span><br><span class="line">stu.score=<span class="number">88</span>;</span><br><span class="line">m[stu]=<span class="number">1213</span>;</span><br><span class="line">stu.name=<span class="string">&quot;bcbc&quot;</span>;</span><br><span class="line">stu.score=<span class="number">100</span>;</span><br><span class="line">m[stu]=<span class="number">1214</span>;</span><br><span class="line">stu.name=<span class="string">&quot;zzzzzz&quot;</span>;</span><br><span class="line">stu.score=<span class="number">1000</span>;</span><br><span class="line">m[stu]=<span class="number">8989</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item: m)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;item.first.name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.first.score&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="key是结构体-结构体内自定义大小"><a href="#key是结构体-结构体内自定义大小" class="headerlink" title="key是结构体(结构体内自定义大小)"></a>key是结构体(结构体内自定义大小)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//对于键是结构体的自定义排序</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;s)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(score!=s.score)<span class="keyword">return</span> score&gt;s.score;</span><br><span class="line">        <span class="keyword">return</span> name&gt;s.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;node,<span class="type">int</span>&gt;m;</span><br><span class="line">node u;</span><br><span class="line">u.name=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">u.score=<span class="number">99</span>;</span><br><span class="line">m[u]=<span class="number">12</span>;</span><br><span class="line">u.name=<span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">u.score=<span class="number">99</span>;</span><br><span class="line">m[u]=<span class="number">13</span>;</span><br><span class="line">u.name=<span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">u.score=<span class="number">100</span>;</span><br><span class="line">m[u]=<span class="number">14</span>;</span><br><span class="line">u.name=<span class="string">&quot;yuy&quot;</span>;</span><br><span class="line">u.score=<span class="number">15</span>;</span><br><span class="line">m[u]=<span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> item: m)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;item.first.name&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;item.first.score&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map对于value-值-排序"><a href="#map对于value-值-排序" class="headerlink" title="map对于value(值)排序"></a>map对于value(值)排序</h2><p>需要用到vector容器和sort函数,sort函数需要自定义排序规则。其中使用sort可以同时也可以对<strong>key</strong>进行排序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//map中对于value排序</span></span><br><span class="line"><span class="comment">//之前说的map是个键值对，所以需要vector</span></span><br><span class="line"><span class="comment">//来接收的话，那么就需要一对一，就需要用到pair了</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> pair&lt;string,<span class="type">int</span>&gt; a,pair&lt;string,<span class="type">int</span>&gt;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;m;</span><br><span class="line">m[<span class="string">&quot;asas&quot;</span>]=<span class="number">18</span>;</span><br><span class="line">m[<span class="string">&quot;ioio&quot;</span>]=<span class="number">90</span>;</span><br><span class="line">m[<span class="string">&quot;cj&quot;</span>]=<span class="number">89</span>;</span><br><span class="line">vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt;<span class="built_in">v</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),cmp);</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">cout&lt;&lt;v[i].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v[i].second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>原博客链接</code>：<a href="https://blog.csdn.net/gaoqiandr/article/details/127172792">C++中的map排序<em>c++ map排序</em>菜到极致就是渣的博客-CSDN博客</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>输入输出重定向</title>
      <link href="/2023/06/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
      <url>/2023/06/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>freopen() 定义在<code>&lt;stdio.h&gt;</code>头文件中，是 C 语言标准库中的函数，专门用于重定向输入流（包括 scanf()、gets() 等）和输出流（包括 printf()、puts() 等）。值得一提的是，该函数也可以对 C++ 中的 cin 和 cout 进行重定向。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    <span class="comment">//cin、cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>      <span class="comment">//string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>     <span class="comment">//freopen</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string name, url;</span><br><span class="line">    <span class="comment">//将标准输入流重定向到 in.txt 文件</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    cin &gt;&gt; name &gt;&gt; url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将标准输出重定向到 out.txt文件</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout); </span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; url;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>随机数</title>
      <link href="/2023/06/22/%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2023/06/22/%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> seed;</span><br><span class="line">seed=<span class="built_in">time</span>(<span class="number">0</span>);<span class="comment">//返回1970年1月1日午夜开始到现在逝去的秒数</span></span><br><span class="line">cout&lt;&lt;seed&lt;&lt;endl;</span><br><span class="line"><span class="built_in">srand</span>(seed);<span class="comment">//只需调用一次</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">rand</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制随机数的范围"><a href="#限制随机数的范围" class="headerlink" title="限制随机数的范围"></a>限制随机数的范围</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> seed;</span><br><span class="line">seed=<span class="built_in">time</span>(<span class="number">0</span>);<span class="comment">//返回1970年1月1日午夜开始到现在逝去的秒数</span></span><br><span class="line">cout&lt;&lt;seed&lt;&lt;endl;</span><br><span class="line"><span class="built_in">srand</span>(seed);<span class="comment">//只需调用一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//生成范围为[min_val,max_val]</span></span><br><span class="line"><span class="type">int</span> min_val=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> max_val=<span class="number">18</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">rand</span>()%(max_val-min_val+<span class="number">1</span>)+min_val&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串的分割</title>
      <link href="/2023/06/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2/"/>
      <url>/2023/06/21/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%86%E5%89%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1,2,3,4,5</span></span><br><span class="line"><span class="comment">//如何分割逗号间隔的字符串</span></span><br><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">string str_num;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">getline</span>(ss,str_num,<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(str_num));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;vec[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-amp-substr"><a href="#find-amp-substr" class="headerlink" title="find &amp; substr"></a>find &amp; substr</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1,2,3,4,5</span></span><br><span class="line"><span class="comment">//如何分割逗号间隔的字符串</span></span><br><span class="line">string str;</span><br><span class="line"><span class="built_in">getline</span>(cin,str);</span><br><span class="line">str+=<span class="string">&quot;,&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">while</span>(str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>)!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pos=str.<span class="built_in">find</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>,pos)));</span><br><span class="line">str=str.<span class="built_in">substr</span>(pos+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout&lt;&lt;vec[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>过去一年来的总结以及未来打算</title>
      <link href="/2023/06/17/%E8%BF%87%E5%8E%BB%E4%B8%80%E5%B9%B4%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%89%93%E7%AE%97/"/>
      <url>/2023/06/17/%E8%BF%87%E5%8E%BB%E4%B8%80%E5%B9%B4%E6%9D%A5%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E6%89%93%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>长话短说吧，过去一年的时间都在备战考研。至于考研的原因也很简单，当时自己太菜了，觉得肯定找不到工作，想着在<code>蓄水池</code>先待着，然后再找找机会的。结果寄了，自己还是那么菜。当时选择报考厦门大学，是因为有个新开的人工智能系，分数还蛮低的。然后自己觉得肯定可以的，不过天不随人愿，我报考的那年分数暴涨50分，我的分数是超过了去年的分数线，不过只有10多分。毫无意外，没了。失败总结：<code>那时候根本来说还是太过于自信了，目光也太短浅，看不到长期的发展趋势。最根本的是不够努力，有时候真的是自我感动了，以为自己做的蛮多准备的</code>。所以呢，有时候事情能做好的时候，就要把它做到完美，不然根本没有获胜的机会。</p><p>考研结束后呢，已经12月底了，还没完成实习任务，花了一个多月时间，找到了一份工作，不过是电话客服。做了一两个月。然后身心俱疲的回学校了。不过还有一门课和毕业设计等待着我(考研太<code>专心</code>，缺考了一门课)。回到学校呢已经4月份了，那时候真的觉得很累。期间呢有投过几份简历，不过简历写得太烂了，几乎都是已读不回的。不过此时身边的同学也几乎都有offer了，我那时候我也很焦虑。然后摆烂了好几天，期间我一直做思想斗争，似乎说服我自己。后来我想开了，真的想开了。</p><blockquote><p>没有理所当然的幸福，所有的一切都是自己争取来了。不必艳羡他人的光芒，毕竟别人也曾付出过无数的汗水和泪水。</p></blockquote><p>近期打算是先找一份暑假工，然后利用剩余时间学习一下软件测试，重回互联网公司。</p><p>自我安慰：没事的少年，人生是场马拉松，不要在意一时的得失。我不是比别人晚了一年吗，那我用接下来的一年来弥补。</p><p>内心的一点忏悔：大学期间，没有把专业知识学到位，浪费太多的时间在内耗和游戏上了。所以如今的一切都是苦果，没什么好抱怨的，自己选择的路再荒谬也要走下去！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2023/06/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2023/06/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程池的原理"><a href="#1-线程池的原理" class="headerlink" title="1.线程池的原理"></a>1.线程池的原理</h2><p><code>作用</code>: 实现线程的复用，避免频繁创建和销毁线程。</p><p>线程池的组成分为3个部分，3个部分配合工作就可以得到一个线程池：</p><ol><li><p>任务队列</p><ul><li><p>线程池的使用者就是生产者线程</p></li><li><p>线程池的使用者会往任务队列里面添加任务</p></li></ul></li><li><p>工作线程(消费者)，N个</p><ul><li>不停读任务队列，从里面取出任务处理</li></ul></li><li><p>管理者线程</p><ul><li><p>周期性的对任务队列的任务数量以及处于忙对象的工作线程进行检测</p></li><li><p>当任务过多时，创建一些新的工作线程</p></li><li><p>当任务过少时，销毁一些工作的线程</p></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次C++笔试</title>
      <link href="/2023/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1C-%E7%AC%94%E8%AF%95/"/>
      <url>/2023/06/16/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1C-%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、选择题-25"><a href="#一、选择题-25" class="headerlink" title="一、选择题(25)"></a>一、选择题(25)</h2><p>1.实现运行时多态要使用(<code>C</code>)</p><p>A.构造函数  B.析构函数  C.虚函数  D.重载函数</p><p><br/></p><p>2.在C++中，数据封装要解决的问题是(<code>B</code>)</p><p>A.数据高速转换</p><p>B.切断了不同模块之间的数据的非法使用  </p><p>C数据规范化排列  </p><p>D.避免数据丢失</p><p><br/></p><p>3.算法的时间复杂度是指(<code>C</code>)</p><p>A.执行算法程序所需要的时间</p><p>B.算法程序的长度</p><p>C算法执行过程中所需要的基本运算次数</p><p>D.算法程序中的指令条数</p><p><br/></p><p>4.执行语句printf”%x”-1),后输出结果是(<code>D</code>)</p><p>A.-1<br>B.-ffff</p><p>C.1<br>D.ffff</p><p><br/></p><p>5.数组定义为 int a[2][3]={1,2,3,4,5}，数组元素值为1的是()</p><p>A.a[1][2]</p><p>B.a[1][1]</p><p>c.a[2][3]</p><p>D.a[0][0]</p><h2 id="填空题-20分"><a href="#填空题-20分" class="headerlink" title="填空题(20分)"></a>填空题(20分)</h2><p><strong>1.给定结构体</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">token_t</span>&#123;</span><br><span class="line">  <span class="type">char</span> digit;</span><br><span class="line">  <span class="type">char</span> index;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> data;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> tick;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则sizeof(token_t)=<code>8</code></p><p><code>解析</code>:char是1字节，unsigned short是 2字节，unsigned long是4字节。所以一共是1+1+2+4=8;</p><p><code>规则</code>:需要字节对齐，使得内存访问速度提升。</p><ul><li><p>成员变量存放位置一般是成员变量大小的倍数。</p></li><li><p>结构体的总大小是最大成员大小的整数倍。</p></li><li><p>声明的先后顺序对大小也有影响。（以32位的编译器举例子）</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;</span><br><span class="line"> <span class="type">char</span> a; <span class="comment">// 1字节</span></span><br><span class="line"> <span class="type">int</span> b; <span class="comment">// 4字节</span></span><br><span class="line"> <span class="type">short</span> c; <span class="comment">// 2字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl;<span class="comment">// 12</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl;<span class="comment">// 16</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(C)&lt;&lt;endl;<span class="comment">// 24</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img title="" src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230616132324.png" alt="结构体A" data-align="inline"> </p><p><img title="" src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230616133419.png" alt="结构体B" data-align="inline"></p><p><img title="" src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230616133608.png" alt="结构体C" data-align="inline"></p><p>2.程序的局部变量存在于(<code>栈</code>)中，全局变量存在于(<code>静态数据区/全局数据区</code>)中动态申请数据存在于(<code>堆</code>)中。</p><p>3.已知一个数组 array，用一个宏定义，求出数组的元素个数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ARRAY_SIZE(array) (sizeof(array) / sizeof((array)[0]))</span></span><br></pre></td></tr></table></figure><p>4.<code>char str[10];</code><br><code>strcpy(str,&quot;0123456789&quot;)</code></p><p>产生什么结果?为什么?</p><p><code>解析</code>：strcpy源码如下</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* destination, <span class="type">const</span> <span class="type">char</span>* source)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* ptr = destination;</span><br><span class="line">    <span class="keyword">while</span> (*source != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        *ptr = *source;</span><br><span class="line">        ptr++;</span><br><span class="line">        source++;</span><br><span class="line">    &#125;</span><br><span class="line">    *ptr = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 添加字符串结尾的 null 字符</span></span><br><span class="line">    <span class="keyword">return</span> destination;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str2 = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str1); <span class="comment">// 输出：Hello, world!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以虽然source的大小为11，str表示管理缓冲区大小为10的指针，但是还是可以运行，不过会导致缓冲区溢出，这是一种常见的安全漏洞。此时str的值变为”0123456789“。<code>注意</code>：char str[10]=”0123456789”;会在编译期间就报错了。</p><h2 id="三、简答题，写出程序执行结果，并解释原因-10-分"><a href="#三、简答题，写出程序执行结果，并解释原因-10-分" class="headerlink" title="三、简答题，写出程序执行结果，并解释原因(10 分)"></a>三、简答题，写出程序执行结果，并解释原因(10 分)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getstr</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     p=(<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">&quot;Tensun&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line">    <span class="built_in">getstr</span>(str);</span><br><span class="line">    <span class="keyword">if</span>( str)&#123;</span><br><span class="line">        str[<span class="number">6</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s,%d&quot;</span>,<span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">free</span>( str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>解析</code>getstr是值传递，不会改变str，对<code>str</code>条件检查后，访问str[6],这是一种未定义的行为，可能会导致程序崩溃。<code>注意</code>:printf(“%s”,str)时，因为未初始化，结果为<code>(null)</code></p><h2 id="MarkDown换行"><a href="#MarkDown换行" class="headerlink" title="MarkDown换行"></a>MarkDown换行</h2><ol><li><p>html换行标签： <code>&lt;br/&gt;</code></p></li><li><p>使用<code>&amp;nbsp;</code>(全称是 <code>non-breaking space</code>，表示非断空行)</p><ul><li><p>注意使用分号<code>;</code></p></li><li><p>只有在编辑区的空白行才能起到换行的作用，否则只是起到一个空格的作用。</p></li></ul></li></ol><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230616122420.png" title="" alt="" data-align="left"></p><p><img title="" src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230616122543.png" alt="" data-align="left"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何让程序运行在Linux后台</title>
      <link href="/2023/06/15/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Linux%E5%90%8E%E5%8F%B0/"/>
      <url>/2023/06/15/%E5%A6%82%E4%BD%95%E8%AE%A9%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8Linux%E5%90%8E%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>我用<code>SSH</code>软件可以连接到Linux服务器，不过一旦关闭SSH软件，Linux上跑的程序直接终止了。比如说我在Linux上运行一个Http服务器，为了维持运行，只能保持SSH软件开启，不过这根本就不合理啊，浪费了Linux服务器资源。所以呢，必须找到一个合适的办法，让程序长期跑在后台。</p><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>使用<code>pstree</code>后可以看到以下画面，我这里使用SSH客户端连接到了Linux服务器，并开启了两个终端，一个使用<code>ping</code>，一个使用<code>pstree</code>。当SSH客户端断开连接后，终端的会话就会结束。此时你运行的前台程序就会收到<code>（SIGHUP）</code>信号。默认情况下就会导致前台程序终止。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230615224131.png" alt=""></p><h3 id="nohup原理"><a href="#nohup原理" class="headerlink" title="nohup原理"></a>nohup原理</h3><p>使用<code>nohup</code>后，这将使得运行的程序忽略挂断信号，并且不会受到SSH连接断开的影响。程序的输出也会被重定向到<code>nohup.out</code>文件中，便于查询执行过程。此时运行的程序就会被托管到<code>init进程(进程号为1)</code>下。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>nohup ./your_program &amp;</code></p><h2 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><code>setsid</code> 的主要作用是将进程从当前终端分离出来，使其在后台独立运行，不受终端关闭或终端信号的影响。它常常与其他命令或进程一起使用，以确保进程在后台持续运行，即使终端会话结束。使用该命令后，进程会被<code>init进程</code>托管，这一段和nohup很像，不过一般为了查看输出，需要使用重定向符。</p><h3 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setsid ./your_program <span class="comment"># 未设置重定向</span></span><br><span class="line">setsid ./your_program &gt; output.txt <span class="comment"># 将输出重定向到文件</span></span><br><span class="line">setsid ./your_program &lt; input.txt <span class="comment"># 将输入重定向为文件</span></span><br></pre></td></tr></table></figure><h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Screen是一个在Linux和类Unix系统上运行的终端复用工具。它允许用户在一个终端会话中创建多个虚拟终端，并在其中运行多个程序或会话。Screen提供了一种持久化的会话环境，即使SSH连接断开或终端关闭，用户也可以重新连接到会话并继续之前的工作。和前面两种不同，此时程序被<code>screen</code>托管，而不是被<code>init</code>托管。不过使用前要先安装<code>sudo apt install screen</code>。</p><p><img title="" src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230615233403.png" alt="" data-align="inline"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen <span class="comment"># 创建screen终端</span></span><br><span class="line">Ctrl+a d <span class="comment"># 离开screen终端</span></span><br><span class="line">screen -<span class="built_in">ls</span> <span class="comment"># 显示已创建的screen终端</span></span><br><span class="line">screen -r screen_id <span class="comment">#重新连接已经离开的screen终端</span></span><br></pre></td></tr></table></figure><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="apt-update"><a href="#apt-update" class="headerlink" title="apt update"></a>apt update</h3><p><code>apt update</code> 是一个用于更新软件包列表的命令。在Ubuntu和其他基于Debian的Linux发行版中，<code>apt update</code> 命令用于与软件包管理系统的软件（repositories）通信，并获取最新的软件包信息。通过运行 <code>apt update</code>，系统会同步本地的软件包信息和远程软件源服务器上的软件包信息。这样可以确保你的本地软件包信息是最新的，从而能够正确地获取并安装最新的软件包版本。</p><h3 id="apt-upgrade"><a href="#apt-upgrade" class="headerlink" title="apt upgrade"></a>apt upgrade</h3><p><code>apt upgrade</code> 是一个用于升级已安装软件包的命令。在Ubuntu和其他基于Debian的Linux发行版中，<code>apt upgrade</code> 命令用于检查系统中已安装软件包的新版本，并执行升级操作，将这些软件包更新到最新可用的版本。在运行 <code>apt upgrade</code> 之前，建议先运行 <code>apt update</code> 命令来更新软件包列表，以确保获取到最新的软件包版本信息。</p><h2 id="其他Linux命令汇总"><a href="#其他Linux命令汇总" class="headerlink" title="其他Linux命令汇总"></a>其他Linux命令汇总</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID <span class="comment"># 杀死进程</span></span><br><span class="line">pstree <span class="comment"># 查看进程数</span></span><br><span class="line">ps -ef | grep info <span class="comment"># 查看特定进程的进程号和父进程</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雷军2022年度演讲-如何度过人生三次低谷</title>
      <link href="/2023/06/15/%E9%9B%B7%E5%86%9B2022%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/"/>
      <url>/2023/06/15/%E9%9B%B7%E5%86%9B2022%E5%B9%B4%E5%BA%A6%E6%BC%94%E8%AE%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="WPS"><a href="#WPS" class="headerlink" title="WPS"></a>WPS</h2><p>26岁的雷军是北京金山的总经理携带团队开发出盘古Office，不过面临耗费3年的心血却没有回报，公司资金链断裂。于是尝试站点卖货，前三天颗粒无收，不过在第四天学习观察，然后第七天成为销冠。在销售的过程中，发现用户需求开发出《电脑入门》，然后大销。顺着这个思路，开发出金山毒霸、金山词霸等，金山找到活下去的出路。终于明白了盘古Office失败的原因：闭门造车，没有了解到用户的真正需求。面对微软的竞争，不甘成为一个勉强存活公司的总经理，于是申请辞职。最后得到半年的gap Year。</p><h2 id="BBS-Bulletin-Board-System"><a href="#BBS-Bulletin-Board-System" class="headerlink" title="BBS(Bulletin Board System)"></a>BBS(Bulletin Board System)</h2><p>于是开始泡吧喜欢上了重金属音乐，然后又喜欢泡论坛，还成为了版主。最后这段经历帮助构建了小米社区。<code>只要有一定的自制力，娱乐也是很好的学习方式。</code></p><h2 id="第一波互联网浪潮"><a href="#第一波互联网浪潮" class="headerlink" title="第一波互联网浪潮"></a>第一波互联网浪潮</h2><p>1997,1998大量中国企业赶上互联网浪潮，腾讯、网易、新浪如雨后春笋冒出来。尝试收购网易，但是失败了。1999年底对互联网的理解：</p><blockquote><p>互联网就是“工具”，未来所有的公司都会用到，电商最有前途。</p></blockquote><p>于是2000上线了卓越网，不过互联网泡沫破灭。不过心怀期望，测试网页的每一个链接和banner，开辟物流和存储的先河。</p><blockquote><p>软件工程没有银子弹，凡是可能出错的地方就一定会出错。</p></blockquote><p>在2004年无钱维持，卖给了亚马逊。不过之后，电商复苏。对卓越网的总结:<code>创立于互联网泡沫破裂之后，倒下于电商全面崛起之前。</code>因为错过了互联网时代，而痛苦。失败总结：<code>创业不仅需要勤奋和天赋，还需要把握风口。</code></p><h2 id="移动互联网"><a href="#移动互联网" class="headerlink" title="移动互联网"></a>移动互联网</h2><p>之后把握主下一个浪潮，坚信移动互联网是今后10年的未来。那时候手机还只是功能机，网上很慢。不过还是下定决心用手机上网，坚持了10年。</p><blockquote><p>哪里有用户的痛点，哪里就有创业者的机会。</p></blockquote><p>今天的雷军是挫折和失败的馈赠，世界上的绝大多数都在面临着不可逃避的痛苦、失败、迷茫，所以不妨大胆迎接挑战。你所经历的所有挫折、失败，甚至那些看似毫无意义消磨时间的事情，都将成为你最宝贵的财富。</p><blockquote><p>人生很长，让我们保持信念，永远相信美好的事情即将发生。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/2023/06/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2023/06/14/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>并查集</code>,正如它名字一样，一种负责对集合的合并(Union)与查询(Find)的数据结构。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[u]==u) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">find</span>(father[u]);</span><br><span class="line">father[u]=x;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = <span class="built_in">find</span>(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSame</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = <span class="built_in">find</span>(u);</span><br><span class="line">    v = <span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1-&gt;3-&gt;5;</span></span><br><span class="line"><span class="comment">2-&gt;4-&gt;6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">join</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">join</span>(<span class="number">5</span>,<span class="number">3</span>);</span><br><span class="line">cout&lt;&lt;<span class="built_in">isSame</span>(<span class="number">1</span>,<span class="number">5</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题小技巧</title>
      <link href="/2023/06/14/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2023/06/14/%E5%88%B7%E9%A2%98%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="求整数上各个位的数"><a href="#求整数上各个位的数" class="headerlink" title="求整数上各个位的数"></a>求整数上各个位的数</h2><h3 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">234</span>;</span><br><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;num%<span class="number">10</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">num/=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="number">234</span>;</span><br><span class="line">string str=<span class="built_in">to_string</span>(num);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.<span class="built_in">size</span>(); i++) cout&lt;&lt;str[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP服务器开发</title>
      <link href="/2023/06/12/HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2023/06/12/HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<strong>请求行（request line）</strong>、<strong>请求头部（header）</strong>、<strong>空行</strong>和<strong>请求数据</strong>四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306122328808.png" alt=""></p><p>实例</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1\r\n</span><br><span class="line">Host: 127.0.0.1:10000\r\n</span><br><span class="line">Connection: keep-alive\r\n</span><br><span class="line">Cache-Control: max-age=0\r\n</span><br><span class="line">……</span><br><span class="line">buff=Accept-Language: zh-CN,zh;q=0.9,en-GB;q=0.8,en;q=0.7,en-US;q=0.6\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><h2 id="HTTP-响应头信息"><a href="#HTTP-响应头信息" class="headerlink" title="HTTP 响应头信息"></a>HTTP 响应头信息</h2><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306130001402.png" alt=""></p><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><div class="table-container"><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table></div><h2 id="判断请求的资源是否存在"><a href="#判断请求的资源是否存在" class="headerlink" title="判断请求的资源是否存在"></a>判断请求的资源是否存在</h2><p><strong>stat函数</strong></p><p>作用：获取文件的状态信息，其中<code>st_mode</code>可以用来判断文件类型</p><h2 id="pipe与CGI"><a href="#pipe与CGI" class="headerlink" title="pipe与CGI"></a>pipe与CGI</h2><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> fields[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(fields)</span></span>;</span><br><span class="line">fields[<span class="number">0</span>] 读端</span><br><span class="line">fileds[<span class="number">1</span>] 写端</span><br></pre></td></tr></table></figure><h3 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h3><p><code>int dup2(int file_id1, int file_id2);</code></p><p>复制文件描述符file_id1到file_id2，file_id2如果存在则关闭file_id2</p><p><strong>作用</strong>：使得file_id1和file_id2有共享的文件偏移量和文件状态，pipe和dup2两者配合，可以实现进程的通信。</p><h3 id="GGI"><a href="#GGI" class="headerlink" title="GGI"></a>GGI</h3><p>CGI是Web服务器和一个独立的进程之间的协议，它会把HTTP请求<code>Request</code>的<code>Header</code>头设置成进程的环境变量，HTTP请求的<code>Body</code>正文设置成进程的标准输入，进程的标准输出设置为HTTP响应<code>Response</code>，包含<code>Header</code>头和<code>Body</code>正文。</p><p><strong>工作概要</strong>：对于一个CGI程序，主要的工作是从环境变量和标准输入中读取数据，然后处理数据，最后向标准输出中输出数据。</p><h2 id="execl"><a href="#execl" class="headerlink" title="execl"></a>execl</h2><p>作用：原先fork()创建出来的进程是与原先的父进程共享代码段，使用execl后，可以将子进程替换成一个指定的程序。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...)</span><br></pre></td></tr></table></figure><p>第一参数path字符指针所指向要执行的文件路径， 接下来的参数代表执行该文件时传递的参数列表：argv[0],argv[1]… 最后一个参数须用空指针NULL作结束。</p><p>通常第一个参数为程序名</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>毒鸡汤</title>
      <link href="/2023/06/09/%E6%AF%92%E9%B8%A1%E6%B1%A4/"/>
      <url>/2023/06/09/%E6%AF%92%E9%B8%A1%E6%B1%A4/</url>
      
        <content type="html"><![CDATA[<p>多少岁不重要，<br>看起来像几岁才重要。<br>不要把辛苦和怨气都挂在脸上，<br>你想要最好的生活，<br>就先让生活，看到最好的你。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简历如何写(开发)</title>
      <link href="/2023/06/06/%E7%AE%80%E5%8E%86%E5%A6%82%E4%BD%95%E5%86%99/"/>
      <url>/2023/06/06/%E7%AE%80%E5%8E%86%E5%A6%82%E4%BD%95%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="投简历技巧"><a href="#投简历技巧" class="headerlink" title="投简历技巧"></a>投简历技巧</h2><ul><li><p>最好的是一岗位，一简历(没有什么东西，既省时又好用的)</p></li><li><p>简历要体现对方的需求，而不是我会啥</p></li><li><p>杜绝“我不会啊”的思想。(不敢写，脸皮薄，怕挫折，丢面子，怕丢人)，很多技术是可以短期突击的。</p></li><li><p>面试只有收获，没有损失。</p></li><li><p>简历是敲门砖，任何人都要包装的</p></li><li><p>简历的包装盒修改只是一个技巧，技术才是王道</p></li><li><p>任何公司都不愿意培养人，尽量不要表现出你的技术短板，更不要说是来公司学习的。来公司是分享我的技术，是来为公司添砖加瓦的。</p></li></ul><h2 id="个人简历"><a href="#个人简历" class="headerlink" title="个人简历"></a>个人简历</h2><h3 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h3><p>姓名、性别、年龄、邮箱、联系方式、学校学历、籍贯</p><h3 id="求职意向"><a href="#求职意向" class="headerlink" title="求职意向"></a>求职意向</h3><p>职位、渴望薪水(写准确值或者面议，不要写范围)</p><h3 id="技能描述-技术服务于项目，项目加持于技术"><a href="#技能描述-技术服务于项目，项目加持于技术" class="headerlink" title="技能描述(技术服务于项目，项目加持于技术)"></a>技能描述(技术服务于项目，项目加持于技术)</h3><ol><li><p>精通、熟悉Java，多年一线开发经验，具备良好的编程能力，并熟练使用<strong>设计模式</strong>。(简历上就写精通，不管你写熟悉或者精通，面试官不会因为你写熟悉就简单问你，该问的都得问。整个技术栈内，至少有3个精通。)</p></li><li><p>精通Java并发编程，对Java的锁机制，线程池机制，AQS等都有深入理解，<strong>并在项目中熟练使用。</strong></p></li><li><p>精通jvm，对垃圾回收算法和垃圾回收有深入理解，并参与过线上项目的<strong>jvm调优工作</strong>。</p></li><li><p>精通spring、springmvc，mybatis，springboot等核心框架，可以根据需求快速搭建项目，并阅读过核心源码。</p></li><li><p>精通springcloud、dubbo等微服务框架，对其核心部件(nacos,sentinel)都有深入理解，并参与过线上项目的服务划分、服务治理、服务分层。</p></li><li><p>精通mysql数据库，对索引、事务、锁、存储引擎等都有深入理解，并通过线上项目的sql调优。</p></li><li><p>精通redis，了解底层磁盘和io模型，数据持久化机制，哨兵机制，对redis单机和分布式集群都有实际的经验。</p></li><li><p>精通zookeeper，对zookeeper的底层实现机制有深入理解，了解paxos，zab算法，对CAP有深入理解</p></li><li><p>精通各种分布式解决方案，分布式锁、分布式事务、分布式id，分布式幂等、风不是链路追踪、预警监控</p></li><li><p>精通头kafka，对底层刷盘机制，集群分片机制都有深入理解，并对消息重复消费又对应的线上解决方案。</p></li><li><p>熟悉各种数据结构，对线性表、树、图都有深入理解。并在leetcode有600题的储备</p></li><li><p>熟悉必备的计算机基础知识：操作系统，计算机组成原理、网络、io</p></li><li><p>es</p></li><li><p>mongodb</p></li><li><p>docker，k8s</p></li><li><p>NGINX，lua</p></li><li><p>websocket，netty</p></li><li><p>hive，hbase，spark，flink</p></li></ol><h2 id="项目经历-项目价值，个人价值"><a href="#项目经历-项目价值，个人价值" class="headerlink" title="项目经历(项目价值，个人价值)"></a>项目经历(项目价值，个人价值)</h2><p>项目名称：XXXX平台</p><p><strong>项目描述</strong>：三四行描述即可，不要堆积大量的文字，要凸显项目的重点和核心价值。（项目有哪些展示的数据量，项目解决了什么问题，提供了什么行业的解决方案），可以适当添加核心模块和核心功能，但是不要把所有的模块都罗列出来</p><p><strong>技术架构</strong>：把项目中所有设计导的技术栈做罗列和展示即可，不需要解释。</p><p><strong>项目职责</strong>：一定要分条展示，<strong>建议7-8条左右</strong>，写具体点的时候要虚(需求分析、数据库设计、代码review，进度监控)实(具体的业务点，利用什么技术实现什么功能，遇到什么问题，如何解决)结合。</p><p><strong>项目难点：</strong> 一般的项目是没有什么难点的，不建议写到简历上，因为你认为的难点可能在面试官看起来很简单。编造难点(调优，重构，架构设计)，实际业务开发中没做过，心里虚，面试官不可能对你项目实现的细节很清楚，所以只要能自圆其说就好，就算第一个不能，那么面试完之后做好录音复盘，想清楚自己说法有什么漏洞，然后去补充。</p><h2 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h2><p>公司名称、时间、职位</p><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><p>学校、专业、时间</p><h2 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h2><p>自我评价不建议分条展示，写成一个段落即可，展示的是你的行业背景和技术经验，可以从业务背景、技术深度、解决方案等多个维度进行描述，比如做过什么行业的项目，提出过什么技术解决方案，项目的数据量多大，做过哪些架构设计，有哪些技术的设备和几点。</p><p>(应届生) 展示的是你的学习能力和技术储备能力</p><p>对技术有热情，深入研究过XXXX、XXXX技术，对XXX技术有深入理解，leetcode有多少储备，了解过哪些开源的项目，获得过什么成长，看过哪些核心的技术梳理，做过哪些博客的积累，github上fork过多少项目。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL索引</title>
      <link href="/2023/06/06/MySQL%E7%B4%A2%E5%BC%95/"/>
      <url>/2023/06/06/MySQL%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h2><p>索引(index)是帮助MySQL高效获取数据的数据结构(有序)。</p><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230606112718.png" alt=""></p><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230606113456.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230606113602.png" alt=""></p><h3 id="Btree-多路平衡树"><a href="#Btree-多路平衡树" class="headerlink" title="Btree(多路平衡树)"></a>Btree(多路平衡树)</h3><p><code>二叉树</code>：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢。</p><p><code>红黑树</code>：大数据量情况下，层级较深，检索速度慢。</p><p><code>B树</code>: m叉树</p><ul><li><p>树中每个结点中至多有m个孩子结点(至多有m-1个关键字)</p></li><li><p>2=&lt;根节点孩子树&lt;=m</p></li><li><p>ceil(m/2)=&lt;非叶子结点孩子树&lt;=m</p></li><li><p>所有叶子结点在同一层上</p></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>与B树的区别</p><ul><li><p>所有数据都在叶子结点</p></li><li><p>叶子结点形成一个单向链表</p></li></ul><p>MySQL中B+树进行了优化，叶子结点由双链表串联。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>特点：</p><ul><li><p>只能用于对等比较，不支持范围查询</p></li><li><p>无法利用索引完成排序操作</p></li><li><p>查询效率高，通常只需要一次检索就可以了，效率通常比B+树索引</p></li></ul><p>为什么InnoDB存储引擎选择使用B+索引结构</p><ul><li><p>相对于二叉树，层级更少，搜索效率高；</p></li><li><p>对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储  的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</p></li><li><p>相对Hash索引，B+tree支持范围匹配及排序操作</p></li></ul><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230606140919.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230606175621.png" alt=""></p><p>聚集索引选取规则：</p><ul><li><p>如果存在主键，主键索引就是聚集索引。</p></li><li><p>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</p></li><li><p>如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p></li></ul><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><p>创建索引：</p><p><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ) ;</code></p><p>查看索引：</p><p><code>SHOW INDEX FROM table_name;</code></p><p>删除索引:</p><p><code>DROP INDEX index_name ON table_name;</code></p><p>案例分析</p><p><strong>1.name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。(常规索引)</strong></p><p>create index idx_user_name on tb_user(name);</p><p><strong>2.为phone字段创建唯一索引</strong></p><p>create unique index idx_user_phone on tb_uer(phone);</p><p><strong>3.为profession、age、status创建联合索引</strong></p><p>create index_user_pro_age_sta on tb_user(profession,age,status)</p><h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><h3 id="SQL执行频率"><a href="#SQL执行频率" class="headerlink" title="SQL执行频率"></a>SQL执行频率</h3><p><code>SHOW GLOBAL STATUS LIKE ‘Com%’</code>,可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>慢查询日志默认没有开启，查询变量状态</p><p><code>show variables like &#39;slow_query_log&#39;;</code></p><p>开启慢查询：set global slow_query_log=”ON”</p><p>设置慢查询参数：set long_query_time=2;</p><p>开启后会生成一个日志文件：show variables like ’slow_%’</p><h3 id="profile详情分析"><a href="#profile详情分析" class="headerlink" title="profile详情分析"></a>profile详情分析</h3><p>show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p><ol><li><p>通过have_profiling  参数，能够看到当前MySQL是否支持profile操作： show <code>variables like &#39;have_profiling&#39;;</code></p></li><li><p>打开profiling，<code>set profiling =1;</code></p></li><li><p>查看打开状态，<code>show variables like &#39;profiling&#39;;</code></p></li><li><p>查看各个命令的时间 <code>show profiles</code>;</p></li><li><p>查看某个命令的各个阶段的时间：<code>show profile for query (query_id);</code></p></li><li><p>查看指定query_id的SQL语句CPU使用情况 <code>show profile cpu for query (id)</code></p></li></ol><h3 id="explain执行计划"><a href="#explain执行计划" class="headerlink" title="explain执行计划"></a>explain执行计划</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试分类</title>
      <link href="/2023/06/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/"/>
      <url>/2023/06/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试</title>
      <link href="/2023/06/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/06/05/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="测试定义"><a href="#测试定义" class="headerlink" title="测试定义"></a>测试定义</h2><ul><li><p>使用人工或者自动的手段来运行或者测试某个系统的过程</p></li><li><p>目的在于检验它是否满足规定的需求(弄清<code>预期结果</code>和<code>实际结果</code>的差别)</p></li></ul><h2 id="测试目的"><a href="#测试目的" class="headerlink" title="测试目的"></a>测试目的</h2><p>以最小的人力、物力和时间找出软件中潜在的错误和缺陷。</p><h2 id="测试的原则"><a href="#测试的原则" class="headerlink" title="测试的原则"></a>测试的原则</h2><ul><li><p>证明软件中存在缺陷</p></li><li><p>不能穷尽测试</p></li><li><p>测试应该尽早介入</p></li><li><p>28原则(80%的用户只用到了20%的功能，80%的错误出现在20%的地方)</p></li><li><p>不存在缺陷谬论(程序一定有缺陷)</p></li><li><p>妥善保存一切文档</p></li></ul><h2 id="测试标准"><a href="#测试标准" class="headerlink" title="测试标准"></a>测试标准</h2><p>国际标准25010、国内标准GBT18905</p><h2 id="测试的基本要求"><a href="#测试的基本要求" class="headerlink" title="测试的基本要求"></a>测试的基本要求</h2><ul><li><p>外观界面测试</p></li><li><p>易用测试</p></li><li><p>兼容性测试</p></li><li><p>安全性测试</p></li><li><p>性能测试</p></li><li><p>功能测试</p></li></ul><h2 id="测试的工作流程"><a href="#测试的工作流程" class="headerlink" title="测试的工作流程"></a>测试的工作流程</h2><ol><li><p>需求分析(阅读需求文档，分析需求的点，参与需求评审)</p></li><li><p>测试计划和测试方案(宏观计划和实际方案)</p></li><li><p>测试用例设计</p></li><li><p>测试用例执行</p></li><li><p>评估阶段 测试报告</p></li></ol><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306081512418.jpeg" alt=""></p><p>优点：</p><ul><li><p>为项目提供了按阶段划分的检查点</p></li><li><p>可在迭代模型中应用瀑布模型</p></li><li><p>当前阶段完成后，只需要关注后序阶段</p></li></ul><p>缺点：</p><ul><li><p>不适合需求变动多的项目</p></li><li><p>成品消耗较多时间</p></li><li><p>灵活性较差</p></li></ul><p>适合项目类型：学生管理模型、银行系统</p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><p>定义：把瀑布模型的顺序特征和快速原型法的迭代特征相结合，将软件看做一系列相互联系的增量，在开发过程的各次迭代中，每次完成其中的一个增量。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306081513770.png" alt=""></p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>特点：快速建立起来的可以运行在计算机上运行的程序。</p><ul><li><p>克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险。适合预先不能明确定义需求的软件系统的开发</p></li><li><p>所选用的开发技术和工具不一定符合主流的发。快速建立起来的系统结构加上连续的修改可能会导致产品质量低下。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306081514560.jpeg" alt=""></p><h3 id="其他模型"><a href="#其他模型" class="headerlink" title="其他模型"></a>其他模型</h3><p> 螺旋开发模型、迭代开发模型、敏捷开发模型</p><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><h3 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h3><p>编码-单元测试，详细设计-集成测试，概要设计-系统测试，需求分析-验收测试</p><p>缺点：测试的阶段晚，在编码阶段才开始测试。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306081512631.png" alt=""></p><h3 id="W模型"><a href="#W模型" class="headerlink" title="W模型"></a>W模型</h3><p>优点：软件测试伴随软件的整个生命周期，在需求分析结束后就可以进行需求分析测试，测试和开发并行独立进行</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/202306081514234.png" alt=""></p><h2 id="测试和开发的关系"><a href="#测试和开发的关系" class="headerlink" title="测试和开发的关系"></a>测试和开发的关系</h2><ul><li><p>目标相同：制造高质量软件</p></li><li><p>相辅相成：开发经验对测试有用，测试经验对开发有用</p></li><li><p>侧重点不同：开发侧重于从无到有，测试偏重于从有到优</p></li></ul><h2 id="软件测试分类"><a href="#软件测试分类" class="headerlink" title="软件测试分类"></a>软件测试分类</h2><details class="folding-tag" blue><summary> 思维导图模式 </summary>              <div class='content'>                            </div>            </details><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p><code>定义</code>：测试用例又叫做test case，是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果以便测试某个程序路径或核实是否满足某个特定需求。</p><p><code>测试用例的特性：</code></p><ul><li><p>有效性(测试用例能够被使用，且被不同人员使用测试结果一致)</p></li><li><p>可复用性(良好的测试用例具有重复使用的功能，如回归测试)</p></li><li><p>易组织性(好的测试用例会分门别类地提供给测试人员参考和使用)</p></li><li><p>可评估性(从测试管理的角度，测试用例的通过率和软件缺陷的书目是软件产品好坏的测试标准)</p></li><li><p>可管理性(从测试管理的角度，测试用例的通过率和软件缺陷的书目是软件产品好坏的测试标准)</p></li></ul><h2 id="测试用例的要素"><a href="#测试用例的要素" class="headerlink" title="测试用例的要素"></a>测试用例的要素</h2><ol><li><p>测试用例编号(唯一性，容易识别)</p></li><li><p>测试项目/模块</p></li><li><p>前提条件</p></li><li><p>测试输入</p></li><li><p>预期输出(从需求文档得到)</p></li><li><p>操作步骤(描述详细)</p></li><li><p>测试用例标题</p></li><li><p>级别</p></li></ol><p><code>其他要素</code>:</p><ul><li><p>用例的设计者</p></li><li><p>用例设计日期(方便检查用例的设计进度)</p></li><li><p>对应开发人员</p></li><li><p>测试结果(pass,fail,block)</p></li><li><p>测试类型(功能，性能，压力)</p></li></ul><div class="table-container"><table><thead><tr><th>测试用例编号</th><th>测试项目/模块</th><th>前提条件</th><th>测试输入</th><th>预期输出</th><th>操作步骤</th><th>测试用例标题</th><th>级别</th></tr></thead><tbody><tr><td>ST-子项名-01</td><td>手机登录</td><td>手机正常使用</td><td>手机号</td><td>正常登录</td><td>输入手机号并确认</td><td>测试手机能否登录成功</td><td>重要</td></tr></tbody></table></div><h2 id="测试用例的设计原则"><a href="#测试用例的设计原则" class="headerlink" title="测试用例的设计原则"></a>测试用例的设计原则</h2><ul><li><p>明确性(测试结果唯一)</p></li><li><p>代表性(相似的用例要合并)</p></li><li><p>简洁性(语句简洁)</p></li></ul><h2 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h2><p><code>定义</code>：将不能穷举的测试过程进行合理分类，从而保证设计出来的测试用例具有完整性和代表性</p><p><code>类型划分</code>：</p><ul><li><p>有效等价类</p></li><li><p>无效等价类</p></li></ul><p>设计测试用例步骤</p><ol><li><p>确认需求</p></li><li><p>确认有效等价类和无效等价类</p></li><li><p>对每条等价类设计测试用例</p></li></ol><h3 id="案例-qq登录"><a href="#案例-qq登录" class="headerlink" title="案例(qq登录)"></a>案例(qq登录)</h3><p>QQ号：6-10位且不以0开头</p><p><code>有效等价类</code>：6位数字，7位数字，8位数字，9位数字，10位数字</p><p><code>无效等价类</code>：6位数字，7位数字，8位数字，9位数字，10位数字（以0开头）</p><p>小数、字母、特殊字符、汉字、组合</p><div class="table-container"><table><thead><tr><th>测试用例编号</th><th>测试项目/模块</th><th>前提条件</th><th>测试输入</th><th>预期输出</th><th>操作步骤</th><th>测试用例标题</th><th>级别</th></tr></thead><tbody><tr><td>qq-login-001</td><td>有效测试qq登录</td><td>网络正常</td><td>100001</td><td>qq号正确</td><td>1.把数据填写到qq号码栏 2.点击登录</td><td>有效测试qq登录</td><td>重要/通过</td></tr><tr><td>qq-login-002</td><td>无效测试qq登录</td><td>网络正常</td><td>abcdef</td><td>qq号错粗</td><td>1.把数据填写到qq号码栏 2.点击登录</td><td>无效测试qq登录</td><td>重要/通过</td></tr></tbody></table></div><h2 id="边界值法"><a href="#边界值法" class="headerlink" title="边界值法"></a>边界值法</h2><p>定义：作为等价类划分法的补充，其测试用例来源于等价类的边界。</p><p>边界点(上点)：输入范围的边界点</p><p>离点：离边界点最近的点</p><p>内点：输入范围内的任意一个点</p><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ol><li><p>考虑输入条件的相互制约及组合关系</p></li><li><p>考虑输出条件对输入条件的依赖关系</p></li></ol><h3 id="因果图中的符号："><a href="#因果图中的符号：" class="headerlink" title="因果图中的符号："></a>因果图中的符号：</h3><p> ~(非)，v(或)，^(与)</p><p>因果图的约束条件：</p><ul><li><p>E(互斥)-最多一个可能实现</p></li><li><p>I(包含)-至少一个实现</p></li><li><p>M(屏蔽)-条件成立，结果不成立；条件不成立，结果不一定不成立。</p></li><li><p>O(唯一)-有且只要一个成立</p></li><li><p>R(要求)-一个出现另外一个一定出现</p></li></ul><h3 id="因果图法的基本步骤"><a href="#因果图法的基本步骤" class="headerlink" title="因果图法的基本步骤"></a>因果图法的基本步骤</h3><ol><li><p>找出所有的原因，即输入条件或输入条件的等价类</p></li><li><p>找出所有的结果，即输出条件</p></li><li><p>明确输入条件之间的制约关系以及组合关系(哪些可以组合，哪些不可以组合)</p></li><li><p>明确所有输出条件之间的制约关系以及组合关系(哪些可以同时输出，哪些不可以同时输出)</p></li><li><p>找出什么样的组合条件会产生哪种输出结果</p></li><li><p>把因果转换成判定表/决策表</p></li><li><p>为判定表/决策表的每一列表示的情况设计测试用例</p></li></ol><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>交通一卡通自动充值软件</p><p>条件：</p><ol><li><p>输入50元</p></li><li><p>输入100元</p></li><li><p>选择充值50元</p></li><li><p>选择充值100元</p></li></ol><p>{1,3}, {1,4}, {2,3}, {2,4}可以组合；1,2,3,4可以单独出现</p><p>结果:</p><ol><li><p>完成充值，退卡</p></li><li><p>提示充值成功</p></li><li><p>找零</p></li><li><p>提示错误</p></li></ol><p>{1,2}必须组合在一起; {1,2,3}可以组合在一起;  {3,4}可以组合，4可以单独出现</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230622205255.png" alt=""></p><h2 id="判定表法"><a href="#判定表法" class="headerlink" title="判定表法"></a>判定表法</h2><p>判定表就是因果图的最终产品</p><h2 id="正交表法"><a href="#正交表法" class="headerlink" title="正交表法"></a>正交表法</h2><p><code>软件</code>：allpairs</p><p>作用：用比较少的案例代表比较多的案例</p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>定义：通过一系列操作步骤，达成某一个结果，到终点的过程测试</p><p>一般用于冒烟测试</p><h2 id="流程分析法"><a href="#流程分析法" class="headerlink" title="流程分析法"></a>流程分析法</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/2023/06/04/Docker%E5%85%A5%E9%97%A8/"/>
      <url>/2023/06/04/Docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Docker是一个用于构建(build)、运行(run)、传送(share)应用程序的平台。有了Docker就可以将应用程序和它运行时所需要的各种依赖包、第三方软件库、配置文件等打包在一起，以便在任何环境都可以正确运行。</p><h3 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h3><p>未使用Docker时，浪费大量的时间在配置环境上</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230604232816.png" alt=""></p><p>使用Docker后，可以将配置步骤打包，只要在开发环境中运行成功，测试环境也是可以成功运行的。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230604232957.png" alt=""></p><h3 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h3><p><strong>虚拟机</strong></p><p>虚拟机的实现是基于虚拟化技术，它是一种将物理资源虚拟成多个逻辑资源的技术。它可以将一台物理服务器虚拟成多个虚拟化服务器。每个逻辑服务器都可以有自己的操作系统、CPU、内存、硬盘和网络接口等等，可以独立运行。不过缺点明显，若我们只需要Web服务器，但是虚拟机却需要启动一个完整的系统，包括系统的内核、各种工具甚至图形界面等等，这会导致资源浪费和启动速度慢的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230604233935.png" alt=""></p><p><strong>Docker</strong></p><p>Docker和容器是两种不同的概念，其实Docker只是容器的一种实现，是一种容器化的解决方案和平台，而容器是一种虚拟化技术和虚拟机类似，也是一种独立的环境，可以在这个环境运行应用程序。<code>和虚拟机不同的是它并不需要再容器中运行一个完整的操作系统，而是使用宿主的操作系统所以启动速度非常快。同时因为需要的资源更少，所以可以在一台服务器上运行更多的容器。</code>比如说一台服务器上只能运行几个虚拟机，不过却可以运行上百个容器，这就是最主要的区别。</p><p><img src="https://cdn.jsdelivr.net/gh/FelixShenBlog/Picture/img/20230604234458.png" alt=""></p><h3 id="基本原理和概念"><a href="#基本原理和概念" class="headerlink" title="基本原理和概念"></a>基本原理和概念</h3><ul><li><p>镜像是一个只读的模板，它可以用来创建容器</p></li><li><p>容器是Docker的运行实例，它提供了一个独立的可移植的环境，可以在这个运行环境中运行应用程序。</p></li><li><p>仓库是用来存镜像的地方，最流行和最常用的仓库就是Dockerhub。通过仓库实现镜像的共享和复用。</p></li></ul><p>镜像和容器的关系就像类和对象的关系，一个镜像可以对应多个容器。</p><p><a href="https://www.bilibili.com/video/BV14s4y1i7Vf?p=1&amp;vd_source=ca7eb02d19375229743d6c538623b3af">视频链接</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP</title>
      <link href="/2023/06/02/KMP/"/>
      <url>/2023/06/02/KMP/</url>
      
        <content type="html"><![CDATA[<h2 id="next数组求解"><a href="#next数组求解" class="headerlink" title="next数组求解"></a>next数组求解</h2><p>next数组也就是最长前后缀表</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL常用算法</title>
      <link href="/2023/05/30/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/30/STL%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="删除队列的某个元素"><a href="#删除队列的某个元素" class="headerlink" title="删除队列的某个元素"></a>删除队列的某个元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//删除字符串全部逗号</span></span><br><span class="line">    string s=<span class="string">&quot;1,3,4,5&quot;</span>;</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="built_in">remove</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">&#x27;,&#x27;</span>),s.<span class="built_in">end</span>());</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//删除vector中的某个元素</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    v.<span class="built_in">erase</span>(<span class="built_in">remove</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">3</span>),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++) cout&lt;&lt;v[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除字符串的前导0"><a href="#删除字符串的前导0" class="headerlink" title="删除字符串的前导0"></a>删除字符串的前导0</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s=<span class="string">&quot;0000123&quot;</span>;</span><br><span class="line"><span class="comment">//    s.erase(0,s.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重复填充数据"><a href="#重复填充数据" class="headerlink" title="重复填充数据"></a>重复填充数据</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//全部元素重新填充</span></span><br><span class="line">    <span class="built_in">fill</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : v) cout&lt;&lt;item&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lower-bound和upper-bound"><a href="#lower-bound和upper-bound" class="headerlink" title="lower_bound和upper_bound"></a>lower_bound和upper_bound</h2><p>lower_bound:找到第一个大于等于target的迭代器，<code>注意判断迭代器是否为end</code></p><p>upper_bound:找到第一个大于target的迭代器，<code>注意判断迭代器是否为end</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it_left=<span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> it_right=<span class="built_in">upper_bound</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(it_left!=nums.<span class="built_in">end</span>()) cout&lt;&lt;*it_left&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(it_right!=nums.<span class="built_in">end</span>()) cout&lt;&lt;*it_right&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL双端队列</title>
      <link href="/2023/05/30/STL%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
      <url>/2023/05/30/STL%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//访问首尾元素</span></span><br><span class="line">    cout&lt;&lt;d.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d.<span class="built_in">back</span>()&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;*d.<span class="built_in">begin</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*(d.<span class="built_in">end</span>()<span class="number">-1</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;d[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d[<span class="number">3</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//添加头部元素</span></span><br><span class="line">    d.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//添加尾部元素</span></span><br><span class="line">    d.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//删除头部元素</span></span><br><span class="line">    d.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">//删除尾部元素</span></span><br><span class="line">    d.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//使用emplace_front和emplace_back更加节省时间</span></span><br><span class="line">    d.<span class="built_in">emplace_front</span>(<span class="number">0</span>);</span><br><span class="line">    d.<span class="built_in">emplace_back</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x: d) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>epoll</title>
      <link href="/2023/05/30/epoll/"/>
      <url>/2023/05/30/epoll/</url>
      
        <content type="html"><![CDATA[<h2 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h2><p><code>epoll_create</code></p><p><code>epoll_wait</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2023/05/29/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2023/05/29/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<p>举个简单的例子理解一下吧，比如pow(5,13)，正常算的话需要执行乘法15次吧。可是如果采用快速幂，只要进行只要四次运算就ok了。13的二进制为1101，每一位分别代表8,4,2,1。</p><script type="math/tex; mode=display">5^{13}=5^1*5^0*5^4*5^8</script><p>原理很简单，x每轮都自乘，若遇到当前二进制为1的话，就乘与x。有点词穷了，附上代码赋值理解吧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//位运算</span></span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> b=n;</span><br><span class="line">        <span class="type">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果n小于0，等与pow(1/x,-n)</span></span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            b=-b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((b&amp;<span class="number">1</span>)==<span class="number">1</span>) res*=x;</span><br><span class="line">            x*=x;</span><br><span class="line">            b=b&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一切才刚刚开始</title>
      <link href="/2023/05/28/%E4%B8%80%E5%88%87%E6%89%8D%E5%88%9A%E5%88%9A%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/05/28/%E4%B8%80%E5%88%87%E6%89%8D%E5%88%9A%E5%88%9A%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>记录一下今天，今天早上投了20多份简历，不过几乎都石沉大海了。心中难免浮出一片悲凉，感觉前路漫漫。于是和一位网友诉苦，她的一句话也确实点醒了我。她说，现在虽然没有稳定工作但是你最起码可以享受找工作的过程 可以有目标 ，如果你现在就稳定工作 可能你还是去了很多更好的机会 失去了过程中的快乐。听到这话我也有了一丝的宽慰，又想起来我那个倒霉蛋哥们，一年了也没收到几个offer。而我呢，还没找多久呢，怎么可以轻言失败呢。一切才刚刚开始呢。以下就是我网上找的鸡汤文。</p><p>当你以为一切都将要结束的时候，其实一切才刚刚开始。其实人生很多时候都不是如意的，很多时候都觉得现在特别难。不过仔细回想一下，当初你觉得很难，觉得不可能度过的那段时间，是不是也刷的一下过去了。现在回想起来甚至想不起来，当初为什么觉得那么难了。也许很多时候不能把时间放在无意义的内耗上，不妨走出去，呼吸一下新鲜空气，或许就有不同的感受了。</p><p>最后啊，再来晚毒鸡汤。当你觉得一切才刚刚开始的时候，挑战已经结束了。哈哈哈！</p>]]></content>
      
      
      <categories>
          
          <category> 个人感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位dp</title>
      <link href="/2023/05/28/%E6%95%B0%E4%BD%8Ddp/"/>
      <url>/2023/05/28/%E6%95%B0%E4%BD%8Ddp/</url>
      
        <content type="html"><![CDATA[<h2 id="数位dp枚举0-n"><a href="#数位dp枚举0-n" class="headerlink" title="数位dp枚举0~n"></a>数位dp枚举0~n</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> limit, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++) cout&lt;&lt;b[i];</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> up=limit?a[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)&#123;</span><br><span class="line">        b[p]=i;</span><br><span class="line">        <span class="built_in">dfs</span>(p+<span class="number">1</span>,limit&amp;&amp;i==up,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        a[p++]=num%<span class="number">10</span>;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">begin</span>()+p);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">handle</span>(<span class="number">120</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带3的数"><a href="#带3的数" class="headerlink" title="带3的数"></a>带3的数</h2><p>思路：先求不带3的数，再减去</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> limit, <span class="type">int</span> length, vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> up=limit?a[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;f[p]!=<span class="number">0</span>) <span class="keyword">return</span> f[p];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">3</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(p+<span class="number">1</span>,limit&amp;&amp;i==up,length,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)</span><br><span class="line">    f[p]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="type">int</span> x=num;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: a) cout&lt;&lt;x;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span>-<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,a.<span class="built_in">size</span>(),a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">handle</span>(<span class="number">200</span>)-<span class="built_in">handle</span>(<span class="number">100</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带49的数"><a href="#带49的数" class="headerlink" title="带49的数"></a>带49的数</h2><p>思路：先求不带49的数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">22</span>][<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pre, <span class="type">bool</span> limit,vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit&amp;&amp;f[p][pre]) <span class="keyword">return</span> f[p][pre];</span><br><span class="line">    <span class="type">int</span> up=limit?v[p]:<span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">4</span>&amp;&amp;i==<span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(p+<span class="number">1</span>,i,limit&amp;&amp;i==up,v,length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) f[p][pre]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">handle</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> x=num;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a.<span class="built_in">push_back</span>(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> num+<span class="number">1</span>-<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,a,a.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">handle</span>(<span class="number">500</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">题目链接</a></p><p>题意概括：找下一个比当前元素大的数</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><p>栈存的是下标</p></li><li><p>如果每次存的都是比栈顶小的元素，找的就是比当前元素大的数</p></li><li><p>如果每次存的都是比栈顶大的元素，找的就是比当前元素小的数</p></li><li><p>单调栈记录的是遍历过的元素，栈顶和当前元素对比，再进行求值的过程</p></li></ul><h3 id="详细版代码"><a href="#详细版代码" class="headerlink" title="详细版代码"></a>详细版代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span></span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(temperatures.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;temperatures.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i]&lt;temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temperatures[i]==temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//将栈内比当前元素小的元素全部弹出之后再push当前元素</span></span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;temperatures[i]&gt;temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()]=i-st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="精简版代码"><a href="#精简版代码" class="headerlink" title="精简版代码"></a>精简版代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 递增栈</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(T.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; T[i] &gt; T[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意栈不能为空</span></span><br><span class="line">                result[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><a href="https://leetcode.cn/problems/next-greater-element-i/">题目链接</a></p><p>题意概括：相同的元素在另外一个数组找下一个更大元素</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先找nums2的下一个最大元素，存入result2数组。问题转化为为nums1中的每个下标找对应的result2元素。即是<code>nums1下标-&gt;result2元素</code>，解决方案为建立<code>nums2的元素-&gt;nums2的下标</code>，再通过<code>result2[m[nums1[i]]</code>访问result2的元素。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result2</span><span class="params">(nums2.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()&amp;&amp;nums2[i]&gt;nums2[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                result2[st.<span class="built_in">top</span>()]=nums2[i];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//映射麻烦,nums1下标-&gt;result2的结果</span></span><br><span class="line">        <span class="comment">//nums2元素-&gt;nums2下标 == nums2元素-&gt;result2下标 == nums1元素-&gt;result2下标</span></span><br><span class="line">        <span class="comment">//nums1元素-&gt;result2的下标-&gt;result2结果</span></span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums2.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            m[nums2[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result1</span><span class="params">(nums1.size(),<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums1.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            result1[i]=result2[m[nums1[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503.下一个更大元素 II"></a>503.下一个更大元素 II</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">题目链接</a></p><p>题目概述：找下一个更大元素，但是环形</p><h3 id="思路1-开辟新数组"><a href="#思路1-开辟新数组" class="headerlink" title="思路1(开辟新数组)"></a>思路1(开辟新数组)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 拼接一个新的nums</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums1</span><span class="params">(nums.begin(), nums.end())</span></span>;</span><br><span class="line">        nums.<span class="built_in">insert</span>(nums.<span class="built_in">end</span>(), nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 用新的nums大小来初始化result</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始单调栈</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i); </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后再把结果集即result数组resize到原数组大小</span></span><br><span class="line">        result.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-取模"><a href="#思路2-取模" class="headerlink" title="思路2(取模)"></a>思路2(取模)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>() * <span class="number">2</span>; i++) &#123; </span><br><span class="line">            <span class="comment">// 模拟遍历两边nums，注意一下都是用i % nums.size()来操作</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] &lt; nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i % nums.<span class="built_in">size</span>()] == nums[st.<span class="built_in">top</span>()]) st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>()); </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; nums[i % nums.<span class="built_in">size</span>()] &gt; nums[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                    result[st.<span class="built_in">top</span>()] = nums[i % nums.<span class="built_in">size</span>()];</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i % nums.<span class="built_in">size</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h2><p><a href="https://leetcode.cn/problems/next-greater-element-ii/">题目链接</a></p><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>按列取雨水</p><ul><li><p>当前列雨水面积：min(左边柱子的最高高度，右边柱子的最高高度) - 当前柱子高度。</p></li><li><p>从左往右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);</p></li><li><p>从右往左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxLeft</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxRight</span><span class="params">(height.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> size = maxRight.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个柱子左边柱子最大高度</span></span><br><span class="line">        maxLeft[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            maxLeft[i] = <span class="built_in">max</span>(height[i], maxLeft[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录每个柱子右边柱子最大高度</span></span><br><span class="line">        maxRight[size - <span class="number">1</span>] = height[size - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            maxRight[i] = <span class="built_in">max</span>(height[i], maxRight[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="built_in">min</span>(maxLeft[i], maxRight[i]) - height[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) sum += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>按行取雨水</p><p>原理：找左边比当前元素大的数，找右边比当前元素大的数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (height.<span class="built_in">size</span>() &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 可以不加</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 存着下标，计算的时候用下标对应的柱子高度</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[st.<span class="built_in">top</span>()]) &#123;     <span class="comment">// 情况一</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">if</span> (height[i] == height[st.<span class="built_in">top</span>()]) &#123;  <span class="comment">// 情况二</span></span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。</span></span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 情况三</span></span><br><span class="line">                <span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[i] &gt; height[st.<span class="built_in">top</span>()]) &#123; <span class="comment">// 注意这里是while</span></span><br><span class="line">                    <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        <span class="type">int</span> h = <span class="built_in">min</span>(height[st.<span class="built_in">top</span>()], height[i]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>; <span class="comment">// 注意减一，只求中间宽度</span></span><br><span class="line">                        sum += h * w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">题目链接</a></p><p>题目概要：找左边比当前元素小的元素，找右边比当前元素小的元素。</p><h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minLeftIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minRightIndex</span><span class="params">(heights.size())</span></span>;</span><br><span class="line">        <span class="type">int</span> size = heights.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个柱子 左边第一个小于该柱子的下标</span></span><br><span class="line">        minLeftIndex[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// 注意这里初始化，防止下面while死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不是用if，而是不断向左寻找的过程</span></span><br><span class="line">            <span class="keyword">while</span> (t &gt;= <span class="number">0</span> &amp;&amp; heights[t] &gt;= heights[i]) t = minLeftIndex[t];</span><br><span class="line">            minLeftIndex[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录每个柱子 右边第一个小于该柱子的下标</span></span><br><span class="line">        minRightIndex[size - <span class="number">1</span>] = size; <span class="comment">// 注意这里初始化，防止下面while死循环</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> t = i + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里不是用if，而是不断向右寻找的过程</span></span><br><span class="line">            <span class="keyword">while</span> (t &lt; size &amp;&amp; heights[t] &gt;= heights[i]) t = minRightIndex[t];</span><br><span class="line">            minRightIndex[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - <span class="number">1</span>);</span><br><span class="line">            result = <span class="built_in">max</span>(sum, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><p>关键点</p><ul><li><p>首尾加0</p></li><li><p>栈内每次存的都是比栈顶元素大的数</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/05/27/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/05/27/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.哈希冲突</strong></p><ul><li><p>定义：在哈希表中，不同的键经过哈希函数计算后得到相同的哈希值，导致它们应该存储在哈希表的同一个位置上</p></li><li><p>链地址法（Chaining）：使用链表或其他数据结构，在哈希表的每个位置上维护一个链表，将哈希冲突的元素存储在同一个位置的链表中。当需要查找、插入或删除元素时，遍历对应位置的链表即可。这种方法简单且易于实现，但可能会造成额外的存储空间开销和链表的遍历操作。</p></li><li><p>开放地址法（Open Addressing）：当发生哈希冲突时，通过一定的规则在哈希表的其他位置寻找空槽来存储冲突元素。常见的开放地址法有线性探测、二次探测、双重哈希等。这种方法不需要额外的数据结构存储冲突元素，节省了存储空间，但可能导致聚集现象，即连续的冲突元素会聚集在一起，影响性能。</p></li><li><p>建立更好的哈希函数：改进哈希函数的设计，减少哈希冲突的发生。好的哈希函数能够尽可能地将键均匀地分布在哈希表的各个位置上，减少冲突的概率。通常，好的哈希函数应该具有均匀性、雪崩效应（即输入的微小变化会导致输出的巨大变化）等特性。</p></li><li><p>调整哈希表的负载因子：负载因子是指哈希表中已存储元素的数量与哈希表大小的比值。当负载因子过高时，哈希冲突的概率会增加。通过动态调整哈希表的大小，可以控制负载因子在一个合理的范围内，减少哈希冲突的发生。</p></li></ul>              </div>            </details><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.C++内存分布：</strong></p><ul><li><p>栈（stack）：栈是用于存储局部变量和函数调用信息的内存区域。它的分配和释放是由编译器自动完成的，遵循后进先出（LIFO）的原则。每当函数被调用时，函数的局部变量和参数被压入栈中，并在函数返回时被自动弹出。栈的大小通常是有限的，一般在编译时确定，超出栈大小的分配会导致栈溢出。</p></li><li><p>堆（heap）：堆是用于动态分配内存的区域。在堆上分配的内存需要手动进行管理，包括分配和释放。通常使用<code>new</code>操作符来分配内存，使用<code>delete</code>操作符来释放内存。堆上分配的内存在不需要时需要手动释放，否则可能导致内存泄漏。堆的大小一般比栈大，并且在运行时动态增长。</p></li><li><p>静态存储区（static storage area）：静态存储区用于存储全局变量、静态变量和静态常量。它在程序开始执行时被分配，并在程序结束时被释放。静态存储区的大小在编译时确定，存储区域在整个程序的执行期间都存在。</p></li><li><p>常量区（Constant Storage）：常量区用于存储常量数据，如字符串常量。这些数据在程序执行期间是只读的，无法修改。代码区（存储程序的机器指令）</p></li><li><p>程序代码区（Code Area）：程序代码区存储程序的指令代码。这部分内存是只读的，存储着程序的可执行指令。</p></li></ul><p><strong>2.什么是智能指针？为什么在C++中使用智能指针？</strong></p><p>智能指针是C++中的一种包装类，用于管理动态分配的对象的生命周期。它们提供了自动化的内存管理，可以避免内存泄漏和悬挂指针的问题。智能指针通过在对象上使用引用计数或其他技术来跟踪对象的引用，并在引用计数为零时自动释放对象的内存。</p><p><strong>3.C++中有哪些类型的智能指针？请简要描述它们的区别</strong></p><p>C++中有三种常用的智能指针类型：unique_ptr、shared_ptr和weak_ptr。</p><ul><li><p>unique_ptr：独占所有权的智能指针，不能共享所有权。它使用独占式所有权语义，确保只有一个指针可以访问所拥有的对象。</p></li><li><p>shared_ptr：允许多个指针共享同一个对象的智能指针。它使用引用计数来跟踪对象的引用，当引用计数为零时自动释放对象。</p></li><li><p>weak_ptr：用于解决shared_ptr可能引起的循环引用问题。weak_ptr可以观测shared_ptr，但不会增加引用计数，也不能直接访问所指向的对象。</p></li></ul><p><strong>3.如何创建和使用智能指针？</strong></p><p>可以使用<code>std::make_unique</code>、<code>std::make_shared</code>和<code>std::make_weak</code>等函数来创建智能指针。例如，使用<code>std::make_unique</code>创建unique_ptr。</p><p><strong>4.智能指针有什么缺点？</strong></p><p>答案：尽管智能指针提供了方便和安全的内存管理，但也存在一些缺点。其中一个主要的缺点是智能指针可能引起循环引用的问题，导致内存泄漏。为了避免这种情况，应该使用weak_ptr来打破循环引用。此外，智能指针相对于裸指针有一些额外的开销，包括引用计数的维护等。</p><p><a href="https://blog.csdn.net/qq_26538113/article/details/125796865">智能指针循环引用问题</a></p><p><strong>5.C++多态</strong></p><ul><li><p>什么是多态性（Polymorphism）：多态性是面向对象编程中的一个重要特性，它允许使用基类的指针或引用来访问派生类对象，实现代码的灵活性和可扩展性。</p></li><li><p>多态性的实现方式：两种主要的实现方式：静态多态性（静态绑定）和动态多态性（动态绑定）。静态多态性通过函数重载和模板实现，而动态多态性通过虚函数和继承实现。</p></li><li><p>虚函数和纯虚函数：虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，它可以在派生类中被重写，实现动态绑定。纯虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，但没有提供具体的实现，需要在派生类中实现。</p></li><li><p>虚函数表（Virtual Function Table）：虚函数表是一个特殊的数据结构，用于实现动态多态性。每个包含虚函数的类都有自己的虚函数表，该表存储了类的虚函数的地址，使得在运行时能够正确调用派生类的虚函数。</p></li><li><p>虚析构函数：虚析构函数的作用是确保在删除指向派生类对象的基类指针时，能够正确调用派生类的析构函数，防止内存泄漏。</p></li><li><p>多态性的优点和应用场景：多态性提供了代码的灵活性、可扩展性和可维护性。它使得代码可以更容易地适应变化和扩展，同时也提高了代码的可读性和重用性。</p></li><li><p>如何阻止派生类重写虚函数：可以在基类中使用<code>final</code>关键字来修饰虚函数，以阻止派生类对该虚函数进行重写。被标记为<code>final</code>的虚函数在派生类中不能被重写。</p></li></ul><p><strong>6.new/delete和malloc/free的区别</strong></p><ul><li>malloc/free是C/C++的库函数，需要stdlib.h；new/delete是C++的关键字；</li><li>都可用于申请动态内存和释放内存，new/delete在对象创建的时候自动执行构造函数，对象消亡前自动执行析构函数，底层实现其实也是malloc/free</li><li>new无需指定内存块的大小，编译器会根据类型信息自行计算；malloc需要显式地支持所需内存的大小</li><li>new返回<strong>指定类型</strong>的指针，无需进行类型转换；malloc默认返回类型为<strong>void*</strong>，必须强行转换为实际类型的指针</li><li>new内存分配失败时会抛出bad_alloc异常；malloc失败时返回NULL</li></ul><p><strong>7.static的用法</strong></p><ul><li><p>static修饰局部变量：使其变为<strong>静态存储方式</strong>（静态数据区），函数执行完成之后不会被释放，而是继续保存在内存中；</p></li><li><p>static修饰全局变量：使其只在本文件内部有效，其他文件不可链接或引用该变量；</p></li><li><p>static修饰函数：静态函数，即函数只在本文件内部有效，对其他文件不可见；避免同名干扰，同时保护</p></li></ul><p><strong>8.const的用法</strong></p><p>const起到<strong>强制保护</strong>的修饰作用，可以预防意外改动，提高程序的健壮性</p><ul><li><p>const修饰常量：定义时就初始化，以后不能更改；</p></li><li><p>const修饰形参：func(const int a); 该形参在函数里不能改变；</p></li><li><p>const修饰类成员函数：const类成员函数不能改变成员变量的数值</p></li></ul><p><strong>const常量和#define的区别</strong></p><ul><li>const定义的常量有类型名字，存放在内存的静态区域中，在编译时确定其值；</li><li><h1 id="define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；"><a href="#define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；" class="headerlink" title="define定义的常量是没有类型的一个立即数，编译器会在预处理阶段将程序中所有使用到该常量的地方进行拷贝替换；"></a>define定义的常量是没有类型的一个<strong>立即数</strong>，编译器会在预处理阶段将程序中所有使用到该常量的地方进行<strong>拷贝替换</strong>；</h1></li></ul><p><strong>9.全局变量和静态变量区别</strong></p><ul><li>存储方式上并无区别，都是静态存储方式</li><li>非静态全局变量作用域为整个源程序；当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的，而静态全局变量则限制了其作用域，只在定义该变量的源文件内有效</li></ul>              </div>            </details><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.IO复用模型</strong></p><p>IO复用模型是一种用于实现高效的并发I/O操作的技术，它允许一个线程同时监视多个I/O事件，并在有事件发生时进行处理，避免了传统的阻塞式I/O中的线程阻塞和轮询等待。</p><p><strong>2.socket编程的流程</strong></p><ol><li><p>创建Socket：使用<code>socket()</code>系统调用创建一个Socket对象。需要指定网络协议、Socket类型和协议族。</p></li><li><p>绑定Socket：使用<code>bind()</code>系统调用将Socket绑定到一个特定的IP地址和端口号上。这一步是可选的，如果不绑定，操作系统会自动为Socket分配一个可用的端口。</p></li><li><p>监听连接请求（仅适用于服务器）：使用<code>listen()</code>系统调用将Socket设置为监听状态，以等待客户端的连接请求。服务器Socket需要指定可以同时处理的最大连接数。</p></li><li><p>接受连接（仅适用于服务器）：使用<code>accept()</code>系统调用接受客户端的连接请求，返回一个新的Socket对象用于与客户端进行通信。服务器Socket会一直阻塞，直到有客户端连接进来。</p></li><li><p>连接服务器（仅适用于客户端）：使用<code>connect()</code>系统调用连接到服务器的Socket。需要指定服务器的IP地址和端口号。</p></li><li><p>发送和接收数据：使用<code>send()</code>和<code>recv()</code>系统调用进行数据的发送和接收。可以根据具体需求进行数据的分割、组装和处理。</p></li><li><p>关闭连接：使用<code>close()</code>系统调用关闭Socket连接，释放相关资源。</p></li></ol><p><strong>3.TCP</strong></p><ul><li><p>TCP的基本概念：TCP是一种可靠的、面向连接的传输协议，它提供了可靠的数据传输、流量控制、拥塞控制和错误恢复机制等功能。</p></li><li><p>三次握手：包括客户端向服务器发送SYN（同步）请求，服务器回复SYN-ACK（同步-应答）确认，最后客户端发送ACK（应答）确认。</p></li><li><p>四次挥手：客户端或服务器发送FIN（结束）请求，对方回复ACK确认，然后再发送FIN请求，对方再次回复ACK确认</p></li></ul><p><strong>4.大小端</strong></p><ul><li><p>大端字节序（Big Endian）：在大端字节序中，高位字节存储在低地址，低位字节存储在高地址。小端字节序（Little Endian）：在小端字节序中，高位字节存储在高地址，低位字节存储在低地址。网络协议通常使用大端字节序来传输数据。</p></li><li><p>大小端转换</p><ul><li><p>使用联合体（Union）：可以定义一个联合体，其中包含相同的数据，但使用不同的字节序。通过将数据存储在一个字节序中，然后在另一个字节序中读取，可以实现大小端转换。</p></li><li><p>使用库函数：C++ 标准库或其他第三方库中可能提供了字节序转换的函数。例如，可以使用 <code>&lt;arpa/inet.h&gt;</code> 头文件中的 <code>ntohs()</code> 和 <code>htons()</code> 函数进行网络字节序和主机字节序之间的转换。</p></li></ul></li></ul><p><strong>5.select</strong></p><p>是什么：select 是一种基于IO复用的模型，是Unix系统提供的一种系统调用。它允许进程或线程同时监视多个文件描述符，并在其中的任何一个准备就绪时通知调用者。</p><p>使用 select 模型的基本流程如下：</p><ul><li><p>调用 select 函数，传入需要监视的文件描述符集合、超时时间等参数。</p></li><li><p>select 函数开始监视所有文件描述符，直到有一个或多个文件描述符准备就绪。</p></li><li><p>select 函数返回时，可以使用一些辅助函数（如FD_ISSET）来判断哪些文件描述符已经准备就绪。</p></li><li><p>对于准备就绪的文件描述符，进行相应的读取、写入或其他操作。</p></li><li><p>重复以上步骤，实现高效的并发IO处理。</p></li></ul><p>使用 select 模型的优点是：</p><ul><li><p>简单易用：相对于其他IO复用模型（如 epoll 和 kqueue），select 的接口更加简单，易于理解和使用。</p></li><li><p>跨平台性：select 是跨平台的，可以在不同的操作系统上使用。</p></li><li><p>支持多种类型的文件描述符：可以同时监视多种类型的文件描述符，如标准输入输出、套接字等。</p></li></ul><p>select 也存在一些缺点：</p><ul><li><p>扩展性有限：select 模型在处理大量文件描述符时性能较差，因为每次调用 select 都需要线性扫描整个文件描述符集合。</p></li><li><p>数量限制：不同操作系统对 select 函数支持的文件描述符数量有限制，通常是1024或更小。</p></li><li><p>低效的事件通知：当有文件描述符准备就绪时，select 只提供了一个整体的通知，需要使用额外的轮询来确定具体是哪些文件描述符准备就绪</p></li></ul><p><strong>6.poll</strong></p><p>poll 模型的基本原理是通过一个结构体数组来表示待监视的文件描述符集合，称为 pollfd 数组。每个 pollfd 结构体包含了一个文件描述符以及监视的事件类型。</p><p>使用 poll 模型的基本流程如下：</p><ul><li><p>创建一个 pollfd 数组，用于存储需要监视的文件描述符和事件类型。</p></li><li><p>使用 poll 函数，将 pollfd 数组传递给它，同时设置超时时间</p></li><li><p>poll 函数开始监视所有文件描述符，直到有一个或多个文件描述符准备就绪或超时。</p></li><li><p>poll 函数返回时，可以通过遍历 pollfd 数组来找到准备就绪的文件描述符。</p></li><li><p>对于准备就绪的文件描述符，进行相应的读取、写入或其他操作。</p></li><li><p>重复以上步骤，实现高效的并发IO处理</p></li></ul><p>优点：</p><ul><li><p>没有文件描述符数量限制：poll 模型没有对文件描述符数量的限制，可以处理更多的文件描述符。</p></li><li><p>提供更直观的事件通知：当有文件描述符准备就绪时，poll 可以提供具体的事件类型，使得处理更加方便和直观。</p></li></ul><p>缺点：</p><ul><li><p>poll 在内部实现上仍然需要遍历整个 pollfd 数组来确定准备就绪的文件描述符，对于大量的文件描述符会有性能问题。</p></li><li><p>跨平台兼容性：poll 不像 select 那样具有跨平台的特性，因此在不同的操作系统上可能存在差异。</p></li></ul><p><strong>7.epoll</strong></p><p>epoll 模型的基本原理是通过使用内核提供的 epoll 系统调用，将需要监视的文件描述符注册到一个事件表（event table）中。当文件描述符准备就绪时，内核会将事件通知给应用程序。</p><ul><li><p>支持较大数量的并发连接：epoll 模型使用基于事件驱动的方式，可以支持非常大的并发连接数，远远超过传统的 select 和 poll 模型的限制。</p></li><li><p>高效的事件通知机制：epoll 使用了回调机制，只有当事件发生时才进行通知，避免了轮询和线性扫描整个文件描述符集合的性能损耗。</p></li><li><p>高性能的数据结构：epoll 使用了红黑树（Red-Black Tree）和就绪列表（Ready List）等高效的数据结构，可以快速地查找和管理准备就绪的文件描述符。</p></li><li><p>较低的内存占用：epoll 模型使用了事件通知机制，只需维护准备就绪的文件描述符，而不需要维护整个文件描述符集合，因此占用的内存较少。</p></li><li><p>支持多种触发模式：epoll 提供了水平触发（Level-Triggered）和边缘触发（Edge-Triggered）两种模式，可以根据需求选择适合的模式。</p></li></ul><p>使用 epoll 模型的基本流程如下：</p><ul><li><p>创建 epoll 实例（epoll_create 或 epoll_create1 函数）</p></li><li><p>创建监听套接字，并设置为非阻塞模式。</p></li><li><p>将监听套接字添加到 epoll 实例的事件表中（epoll_ctl 函数，指定事件类型为 EPOLLIN）。</p></li><li><p>进入事件循环，调用 epoll_wait 函数等待事件发生。</p></li><li><p>当 epoll_wait 返回时，遍历就绪的事件列表，处理每个事件对应的文件描述符。</p></li><li><p>如果是监听套接字准备就绪，表示有新的连接请求，接受连接并将新的套接字添加到 epoll 实例的事件表中。</p></li><li><p>如果是已连接套接字准备就绪，进行读取或写入操作。</p></li></ul><p>边缘触发模式：</p><ul><li><p>精确的事件通知：边缘触发模式只在文件描述符状态发生变化时才进行通知，而不是像水平触发模式那样只要文件描述符可读或可写就会通知。这意味着应用程序只在真正发生状态变化时才会收到通知，避免了不必要的通知，减少了上下文切换和事件处理的开销。</p></li><li><p>适应高并发环境：边缘触发模式适用于高并发连接的场景，特别是在大规模并发连接的情况下，由于只在状态变化时进行通知，可以有效降低系统开销。边缘触发模式通常与非阻塞 I/O 配合使用，以更好地利用系统资源和处理并发连接。</p></li></ul><p>水平触发模式：</p><ul><li><p>持续通知：一旦文件描述符可读或可写，内核会持续通知应用程序，直到应用程序处理完相关事件或缓冲区不再可读或可写。这意味着应用程序需要在每次通知后重新处理 I/O 事件，否则可能会造成 CPU 资源的浪费。</p></li><li><p>适用于阻塞 I/O：水平触发模式通常与阻塞 I/O 结合使用。当文件描述符准备就绪时，应用程序可以直接进行 I/O 操作，如果数据未完全就绪或无法立即发送，则会阻塞在相应的读取或写入操作上，直到数据就绪或可写入</p></li></ul><p>两种模式和I/O的组合：<a href="https://www.cnblogs.com/JCpeng/p/15169423.html">epoll水平/边缘触发模式设置阻塞/非阻塞IO事件触发条件及次数 - Jcpeng_std - 博客园</a></p><ul><li>具体地说，采用边缘触发模式必须使用非阻塞IO，不然读缓冲区数据没有了，就会一直阻塞在recv()函数这里。（内核通知fd需要读取，不过却卡在了读取的路上）</li></ul>              </div>            </details><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.死锁的必要条件</strong></p><ul><li><p>互斥条件（Mutual Exclusion）</p></li><li><p>不可剥夺条件（No Preemption）</p></li><li><p>请求和保持条件（Hold and Wait)</p></li><li><p>循环等待条件（Circular Wait）</p></li></ul><p><strong>2.死锁的破坏</strong></p><ul><li><p>预防死锁（Deadlock Prevention）：</p><ul><li><p>互斥条件破坏：将某些资源设计为可共享的，多个进程可以同时访问。</p></li><li><p>请求与保持条件破坏：进程在申请资源时，要求一次性申请所需要的所有资源，而不是逐个申请。</p></li><li><p>不可剥夺条件破坏：允许操作系统在必要时剥夺进程已经占有的资源。</p></li><li><p>循环等待条件破坏：对系统中的资源进行全局排序，并规定进程按照序号递增的顺序申请资源。</p></li></ul></li><li><p>避免死锁（Deadlock Avoidance）：银行家算法（Banker’s Algorithm）和资源分配图（Resource Allocation Graph）。</p></li><li><p>检测和恢复死锁（Deadlock Detection and Recovery）：常见的死锁检测算法有图论算法、资源分配图算法等。恢复死锁可以采取一些策略，如终止某个或多个进程、抢占资源、回滚进程等。</p></li><li><p>忽略死锁（Deadlock Ignorance）：这种方法适用于死锁发生的概率极低，或者死锁发生后对系统造成的影响较小的场景。</p></li></ul><p><strong>3.进程通信方式</strong></p><ol><li><p>共享内存（Shared Memory）：多个进程可以访问和操作同一块共享内存区域，从而实现数据的共享和交换。进程可以直接读写内存，无需进行复制和传输。共享内存需要使用同步机制（如信号量）来避免多个进程同时访问导致的竞态条件。</p></li><li><p>管道（Pipe）：管道是一种半双工的通信方式，用于具有亲缘关系的进程间通信。一个进程可以将输出写入管道，另一个进程则可以从管道读取输入。管道可以是匿名管道（在进程创建时自动创建）或命名管道（通过文件系统中的路径名创建）。</p></li><li><p>命名管道（Named Pipe）：命名管道允许不具有亲缘关系的进程进行通信。与匿名管道不同，命名管道在文件系统中有一个关联的路径名，进程可以通过打开该路径名来进行通信。</p></li><li><p>消息队列（Message Queue）：消息队列是一种可以实现进程间异步通信的方式。进程可以将消息发送到队列中，其他进程则可以从队列中接收这些消息。消息队列允许不同进程之间以先进先出的顺序进行通信。</p></li><li><p>信号量（Semaphore）：信号量是一种用于进程间同步的机制。它可以用来保护临界区，限制资源的访问以及实现进程间的互斥和同步操作。进程可以通过等待（wait）和释放（signal）信号量来实现对共享资源的访问控制。</p></li><li><p>套接字（Socket）：套接字是一种用于网络通信的接口。它允许不同主机上的进程进行通信，实现了跨网络的进程间通信。</p></li><li><p>文件（File）：进程可以通过读写文件来进行通信。一个进程可以将数据写入文件，另一个进程则可以从文件中读取这些数据。</p></li></ol><p><strong>4.进程和线程的区别</strong></p><ul><li><p>定义：进程是程序的执行实例，是资源分配和调度的基本单位。它拥有独立的内存空间，包含程序代码、数据和执行状态。线程是进程内的一个执行单元，是进程的实际执行者。线程共享进程的内存空间和资源，可以看作是进程内的子任务。</p></li><li><p>资源占用：每个进程都有独立的内存空间和资源，包括文件描述符、环境变量、信号处理器等。不同进程之间的资源是相互隔离的，需要通过进程间通信机制来实现数据交换。而线程共享进程的内存空间和资源，可以直接读取和修改进程的数据。</p></li><li><p>切换开销：进程之间切换的开销较大，因为需要保存和恢复整个进程的状态信息，包括程序计数器、寄存器状态、内存映射等。线程切换的开销较小，因为线程共享进程的内存空间，只需要保存和恢复线程私有的寄存器状态即可。</p></li><li><p>通信和同步：进程间通信（IPC）是相对复杂的，需要使用进程间通信机制，如管道、消息队列、共享内存等。线程之间通信和同步较为简单，可以直接读写共享的内存空间，也可以使用线程间同步机制，如互斥锁、条件变量等，来保证数据的一致性和互斥访问。</p></li><li><p>安全性：由于每个进程有独立的内存空间，一个进程的崩溃不会影响其他进程。而在多线程编程中，一个线程的错误可能导致整个进程崩溃。</p></li></ul><p><strong>5.僵尸进程和孤儿进程</strong></p><ul><li><p>孤儿进程（Orphan Process）：当一个进程的父进程在其退出之前先退出或被终止时，该进程会成为孤儿进程。此时，孤儿进程将由 init 进程（进程 ID 为 1）接管，并成为 init 进程的子进程。init 进程负责回收孤儿进程的资源，并保持系统的稳定运行。孤儿进程不会成为僵尸进程，因为它的退出状态会被 init 进程处理。</p></li><li><p>僵尸进程（Zombie Process）：当一个进程终止（退出），但其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 系统调用来获取子进程的退出状态时，子进程会变成僵尸进程。在这种状态下，僵尸进程的进程控制块（Process Control Block，PCB）仍然存在，但不再执行任何代码。僵尸进程占用一些系统资源，因此父进程应该及时回收子进程，以避免僵尸进程的累积。父进程可以通过调用适当的系统调用来获取子进程的退出状态，并释放僵尸进程的资源。</p></li></ul><p><strong>6.虚拟内存</strong></p><p>是什么：虚拟内存的主要目的是提供了一种抽象层，使得每个进程认为它拥有连续的、私有的地址空间，而不需要实际的物理内存支持。它通过使用页面（Page）或页面框（Page Frame）作为最小的内存单位，将进程的地址空间划分为固定大小的页面，并将这些页面映射到物理内存或磁盘上。</p><p>工作原理：</p><ul><li><p>地址空间划分：操作系统将进程的地址空间划分为多个页面（通常是固定大小的4KB或2MB），并将其映射到虚拟地址空间。</p></li><li><p>虚拟地址转换：当进程访问虚拟地址时，CPU会将虚拟地址转换为物理地址。这个转换过程是通过页表（Page Table）实现的，页表存储了虚拟页面和物理页面之间的映射关系。</p></li><li><p>页面置换：如果所需的页面不在物理内存中，操作系统会将页面从磁盘加载到内存中，并更新页表中的映射关系。如果内存不足，操作系统会根据页面置换算法将某些页面置换到磁盘上，以便为新页面腾出空间。</p></li></ul><p>虚拟内存的优势包括：</p><ul><li><p>扩展了物理内存：进程可以访问比物理内存更大的地址空间，允许运行更大的程序和处理更大的数据。</p></li><li><p>提供了地址空间隔离：每个进程拥有独立的地址空间，保护了进程之间的数据不受干扰，提高了系统的稳定性和安全性。</p></li><li><p>简化了内存管理：操作系统负责管理虚拟内存的分配和回收，减少了程序员对内存管理的复杂性。</p></li><li><p>支持页面置换和页面共享：通过页面置换算法，操作系统可以有效地管理内存资源。同时，多个进程可以共享同一物理页面，提高了内存利用率。</p></li></ul>              </div>            </details><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.单例模式</strong></p><p>涉及到类多个对象的操作函数：</p><ul><li><p>构造函数</p></li><li><p>拷贝构造函数</p></li><li><p>拷贝赋值操作符函数()</p></li></ul><p>为了把一个类可以实例化多个对象的路堵死：</p><ul><li><p>构造函数私有化</p></li><li><p>拷贝构造函数私有化或者禁用</p></li><li><p>拷贝赋值操作符函数私有化或者禁用</p></li></ul><p>要点：<code>静态成员的初始化要在类外</code></p><p>为了得到单例对象，需要定义一个静态的私有的类实例和静态的公共的访问函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分类：</p><ul><li><p>饿汉模式-&gt;定义类的时候已经创建单例对象(以上示例就是懒汉模式)</p></li><li><p>懒汉模式-&gt;使用的时候才创建单例对象(示例如下)</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程下：</p><ul><li><p>饿汉模式在多线程下没有线程安全问题，多线程可以同时访问</p></li><li><p>懒汉模式在多线程下有线程安全问题，可能创建多个类的实例</p></li></ul><p>解决懒汉模式在多线程下的线程安全问题</p><p>方案一：加互斥锁，不过多线程下是顺序执行的</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ=<span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：双重检查锁定，一开始还未创建实例时是顺序执行的，创建后可以并行执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span>(m_taskQ==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                m_taskQ=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="type">static</span> TaskQueue* m_taskQ;</span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">TaskQueue* TaskQueue::m_taskQ=<span class="literal">nullptr</span>;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二中m_taskQ = new TaskQueue执行过程中，正常过程如下：</p><ul><li><p>第一步：分配内存用于保存 TaskQueue 对象。</p></li><li><p>第二步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p></li><li><p>第三步：使用 m_taskQ 指针指向分配的内存。</p></li></ul><p>但是被重新排序以后执行顺序可能会变成这样：</p><ul><li><p>第一步：分配内存用于保存 TaskQueue 对象。</p></li><li><p>第二步：使用 m_taskQ 指针指向分配的内存。</p></li><li><p>第三步：在分配的内存中构造一个 TaskQueue 对象（初始化内存）。</p></li></ul><p>此时可能会出现这种情况，一个线程执行的顺序如上，执行到第二步时，m_taskQ不等于nullptr了，此时其他线程遇到第一个检查时就可以直接通过并返回指针，造成异常的访问情况</p><p>方案三：双重锁定+使用C++11的atomic规定指令执行顺序，使用原子操作可以使得机器指令按顺序执行</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue &amp;t)=<span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; t)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TaskQueue* task = m_taskQ.<span class="built_in">load</span>();</span><br><span class="line">        <span class="keyword">if</span>(task==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">            task = m_taskQ.<span class="built_in">load</span>();</span><br><span class="line">            <span class="keyword">if</span>(task==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                task=<span class="keyword">new</span> TaskQueue;</span><br><span class="line">                m_taskQ.<span class="built_in">store</span>(task);</span><br><span class="line">            &#125;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;单例对象的一个成员函数&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>()=<span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">//static TaskQueue* m_taskQ;</span></span><br><span class="line">    <span class="type">static</span> mutex m_mutex;</span><br><span class="line">    <span class="type">static</span> atomic&lt;TaskQueue*&gt; m_taskQ;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//TaskQueue* TaskQueue::m_taskQ=nullptr;</span></span><br><span class="line">atomic&lt;TaskQueue*&gt; TaskQueue::m_taskQ;</span><br><span class="line">mutex TaskQueue::m_mutex;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* taskQ = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    taskQ-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案四：静态局部对象(懒汉模式多线程下最简单的方案)</p><p>原理:<code>如果指令逻辑进入一个未被初始化的声明变量，所有并发执行应当等待该变量完成初始化。</code></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// = delete 代表函数禁用, 也可以将其访问权限设置为私有</span></span><br><span class="line">    <span class="built_in">TaskQueue</span>(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    TaskQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> TaskQueue&amp; obj) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> TaskQueue* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> TaskQueue taskQ;</span><br><span class="line">        <span class="keyword">return</span> &amp;taskQ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello, world!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TaskQueue* queue = TaskQueue::<span class="built_in">getInstance</span>();</span><br><span class="line">    queue-&gt;<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details> ]]></content>
      
      
      <categories>
          
          <category> 面试八股文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11-右值引用</title>
      <link href="/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>lvalue: 可以取地址</p><p>rvalue: 不可取地址</p><p>引用就是别名</p><p>只能通过左值去初始化左值引用，右值去初始化右值引用</p><p>常量的左值引用是万能的引用类型，可以用左值、左值引用、常量的右值引用</p><p>右值引用：延长临时变量的时间， A a=临时</p><p>左值引用：用来函数传递参数</p><p>移动构造函数-复用其他对象中的资源(堆内存)（浅拷贝+其他对象指针指向空）</p><p>右值引用：复用匿名对象所有资源</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为OD题库</title>
      <link href="/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/"/>
      <url>/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-最大化资源控制成本"><a href="#1-最大化资源控制成本" class="headerlink" title="1.最大化资源控制成本"></a>1.最大化资源控制成本</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>公司创新实验室正在研究如何最小化资源成本，最大化资源利用率，请你设计算法帮他们解决个任务混部问题: 有taskNum项任务，每个任务有开始时间 (startTime) ，结束时间(endTime)并行度(parallelism) 三个属性，并行度是指这个任务运行时将会占用的服务器数量，一个服务器在每个时刻可以被任意任务使用但最多被一个任务占用，任务运行完成立即释放(结束时刻不占用)。任务混部问题是指给定一批任务，让这批任务由同一批服务器承载运行请你计算完成这批任务混部最少需要多少服务器，从而最大最大化控制资源成本。<br><strong>输入描述:</strong><br>第一行输入为taskNum，表示有taskNum项任务接下来taskNum行，每行三个整数，表示每个任务的开始时间(startTime ) ，结束时间 (endTime ) ，并行度 (parallelism)<br><strong>输出描述:</strong><br>个整数，表示最少需要的服务器数量<br><strong>示例1</strong> 输入输出示例仅供调试，后台判断数据一般不包含示例输入<br>3<br>2 3 1<br>6 9 2<br>0 5 1<br><strong>输出</strong><br>2</p><p>说明共有三个任务，第一个任务在时间区间[2，3]运行，占用1个服务器，第二个任务在时间区间[6，9] 运行，占用2个服务器，第三个任务在时间区间[0，5]运行，占用1个服务器，需要最多服务器的时间区间为[2，3]和[6，9] ，需要2个服务器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&gt;b[<span class="number">0</span>];<span class="comment">//小顶堆,结束时间最早的在堆顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">task</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;task[i][<span class="number">0</span>]&gt;&gt;task[i][<span class="number">1</span>]&gt;&gt;task[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//priority_queue存放未完成的task</span></span><br><span class="line">    <span class="comment">//每次只需要比较堆顶的结束时间和当前任务的开始时间就可以得知当前任务是否可以加入</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;, cmp&gt; pq;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务按照开始时间升序</span></span><br><span class="line">    <span class="built_in">sort</span>(task.<span class="built_in">begin</span>(),task.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">int</span> max_res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cur_res=<span class="number">0</span>;<span class="comment">//优先队列里面的任务对应并发度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;task.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将结束时间小于当前任务开始时间的任务清空</span></span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">top</span>()[<span class="number">0</span>]&lt;task[i][<span class="number">0</span>])&#123;</span><br><span class="line">                cur_res-=pq.<span class="built_in">top</span>()[<span class="number">1</span>];</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pq.<span class="built_in">push</span>(vector&lt;<span class="type">int</span>&gt;&#123;task[i][<span class="number">1</span>],task[i][<span class="number">2</span>]&#125;);</span><br><span class="line">        cur_res+=task[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(cur_res&gt;max_res) max_res=cur_res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h3 id="2-完美走位"><a href="#2-完美走位" class="headerlink" title="2.完美走位"></a>2.完美走位</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>输入一个长度为4的倍数的字符串，字符串中仅包含WASD四个字母将这个字符串中的连续子串用同等长度的仅包含WASD的 字符串替换Q，如果替换后整个字符串中WASD四个字母出现的频数相同，那么我们称替换后的字符串是“完美走位”。求子串的最小长度。如果输入字符串已经平衡则输出0.<br><strong>二、输入</strong><br>一行字符表示给定的字符串s<br>数据范围:<br>1&lt;=n&lt;=10^5且n是4的倍数，字符串中仅包含WASD四个字母<br><strong>三、输出</strong><br>一个整数表示答案<br><strong>四、样例输入输出</strong><br>输入:<br>WASDAASD<br>输出:</p><p>1<br>说明:<br>将第二个A替换为W，即可得到完美走位</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">滑动区间内为可自由变更的区间，若滑动区间的长度可以&gt;=最大值与各个字母的差</span></span><br><span class="line"><span class="comment">且二者的差值为4的整数倍，滑动区间满足</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; char_count;</span><br><span class="line">    <span class="comment">//初始化不能省略</span></span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;A&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;S&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line">    char_count[<span class="string">&#x27;D&#x27;</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: str)</span><br><span class="line">    &#123;</span><br><span class="line">        char_count[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;A&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;S&#x27;</span>]&amp;&amp;</span><br><span class="line">    char_count[<span class="string">&#x27;W&#x27;</span>]==char_count[<span class="string">&#x27;D&#x27;</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//出现最多的字母</span></span><br><span class="line">    <span class="type">int</span> max_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 空闲的字母数</span></span><br><span class="line">    <span class="type">int</span> surplus_char_num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始时，滑动窗口的长度为1,滑动窗口外的相应字母--</span></span><br><span class="line">    char_count[str[<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;str.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//每次都要重新赋值，不然会保留最开始的最大值</span></span><br><span class="line">        max_char_num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)&#123;</span><br><span class="line">            max_char_num=<span class="built_in">max</span>(max_char_num,x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;最大的字母数:&quot;&lt;&lt;max_char_num&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//滑动窗口的长度也是可自由分配字母的个数</span></span><br><span class="line">        length=right-left+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//需要改变的字母数</span></span><br><span class="line">        <span class="type">int</span> required=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x: char_count)</span><br><span class="line">        &#123;</span><br><span class="line">            required+=(max_char_num-x.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;需要改变的字母数&quot;&lt;&lt;required&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;区间长度&quot;&lt;&lt;length&lt;&lt;&quot;,&quot;&lt;&lt;&quot;区间范围&quot;&lt;&lt;left&lt;&lt;&quot;,&quot;&lt;&lt;right&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">        surplus_char_num=length-required;</span><br><span class="line">        <span class="comment">//区间满足，左指针左移</span></span><br><span class="line">        <span class="keyword">if</span>(surplus_char_num&gt;=<span class="number">0</span>&amp;&amp;surplus_char_num%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(length&lt;ans) ans=length;</span><br><span class="line">            char_count[str[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//区间不满足，右指针右移</span></span><br><span class="line">            <span class="comment">//右指针需要先右移</span></span><br><span class="line">            right++;</span><br><span class="line">            char_count[str[right]]--;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="3-羊、狼、农夫过河"><a href="#3-羊、狼、农夫过河" class="headerlink" title="3.羊、狼、农夫过河"></a>3.羊、狼、农夫过河</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。农夫有一艘容量固定的船，能够承载固定数量的动物。要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。<br>备注: 农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊农夫自身不占用船的容量。<br><strong>输入描述</strong><br>第一行输入为M，N，x，分别代表羊的数量，狼的数量，小船的容量.<br><strong>输出描述</strong><br>输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。(若无法满足条件则输出0)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> minTimes=INT_MAX;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transport</span><span class="params">(<span class="type">int</span> m0, <span class="type">int</span> n0, <span class="type">int</span> x, <span class="type">int</span> m1, <span class="type">int</span> n1, <span class="type">int</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=m0+n0)&#123;</span><br><span class="line">        <span class="keyword">if</span>(times+<span class="number">1</span>&lt;minTimes) minTimes=times+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//外层保证羊的数量小于容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=m0 &amp;&amp; i&lt;=x; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证羊+狼不超重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=n0 &amp;&amp; i+j&lt;=x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//保证两岸的羊数量&gt;=狼(要么羊数量为0)</span></span><br><span class="line">            <span class="keyword">if</span>((m0-i==<span class="number">0</span>||m0-i&gt;n0-j)&amp;&amp;(m1+i==<span class="number">0</span>||m1+i&gt;n1+j))&#123;</span><br><span class="line">                <span class="built_in">transport</span>(m0-i,n0-j,x,m1+i,n1+j,times+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> M,N,X;</span><br><span class="line">    cin&gt;&gt;M&gt;&gt;N&gt;&gt;X;</span><br><span class="line">    <span class="built_in">transport</span>(M,N,X,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(minTimes==INT_MAX)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;minTimes&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="4-字符串重新排列"><a href="#4-字符串重新排列" class="headerlink" title="4.字符串重新排列"></a>4.字符串重新排列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出</p><p>1、单词内部调整: 对每个单词字母重新按字典序排序<br>2、单词间顺序调整:<br>1)统计每个单词出现的次数，并按次数 降序排列Q<br>2)次数相同，按单词长度Q 升序排列<br>3)次数和单词长度均相同，按字典升序排列<br>请输出处理后的字符串，每个单词以一个空格分隔<br><strong>输入描述:</strong><br>一行字符串，每个字符取值范围:[a-ZA-z0-9] 以及空格，字符串长度范围:[1，1000]<br>例1:<br>输入<br>This is an apple<br>输出<br>an is This aelpp<br>例2:<br>输入:<br>My sister is in the house not in the yard<br>输出:<br>in in eht eht My is not adry ehosu eirsst</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a, pair&lt;string,<span class="type">int</span>&gt; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.second!=b.second) <span class="keyword">return</span> a.second&gt;b.second;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.first.<span class="built_in">size</span>()!=b.first.<span class="built_in">size</span>()) <span class="keyword">return</span> a.first.<span class="built_in">size</span>()&lt;b.first.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a.first&lt;b.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> pos = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,pos));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="comment">//第一步，单词内部调整</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步，单词间调整</span></span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; str_count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str_count.<span class="built_in">count</span>(v[i]))&#123;</span><br><span class="line">            str_count[v[i]]+=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str_count[v[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    vector&lt;pair&lt;string,<span class="type">int</span>&gt;&gt; <span class="built_in">str_count_vec</span>(str_count.<span class="built_in">begin</span>(),str_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(str_count_vec.<span class="built_in">begin</span>(),str_count_vec.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item : str_count_vec)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;item.second; i++) cout&lt;&lt;item.first&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="5-租车骑绿岛"><a href="#5-租车骑绿岛" class="headerlink" title="5.租车骑绿岛"></a>5.租车骑绿岛</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，做最大载重M。给出部门每个人的体重，请问最多需要租用多少双人自行车</p><p><strong>输入描述:</strong><br>第一行两个数字m、n，分别代表自行车限重，部门总人数。第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。0&lt;me=200<br>0&lt;n&lt;=1000000<br><strong>输出描述:</strong><br>最小需要的双人自行车数量。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>34<br>3 2 2 1<br>输出</p><p>3</p><p><strong>思路</strong>：这个问题可以通过贪心算法来解决。首先，将所有人的体重从小到大排序。然后，从最轻的人开始，每次选择最轻的人和最重的人搭配在一起。如果两个人的体重之和不超过自行车的限重，则他们可以共用一辆自行车；否则，最重的人需要单独使用一辆自行车。重复这个过程，直到所有人都被安排好。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">min_bikes</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> weights[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(weights, weights + n);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> bikes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (weights[left] + weights[right] &lt;= m) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right--;</span><br><span class="line">            bikes++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bikes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> weights[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; weights[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min_bikes</span>(m, n, weights) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="6-无向图染色"><a href="#6-无向图染色" class="headerlink" title="6.无向图染色"></a>6.无向图染色</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给一个无向图Q 染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方案?<br><strong>输入描述:</strong><br>第一行输入M(图中节点数) N(边数)<br>后续N行格式为: V1 V2表示一个V1到V2的边<br>数据范围: 1 &lt;= M &lt;= 15.0 &lt;= N &lt;= M3，不能保证所有节点都是连通的</p><p><strong>输出描述:</strong><br>输出一个数字表示染色方案的个数<br>示例1:<br>输入:<br>4 4<br>1 2<br>2 4<br>3 4<br>1 3<br><strong>输出:</strong></p><p>7<br>说明: 4个节点，4条边，1号节点和2号节点相连，2号节点和4号节点相连，3号节点和4号节点相连，1号节点和3号节点相连，若想必须保证相邻两个节点不能同时为红色，总共7种方案。</p><p><strong>思路</strong>：遍历所有的染色方案，再逐一判断每条边的两边是否都是红色</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="comment">//存入结点时，以0号结点开头</span></span><br><span class="line">        edges.<span class="built_in">push_back</span>(&#123;a<span class="number">-1</span>,b<span class="number">-1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    0101表示0号结点为黑，1号结点为红，2号结点为黑，3号结点为红</span></span><br><span class="line"><span class="comment">    从右边往左边分别是0,1,2,3</span></span><br><span class="line"><span class="comment">    为了取得相应结点的颜色，需要右移0,1,2,3位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;m); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//检测所有边的两端</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> edge: edges)&#123;</span><br><span class="line">            <span class="type">int</span> node1=i&gt;&gt;edge.first;</span><br><span class="line">            <span class="type">int</span> node2=i&gt;&gt;edge.second;</span><br><span class="line">            <span class="keyword">if</span>((node1&amp;<span class="number">1</span>) &amp;&amp; (node2&amp;<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="7-单向链表中间节点"><a href="#7-单向链表中间节点" class="headerlink" title="7.单向链表中间节点"></a>7.单向链表中间节点</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>求单向链表Q 中间的节点值，如果奇数个节点取中间，偶数个取偏右边的那个值。</p><p><strong>输入描述:</strong><br>第一行 链表头节点地址path 后续输入的节点数n后续输入每行表示一个节点，格式:”节点地址 节点值 下一个节点地址(-1表示空指针“输入保证链表不会出现环，并且可能存在一些节点不属于链表输出描述:<br>链表中间节点值。<br>测试用例:<br><strong>输入:</strong><br>00010 4<br>00000 3 -1<br>00010 5 12309<br>11451 6 00000<br>12309 7 11451<br>输出:<br>6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,<span class="type">int</span>&gt; node_value;</span><br><span class="line">    map&lt;string,string&gt; node_node;</span><br><span class="line">    string head;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;head&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string start,end;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin&gt;&gt;start&gt;&gt;val&gt;&gt;end;</span><br><span class="line">        node_value[start]=val;</span><br><span class="line">        node_node[start]=end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历一遍求长度</span></span><br><span class="line">    string tmp=head;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(node_node[tmp]!=<span class="string">&quot;-1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp=node_node[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;node_value[tmp]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="8-划分为k个相等的子集"><a href="#8-划分为k个相等的子集" class="headerlink" title="8.划分为k个相等的子集"></a>8.划分为k个相等的子集</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定一个整数数组  <code>nums</code> 和一个正整数 <code>k</code>，找出是否有可能把这个数组分成 <code>k</code> 个非空子集，其总和都相等。</p><p>思路一：动态规划</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % k != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target = sum / k;</span><br><span class="line">    <span class="comment">//dp压缩状态，dp[i]表示状态i下是否可以划分为x个target</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1</span> &lt;&lt; nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//枚举每一种状态，并由当前状态推导出后面的状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>()); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]==<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//第j位是否为1,即是否已经使用</span></span><br><span class="line">            <span class="type">int</span> flag=i&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">if</span>(!flag&amp;&amp;dp[i]+nums[j]&lt;=target)&#123;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=(dp[i]+nums[j])%target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[(<span class="number">1</span>&lt;&lt;nums.<span class="built_in">size</span>())<span class="number">-1</span>]==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路二：回溯法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sum%k!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> target=sum/k;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a&gt;b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bucket</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">backtrack</span>(nums,<span class="number">0</span>,bucket,k,target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt;&amp; bucket, <span class="type">int</span> k, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==nums.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//每个球有k个选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;bucket[i]==bucket[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(bucket[i]+nums[index]&gt;target) <span class="keyword">continue</span>;</span><br><span class="line">        bucket[i]+=nums[index];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">backtrack</span>(nums,index+<span class="number">1</span>,bucket,k,target)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        bucket[i]-=nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="9-最多颜色的车"><a href="#9-最多颜色的车" class="headerlink" title="9.最多颜色的车"></a>9.最多颜色的车</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>在一个狭小的路口，每秒只能通过一辆车，假好车辆的颜色只有 3 种，找出N 秒内经过的最多颜色的车辆数量。<br>三种颜色编号为0，1，2<br><strong>输入描述</strong><br>第一行输入的是通过的车辆颜色信息<br>[0,1,1,2]代表4 秒钟通过的车辆颜色分别是 0，1，1，2</p><p>第二行输入的是统计时间窗，整型，单位为秒输出描述<br>输出指定时间窗内经过的最多颜色的车辆数量<br>样例<br>样例一:<br>输入<br>0 1 2 1<br>3<br>输出<br>2<br>样例解释<br>在 3 秒时间窗内，每个颜色最多出现 2 次。例为: [1,2,1]<br>样例二:<br>输入<br>0 1 2 1<br>2<br>输出</p><p>1<br>样例解释<br>在 2 秒时间窗内，每个颜色最多出现1 次</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    <span class="type">int</span> window;</span><br><span class="line">    cin&gt;&gt;window;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cars;</span><br><span class="line">    <span class="keyword">while</span>(input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>)!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> found=input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>,found)));</span><br><span class="line">        input_str=input_str.<span class="built_in">substr</span>(found+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cars.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="comment">//初始化滑动窗口</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; car_count=<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;window; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滑动窗口滑动</span></span><br><span class="line">    <span class="type">int</span> max_res=*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=window; i&lt;cars.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        car_count[cars[i]]++;</span><br><span class="line">        car_count[cars[i-window]]--;</span><br><span class="line">        max_res=<span class="built_in">max</span>(max_res,*<span class="built_in">max_element</span>(car_count.<span class="built_in">begin</span>(),car_count.<span class="built_in">end</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="10-不含101的数"><a href="#10-不含101的数" class="headerlink" title="10.不含101的数"></a>10.不含101的数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>小明在学习二进制时，发现了一类不含 101的数，也就是：将数字用二进制表示，不能出现 101 。现在给定一个整数区间 [l,r] ，请问这个区间包含了多少个不含 101 的数？</p><p><strong>输入描述</strong></p><p>输入的唯一一行包含两个正整数 l， r（ 1 ≤ l ≤ r ≤ 10^9）。</p><p><strong>输出描述</strong></p><p>输出的唯一一行包含一个整数，表示在 [l,r] 区间内一共有几个不含 101 的数。</p><p><strong>样例一：</strong></p><p><strong>输入</strong></p><p>1 10</p><p><strong>输出</strong></p><p>8</p><p>样例解释：区间 [1,10] 内， 5 的二进制表示为 101 ，10的二进制表示为 1010 ，因此区间 [ 1 , 10 ] 内有 10−2=8个不含 101的数。</p><p>思路一：暴力法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bitset&lt;64&gt; <span class="title">bit</span><span class="params">(num)</span></span>;</span><br><span class="line">    string bin=bit.<span class="built_in">to_string</span>();</span><br><span class="line">    cout&lt;&lt;bin&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(bin.<span class="built_in">find</span>(<span class="string">&quot;101&quot;</span>)==<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isValid</span>(i))&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路二：数位dp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> p, <span class="type">bool</span> flag, vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; binary_dp, vector&lt;<span class="type">int</span>&gt; single_binary_nums, <span class="type">int</span> pre, <span class="type">int</span> prepre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == single_binary_nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag &amp;&amp; binary_dp[p][pre][prepre] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> binary_dp[p][pre][prepre];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> index = flag ? single_binary_nums[p] : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index+<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; pre == <span class="number">0</span> &amp;&amp; prepre == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += <span class="built_in">search</span>(p + <span class="number">1</span>, flag &amp;&amp; i == index, binary_dp, single_binary_nums, i, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">        binary_dp[p][pre][prepre] = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 10 -&gt; [1,0,1,0,0]</span></span><br><span class="line">    bitset&lt;20&gt; number;</span><br><span class="line">    number = num;</span><br><span class="line">    string number_str=number.<span class="built_in">to_string</span>(); </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">single_binary_nums</span><span class="params">(number_str.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;number_str.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        single_binary_nums[i] = (<span class="type">int</span>)number_str[i]<span class="number">-48</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">binary_dp</span>(single_binary_nums.<span class="built_in">size</span>(), vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">search</span>(<span class="number">0</span>, <span class="literal">true</span>, binary_dp, single_binary_nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> left, right;</span><br><span class="line">    cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">dp</span>(right)-<span class="built_in">dp</span>(left<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="11-过滤组合字符串"><a href="#11-过滤组合字符串" class="headerlink" title="11.过滤组合字符串"></a>11.过滤组合字符串</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>数字0、1、2、3、4、5、6、7、8、9分别关联 a~z 26个英文字母<br>0关联”a””b””c”<br>1关联”d”,”e”,”?<br>2关联”g”,”h”””<br>3 关联”,”k”,””<br>4 关联”m””n””o”<br>5关联”p”,”q”””<br>6关联”s”,”t”<br>7 关联”u””v”<br>8关联”w””x”<br>9关联”y”,”z”<br>例如7关联”u””v”，8关联”x””w”，输入一个字符串例如“78”和一个屏蔽字符串“ux”,那么“78”可以组成多个字符串例如:“ux”，“uw”“vx”，“ww”，过滤这些完全包含屏蔽字符串的每一个字符的字符串，然后输出剩下的字符串。<br>示例:<br>输入:<br>78<br>ux<br>输出:<br>uw vx vw<br>说明: ux完全包含屏蔽字符串ux，因此别除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> string letterMap[<span class="number">10</span>]=&#123;</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>, <span class="comment">//0</span></span><br><span class="line">    <span class="string">&quot;def&quot;</span>,<span class="comment">//1</span></span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,<span class="comment">//2</span></span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,<span class="comment">//3</span></span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,<span class="comment">//4</span></span><br><span class="line">    <span class="string">&quot;pqr&quot;</span>,<span class="comment">//5</span></span><br><span class="line">    <span class="string">&quot;st&quot;</span>,<span class="comment">//6</span></span><br><span class="line">    <span class="string">&quot;uv&quot;</span>,<span class="comment">//7</span></span><br><span class="line">    <span class="string">&quot;wx&quot;</span>,<span class="comment">//8</span></span><br><span class="line">    <span class="string">&quot;yz&quot;</span>,<span class="comment">//9</span></span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, string&amp; digits, string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index==digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> digit = digits[index]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    string letters = letterMap[digit];<span class="comment">//取数字对应字母集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;letters.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(index+<span class="number">1</span>,digits,s+letters[i]);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符是否全部包含</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string str1, string str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str1)</span><br><span class="line">    &#123;</span><br><span class="line">        set1.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="type">char</span>&gt; set2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:str2)</span><br><span class="line">    &#123;</span><br><span class="line">        set2.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: set2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(set1.<span class="built_in">count</span>(x)==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string digits;</span><br><span class="line">    string filter;</span><br><span class="line">    cin&gt;&gt;digits&gt;&gt;filter;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,digits,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    string result_str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x: result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(filter,x))&#123;</span><br><span class="line">            result_str+=(x+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result_str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="12-真正的密码"><a href="#12-真正的密码" class="headerlink" title="12.真正的密码"></a>12.真正的密码</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>在一行中输入一个字符串数组Q，如果其中一个字符串的所有以索引0开头的子串在数组中都有，那么这个字符串就是潜在密码，在所有潜在密码中最长的是真正的密码，如果有多个长度相同的真正的密码，那么取字典序最大的为唯一的真正的密码，求唯一的真正的密码</p><p>示例1:<br>输入: h he hel hell hello o ok n ni nin ninj ninjaQ<br>输出: ninja说明:按要求，hello、ok、ninja都是潜在密码。检查长度，hello、ninja是真正的密码。检查字典序Q，ninja是唯一真正密码。<br>示例2:<br>输入:<br>a b c d f<br>输出:<br>说明: 按要求，a b c d f都是潜在密码。检查长度，a b c d f 是真正的密码。检查字典序，f是唯一真正密码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有字符串放入哈希集合</span></span><br><span class="line">    set&lt;string&gt; word_set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        word_set.<span class="built_in">insert</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的密码</span></span><br><span class="line">    string true_pass_word=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按顺序检查每一个词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : v) &#123;</span><br><span class="line">        <span class="comment">// 条件1：检查这个词所有以索引0开头的子串在数组中是否都有</span></span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 以索引0开头的子串</span></span><br><span class="line">            string sub_str=s.<span class="built_in">substr</span>(<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(!word_set.<span class="built_in">count</span>(sub_str))&#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="comment">// 条件2：比较密码长度</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;true_pass_word.<span class="built_in">size</span>())</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            <span class="comment">// 条件3：比较密码字典排序</span></span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()==true_pass_word.<span class="built_in">size</span>()&amp;&amp; s&gt;true_pass_word)&#123;</span><br><span class="line">                true_pass_word=s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; true_pass_word;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="13-最小调整顺序次数"><a href="#13-最小调整顺序次数" class="headerlink" title="13.最小调整顺序次数"></a>13.最小调整顺序次数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_number;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_number);</span><br><span class="line">    <span class="type">int</span> number = <span class="built_in">stoi</span>(input_number);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; operations;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>*number;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        operations.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//是否有序</span></span><br><span class="line">    <span class="type">bool</span> in_order = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; operations.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;string&gt; operaion_str = operations[i];</span><br><span class="line">        <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;head&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size &gt; <span class="number">0</span> &amp;&amp; in_order) &#123;</span><br><span class="line">                in_order = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (operaion_str[<span class="number">0</span>]==<span class="string">&quot;tail&quot;</span>) &#123;</span><br><span class="line">            queue_size++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue_size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!in_order) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                in_order = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            queue_size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="14-星球移居计划-n"><a href="#14-星球移居计划-n" class="headerlink" title="14.星球移居计划-n"></a>14.星球移居计划-n</h2><h2 id="15-需要打开多少监视器-n"><a href="#15-需要打开多少监视器-n" class="headerlink" title="15.需要打开多少监视器-n"></a>15.需要打开多少监视器-n</h2><h2 id="16-最佳种树距离-n"><a href="#16-最佳种树距离-n" class="headerlink" title="16.最佳种树距离-n"></a>16.最佳种树距离-n</h2><h2 id="17-阿里巴巴寻宝盒-n"><a href="#17-阿里巴巴寻宝盒-n" class="headerlink" title="17.阿里巴巴寻宝盒-n"></a>17.阿里巴巴寻宝盒-n</h2><h2 id="18-选修课-n"><a href="#18-选修课-n" class="headerlink" title="18.选修课-n"></a>18.选修课-n</h2><h2 id="19-探索地块建立"><a href="#19-探索地块建立" class="headerlink" title="19.探索地块建立"></a>19.探索地块建立</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给一块n<em>m的地块，相当于n</em>m的二维数组，每个元素的值表示这个小地块的发电量;求在这块地上建立正方形的边长为c的发电站，发电量满足目标电量k的地块数量。输入描述:<br>第一行为四个按空格分隔的正整数，分别表示n,m,c k后面n行整数，表示每个地块的发电量输出描述:<br>输出满足条件的地块数量<br>示例:<br>输入:<br>2 5 2 6 // n m ck，下面每行是nm地块每格的发电量<br>1 3 4 5 8<br>2 3 6 7 1<br>输出:<br>4<br>说明:<br>满足条件的地块有以下几种<br>第一种:<br>1 3<br>2 3<br>第二种:<br>3 4<br>3 6<br>第三种:<br>4 5<br>6 7<br>第四种:<br>5 8<br>7 1</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRect</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;P,<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> P[x2][y2]-P[x1<span class="number">-1</span>][y2]-P[x2][y1<span class="number">-1</span>]+P[x1<span class="number">-1</span>][y1<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_area_count</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; mat, <span class="type">int</span> threshold, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = mat.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> m = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">     vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">s</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//1、生成前缀和子矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="comment">//s[i][j]表示以[i,j]作为矩阵最右下角的最大矩阵的前缀和</span></span><br><span class="line">            <span class="comment">//解释：以点[i,j]作为作为最右下角的最大矩阵的前缀和需要加上点[i-1,j]和点[i,j-1]的前缀和，然而会重复多加一个点[i-1][j-1]的前缀和，所以要减一个</span></span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + mat[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//2、遍历前缀和矩阵，获得边长等于c的矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-c+<span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m-c+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getRect</span>(s,i,j,i+c<span class="number">-1</span>,j+c<span class="number">-1</span>)&gt;=threshold) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> c = params[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; matrix;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="comment">// 带空格的字符串输入</span></span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">        matrix.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">get_area_count</span>(matrix, k, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="20-模拟商场优惠打折"><a href="#20-模拟商场优惠打折" class="headerlink" title="20.模拟商场优惠打折"></a>20.模拟商场优惠打折</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>模拟商场优惠打折，有三种 优惠券Q 可以用，满减券、打折券和无门槛券满减券: 满100减10，满200减20，满300减30，满400减40，以此类推不限制使用;打折券: 固定折扣92折，且打折之后向下取整Q，每次购物只能用1次:无门槛券: 一张券减5元，没有使用限制;<br>每个人结账使用优惠券时有以下限制: 每人每次只能用两种优惠券，并且同一种优惠券必须一次用完，不能跟别的穿插使用(比如用一张满减，再用一张打折，再用一张满减，这种顺序<br>不行)求不同使用顺序下每个人用完券之后得到的最低价格和对应使用优惠券的总数:如果两种顺序得到的价格一样低，就取使用优惠券数量较少的那个。输入描述:<br>第一行三个数字m,n,k，分别表示每个人可以使用的满减券、打折券和无门槛券的数量第二行一个数字x,表示有几个人购物<br>后面x行数字，依次表示是这几个人打折之前的商品总价输出描述:<br>输出每个人使用券之后的最低价格和对应使用优惠券的数量示例:<br>输入:<br>3 2 5<br>3<br>100<br>200<br>400<br>输出:<br>65 6<br>135 8<br>275 8</p><p>说明</p><p>第一个人使用 1 张满减券和5张无门槛券价格最低</p><p>第二个人使用 3 张满减券和5张无门槛券价格最低</p><p>第三个人使用 3 张满减券和5张无门槛券价格最低</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//空格分割</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后打折</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_a</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后满减</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_b</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先满减后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_c</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (price &lt;<span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        price -= (price/<span class="number">100</span> * <span class="number">10</span>);</span><br><span class="line">        count += <span class="number">1</span>; </span><br><span class="line">        m--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先打折后无门槛</span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">mode_d</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        price *= <span class="number">0.92</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++) &#123;</span><br><span class="line">        price -= <span class="number">5</span>;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//无门槛用了为负数是直接置0</span></span><br><span class="line">        <span class="keyword">if</span> (price &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            price=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(price, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.first == b.first)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_params;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; params = <span class="built_in">split</span>(input_params);</span><br><span class="line">    <span class="type">int</span> m = params[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> n = params[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> k = params[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    string input_params_x;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_params_x);</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">stoi</span>(input_params_x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;x;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> price = <span class="built_in">stoi</span>(input_str);</span><br><span class="line"></span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_a</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_b</span>(price, m, n));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_c</span>(price, m, k));</span><br><span class="line">        result.<span class="built_in">push_back</span>(<span class="built_in">mode_d</span>(price, n, k));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照价格降序，用券数降序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), comp);</span><br><span class="line">        cout &lt;&lt; result[<span class="number">0</span>].first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; result[<span class="number">0</span>].second&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="21-区间覆盖"><a href="#21-区间覆盖" class="headerlink" title="21.区间覆盖"></a>21.区间覆盖</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定坐标轴上的一组线段，线段的起点和终点均为整数并且长度不小于1，请你从中找到最少数量的线段，这些线段可以覆盖住所有线段。<br>输入描述<br>第一行输入为所有线段的数量，不超过10000，后面每行表示一条线段，格式为”x,y”x和y 分别表示起点和终点，取值范围是[-10^5，10^5]。输出描述<br>最少线段数量，为正整数。<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>1,4<br>2,5<br>3,6<br>输出</p><p>2</p><p>思路<a href="https://www.programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html#%E6%96%B9%E6%B3%95%E4%B8%80">代码随想录</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; x, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//按左端点从小到大排 ,左端点相同，右端点大的在前面</span></span><br><span class="line">    <span class="keyword">if</span>(x.first!=y.first)</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;       </span><br><span class="line">    <span class="keyword">return</span> x.second&gt;y.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; range;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    range.first = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">    range.second = <span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="type">int</span> destiny=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        string input_str;</span><br><span class="line">        cin &gt;&gt; input_str;</span><br><span class="line">        destiny=<span class="built_in">max</span>(destiny,<span class="built_in">split</span>(input_str).second);</span><br><span class="line">        ranges.<span class="built_in">push_back</span>(<span class="built_in">split</span>(input_str));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp); </span><br><span class="line">    <span class="type">int</span> curDistance=ranges[<span class="number">0</span>].second;<span class="comment">//当前覆盖最远距离</span></span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> nextDistance=ranges[<span class="number">0</span>].second;<span class="comment">//下一步覆盖最远距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">       <span class="keyword">if</span>(ranges[i].first&lt;=curDistance)&#123;</span><br><span class="line">           nextDistance=<span class="built_in">max</span>(nextDistance,ranges[i].second);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           i--;</span><br><span class="line">           ans++;</span><br><span class="line">           curDistance=nextDistance;</span><br><span class="line">           <span class="keyword">if</span>(nextDistance==destiny) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(curDistance!=destiny) ans++;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="22-二元组个数"><a href="#22-二元组个数" class="headerlink" title="22.二元组个数"></a>22.二元组个数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>给定两个数组Qa，b，若l == ] 则称[,] 为一个二元组，求在给定的两个数组中，二元组的个数。输入描述:<br>第一行输入 m<br>第二行输入m个数，表示第一个数组<br>第三行输入 n<br>第四行输入n个数，表示第二个数组<br>输出描述:<br>二元组Q个数。<br>示例1:<br>输入:<br>d<br>1 2 34<br>输出:<br>说明: 二元组个数为 1个<br>示例2:<br>输入:<br>6<br>1 1 2 2 4 5<br>3<br>2 2 4<br>输出:<br>5<br>说明:二元组个数为 5 个</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理输入</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_a;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_a_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        nums_a.<span class="built_in">push_back</span>(a);</span><br><span class="line">        nums_a_count[a] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_b;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nums_b_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        nums_b.<span class="built_in">push_back</span>(b);</span><br><span class="line">        nums_b_count[b] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums_a_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums_b_count.<span class="built_in">count</span>(x.first)) &#123;</span><br><span class="line">            result += x.second * nums_b_count[x.first];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="23-连接器问题"><a href="#23-连接器问题" class="headerlink" title="23.连接器问题"></a>23.连接器问题</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>有一组区间[a0，b0]，[a1，b1]，… (a，b表示起点，终点) ，区间有可能重叠、相邻，重叠或相邻则可以合并为更大的区间;给定一组连接器[x1，x2，x3，…] (x表示连接器的最大可连接长度，即x&gt;=gapQ)，可用于将分离的区间连接起来，但两个分离区间之间只能使用1个连接器请编程实现使用连接器后，最少的区间数结果。<br>区间数量&lt;10000，ab均 &lt;=10000<br>连接器梳理&lt;10000; x &lt;= 10000<br>输入描述<br>区间组: [1,10],[15,201,[18,30],[33,40]</p><p>连接器组: [5,4,3,2]<br>输出描述</p><p>1<br>说明:<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。示例1 输入输出示例仅供调试，后台判题数据一般不包含示例入<br>[1,10],[15,20],[18,30],[33,40]<br>[5,4, 3, 2]<br>输出</p><p>1<br>说明<br>合并后: [1,10],[15,30],[33,40]，使用5,3两个连接器连接后只剩下[1,40]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &gt; b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入</span></span><br><span class="line">    string range_str;</span><br><span class="line">    cin &gt;&gt; range_str;</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    range_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(range_str.<span class="built_in">begin</span>(), range_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), range_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp_ranges = <span class="built_in">split</span>(range_str);</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ranges;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;temp_ranges.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; single_range;</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i<span class="number">-1</span>]);</span><br><span class="line">            single_range.<span class="built_in">push_back</span>(temp_ranges[i]);</span><br><span class="line">            ranges.<span class="built_in">push_back</span>(single_range);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string conntetor_str;</span><br><span class="line">    cin &gt;&gt; conntetor_str;</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;[&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    conntetor_str.<span class="built_in">erase</span>(<span class="built_in">remove</span>(conntetor_str.<span class="built_in">begin</span>(), conntetor_str.<span class="built_in">end</span>(), <span class="string">&#x27;]&#x27;</span>), conntetor_str.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; connectors = <span class="built_in">split</span>(conntetor_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(ranges.<span class="built_in">begin</span>(), ranges.<span class="built_in">end</span>(), comp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并区间</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merge_ranges;</span><br><span class="line">    merge_ranges.<span class="built_in">push_back</span>(ranges[<span class="number">0</span>]);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; range_diffs;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; ranges.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range1 = merge_ranges[merge_ranges.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; range2 = ranges[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (range2[<span class="number">0</span>] &lt;= range1[<span class="number">1</span>]) &#123;</span><br><span class="line">            merge_ranges.<span class="built_in">pop_back</span>();</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;range1[<span class="number">0</span>], <span class="built_in">max</span>(range1[<span class="number">1</span>], range2[<span class="number">1</span>])&#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            range_diffs.<span class="built_in">push_back</span>(range2[<span class="number">0</span>] - range1[<span class="number">1</span>]);</span><br><span class="line">            merge_ranges.<span class="built_in">push_back</span>(range2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(range_diffs.<span class="built_in">begin</span>(), range_diffs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(connectors.<span class="built_in">begin</span>(), connectors.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = merge_ranges.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; connectors.<span class="built_in">size</span>()&amp;&amp;idx&lt;range_diffs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connectors[i] &gt;= range_diffs[idx]) &#123;</span><br><span class="line">            idx++;</span><br><span class="line">            result--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="24-打印机队列"><a href="#24-打印机队列" class="headerlink" title="24.打印机队列"></a>24.打印机队列</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>有5台打印机打印文件，每台打印机有自己的待打印队列。因为打印的文件内容有轻重缓急之分，<br>所以队列中的文件有1~10不同的代先级，其中数宁越大优先级越高打印机会从自己的待打印队列中选择优先级最高的文件来打印。如果存在两个优先级一样的文件，则选择最早进入队列的那个文件现在请你来模拟这5台打印机的打印过程。<br>输入描述<br>每个输入包含1个测试用例，每个测试用例第一行给出发生事件的数量N (0 &lt; N&lt; 1000)。<br>接下来有 N 行，分别表示发生的事件。<br>共有如下两种事件:<br>1.“IN P NUM”，表示有一个拥有优先级 NUM 的文件放到了打印机 P 的待打印队列中。 (0&lt; P&lt;= 5, 0&lt; NUM &lt;= 10);<br>2.“OUT P”，表示打印机 P 进行了一次文件打印，同时该文件从待打印队列中取出。 (0&lt; P&lt;=57<br>输出描述<br>对于每个测试用例，每次”OUT P”事件，请在一行中输出文件的编号如果此时没有文件可以打印，请输出”NULL“。文件的编号定义为”IN P NUM”事件发生第 次，此处待打印文件的编号为x。编号从1开始.示例1 输入输出示例仅供调试，后台判断数据一般不包含示例<br>输入</p><p>7<br>IN 1 1<br>IN 1 2<br>IN 1 3<br>IN 2 1<br>OUT 1<br>OUT 2<br>OUT 2<br>输出</p><p>3</p><p>4</p><p>NULL</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(input_str);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    <span class="type">int</span> order;</span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(File a, File b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b.priority-a.priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_count_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_count_str);</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">stoi</span>(input_count_str);</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;File&gt;&gt; <span class="built_in">printers</span>(<span class="number">5</span>, <span class="built_in">vector</span>&lt;File&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        string temp_str;</span><br><span class="line">        <span class="built_in">getline</span>(cin,temp_str);</span><br><span class="line">        vector&lt;string&gt; operations = <span class="built_in">split</span>(temp_str);</span><br><span class="line">        string type = operations[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;IN&quot;</span> == type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">stoi</span>(operations[<span class="number">2</span>]);</span><br><span class="line">            flag++;</span><br><span class="line">            File file;</span><br><span class="line">            file.order = flag;</span><br><span class="line">            file.priority = num;</span><br><span class="line">            printers[p - <span class="number">1</span>].<span class="built_in">push_back</span>(file);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;OUT&quot;</span>==type) &#123;</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">stoi</span>(operations[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (printers[p<span class="number">-1</span>].<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">sort</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>(), printers[p<span class="number">-1</span>].<span class="built_in">end</span>(), comp);</span><br><span class="line">                File file = printers[p<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                cout&lt;&lt;file.order&lt;&lt;endl;</span><br><span class="line">                printers[p<span class="number">-1</span>].<span class="built_in">erase</span>(printers[p<span class="number">-1</span>].<span class="built_in">begin</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NULL&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="25-处理器问题"><a href="#25-处理器问题" class="headerlink" title="25.处理器问题"></a>25.处理器问题</h2><h2 id="26-日志首次上报最多积分"><a href="#26-日志首次上报最多积分" class="headerlink" title="26.日志首次上报最多积分"></a>26.日志首次上报最多积分</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。如果上报太频繁，会对服务端造成压力;如果上报太晚，会降低用户的体验,如果一次上报的条数太多，会导致超时失败。为此，项目组设计了如下的上报策略<br>1、每成功上报一条日志，奖励1分<br>2、每条日志每延迟上报1秒，扣1分3、积累日志达到100条，必须立即上报给出日志序列，根据该规则，计算首次上报能获得的最多积分数输入描述:<br>按时序产生的日志条数 T1,T2…Tn，其中 1&lt;=n&lt;=1000，0&lt;=Ti&lt;=100输出描述:<br>首次上报最多能获得的积分数<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>1 98 1<br>输出<br>98<br>说明:<br>T1 时刻上报得 1 分<br>T2 时刻上报得98分，最大<br>T3 时刻上报得 0分<br>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>3 7 40 10 60<br>输出</p><p>37<br>说明:<br>T1 时刻上报得 3 分<br>T2 时刻上报得 7 分<br>T3 时刻上报得 37 分，最大<br>T4 时刻上报得 -3 分<br>T5 时刻上报，因为已经超了100条的限制，所以只能上报100条，得 -23 分</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理输入</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; logs;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        logs.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    logs.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加分</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plus_score</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    plus_score[<span class="number">0</span>] = logs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 减分</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">minus_score</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(logs.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    result[<span class="number">0</span>] = logs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        plus_score[i] = <span class="built_in">min</span>(<span class="number">100</span>, plus_score[i - <span class="number">1</span>] + logs[i]);</span><br><span class="line">        minus_score[i] = minus_score[i - <span class="number">1</span>] + plus_score[i - <span class="number">1</span>];</span><br><span class="line">        result[i] = plus_score[i] - minus_score[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (plus_score[i] &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_score = <span class="number">0</span>; <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item &gt; max_score) &#123;</span><br><span class="line">            max_score = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;max_score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="27-简单的曝光"><a href="#27-简单的曝光" class="headerlink" title="27.简单的曝光"></a>27.简单的曝光</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>一个图像有n个像素点，存储在一个长度为n的数组img里，每个像素点的取值范围[0,255]的正整数。清你给图像每个像素点值加上一个整数k(可以是负数》，得到新图newImg，使得新图newImg的所有像素平均值最接近中位值128。请输出这个整数k。<br>输入描述<br>n个整数，中间用空格分开<br>例如<br>0 0 0 0<br>4个数值，中间用空格分开<br>输出描述<br>个整数k<br>补充说明<br>1&lt;=n&lt;= 100<br>·如有多个整数k都满足，输出小的那个k;新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0; 当新像素值>255其值会更改为255;<br>例如newlmg=”-1 -2 256”会自动更改为”0 0 255”<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例输入<br>0 0 0 0<br>输出<br>128</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string input_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">while</span> (input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = input_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        input_str = input_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(input_str));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str, string op)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(op) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(op);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入处理</span></span><br><span class="line">    string input_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(input_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> min_diff = <span class="number">256</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">-256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">-127</span>; i &lt;= <span class="number">128</span>; i++) &#123;</span><br><span class="line">        <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">            <span class="comment">// 注意项3</span></span><br><span class="line">            sum += <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">min</span>(nums[j] + i, <span class="number">255</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//靠近中位数的程度</span></span><br><span class="line">        <span class="type">double</span> diff = <span class="built_in">abs</span>(sum / nums.<span class="built_in">size</span>() - <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; min_diff) &#123;</span><br><span class="line">            min_diff = diff;</span><br><span class="line">            result = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff == min_diff &amp;&amp; result != <span class="number">-256</span>) &#123;</span><br><span class="line">            <span class="comment">//注意项2</span></span><br><span class="line">            result = <span class="built_in">min</span>(result, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="27-最大版本号"><a href="#27-最大版本号" class="headerlink" title="27.最大版本号"></a>27.最大版本号</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>Maven 版本号定义，&lt;主版本&gt;.&lt;次版本&gt;.增量版本&gt;-&lt;里程碑版本举例3.1.4-beta 其中，主版本和次版本都是必须的，主版本，次版本，增量版本由多位数字组成，可能包含前导零，里程碑版本由字符串组成</p><p>&lt;主版本&gt;.&lt;次版本&gt;增量版本&gt;: 基于数字比较</p><p>比较里程碑版本: 基于宁符串比较</p><p>采用字典典序比较版本号时，按从左到右的顺序依次比较。基于数字比较只需比较忽略任何前导零后的整数值</p><p>输入2个版本号</p><p>输出最大版本号<br>输入描述:<br>输入两个版本号，按行分割，每个版本号的长度小于50</p><p>输出描述:<br>输出较大的版本号<br>示例1:<br>输入:<br>2.5.1-0<br>1.4.2-D<br>输出:<br>2.5.1-0</p>              </div>            </details><h2 id="28-二进制差异数"><a href="#28-二进制差异数" class="headerlink" title="28.二进制差异数"></a>28.二进制差异数</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>对于任意两个正整数A和B，定义它们之间的差异值和相似值:差异值:A、B转换成二进制后，对于二进制的每一位，对应位置的bit值不相同则为1，否则为<br>0:<br>相似值: A、B转换成二进制后，对于二进制的每一位，对应位置的bit值都为1则为1，否则为0:<br>现在有n个正整数A0到A (n-1)，问有多少(i,j)0&lt;=i&lt;j&lt;n) ，Ai和Aj的差异值大于相似值.假设A=5，B=3;则A的二进制表示101;B的二进制表示011;则A与B的差异值二进制为110;<br>相似值二进制为001;<br>A与B的差异值十进制等于6，相似值十进制等于1，满足条件。输入描述</p><p>输入个n</p><p>接下来n个正整数数据范围: 1&lt;=n&lt;=10^5，1&lt;=A[i]&lt;2^30输出描述<br>输出<br>满足差异值大于相似值的对数<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>4<br>4 3 5 2<br>输出<br>4<br>说明<br>样例1解释<br>满足条件的分别是(0,1)(0,3)(1,2)(2,3)，共4对</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">countPairsWithDifference</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="type">int</span> diff = nums[i] ^ nums[j];</span><br><span class="line">            <span class="type">int</span> sim = nums[i] &amp; nums[j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (diff &gt; sim) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">countPairsWithDifference</span>(nums);</span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二思路：其实就是找规律，因为差异值大于相似值，其最高位的1必然不同，这样就会导致差异值的最高位为1，相似值的最高位为0。因此我们只要找到最高位的1的种类，然后相互组合即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str, string op)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(op) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(op);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(param_str);</span><br><span class="line"></span><br><span class="line">    string op_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, op_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(op_str);</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">bit_info</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">      <span class="function">bitset&lt;32&gt; <span class="title">num_binary</span><span class="params">(num)</span></span>;</span><br><span class="line">      string num_binary_str= num_binary.<span class="built_in">to_string</span>();</span><br><span class="line">      num_binary_str.<span class="built_in">erase</span>(<span class="number">0</span>,num_binary_str.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>));</span><br><span class="line">      <span class="type">int</span> len = num_binary_str.<span class="built_in">size</span>(); </span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;&quot;</span> == num_binary_str) &#123;</span><br><span class="line">        bit_info[<span class="number">0</span>]++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bit_info[num_binary_str.<span class="built_in">size</span>()]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bit_info.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; bit_info.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">        res += bit_info[i] * bit_info[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="Excel单元格数值统计"><a href="#Excel单元格数值统计" class="headerlink" title="Excel单元格数值统计"></a>Excel单元格数值统计</h2><h2 id="相同数字的积木游戏"><a href="#相同数字的积木游戏" class="headerlink" title="相同数字的积木游戏"></a>相同数字的积木游戏</h2><h2 id="开放日活动"><a href="#开放日活动" class="headerlink" title="开放日活动"></a>开放日活动</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>其实题目很简单，就是设置一下 maxcapacity ，从大到小遍历即可，看每一轮消减小球个数后，能否满足条件。</p><p>二分法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="投篮大赛"><a href="#投篮大赛" class="headerlink" title="投篮大赛"></a>投篮大赛</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>你现在是一场采用特殊赛制投篮大赛的记录员。这场比赛由若干回合组成，过去几回合的得分口能会影响以后几回合的得分。<br>比赛开始时，记录是空白的。<br>你会得到一个记录操作的字符串列表 opsQ，其中ops是你需要记录的第i项操作，ops遵循下述规则:<br>。整数X-表示本回合新获得分数x<br>“+”- 表示本回合新获得的得分是前两次得分的总和<br>。“D”- 表示本回合新获得的得分是前一次得分的两倍<br>。“C”- 表示本回合没有分数，并且前一次得分无效，将其从记录中移除.<br>请你返回记录中所有得分的总和。<br>示例1:<br>输入: 52CD+<br>输出: 30<br>解释:<br>“5”-记录加5，记录现在是[5]<br>“2”-记录加2，记录现在是[5,2]<br>“C”-使前一次得分的记录无效并将其移除，记录现在是[5].<br>“D”-记录加2*5=10，记录现在是[5，10].<br>“+”-记录加5+10=15，记录现在是[5，10，15]所有得分的总和5+10+15=30</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    vector&lt;string&gt; params = <span class="built_in">split_str</span>(param_str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//四个分支，但其实有隐患</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; scores;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;params.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (params[i] == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(scores[scores.<span class="built_in">size</span>()<span class="number">-2</span>] + scores[scores.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == <span class="string">&quot;D&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(<span class="number">2</span>*scores[scores.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scores.<span class="built_in">size</span>() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            scores.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            scores.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; <span class="built_in">accumulate</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="开心消消乐"><a href="#开心消消乐" class="headerlink" title="开心消消乐"></a>开心消消乐</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>                            </div>            </details><h2 id="通信误码"><a href="#通信误码" class="headerlink" title="通信误码"></a>通信误码</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>信号传播过程中会出现一些误码，不同的数字表示不同的误码ID，取值范围为1~65535，用一个数组Q记录误码出现的情况，<br>每个误码出现的次数代表误码频度，请找出记录中包含频度最高误码的最小子 数组长度Q输入描述<br>误码总数目: 取值范围为0~255，取值为0表示没有误码的情况。误码出现频率数组: 误码ID范围为1~65535，数组长度为1~1000.输出描述<br>包含频率最高的误码最小子数组长度<br>示例1 输入输出示例仅供调试，后台判题数据一般不包含示例<br>输入<br>5<br>1 2 2 4 1<br>输出<br>2<br>说明<br>频度最高的有1和2，他们的频度均为2<br>可能的记录数组为[2,2]和[1,2,2,4,1]<br>最短的长度为2.<br>示例2 输入输出示例仅供调试，后台判题数据一般不包含示例入</p><p>7<br>1 2 2 4 2 1 1<br>输出<br>4<br>说明<br>最短的为[2,2,4,2]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string n_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, n_str);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">stoi</span>(n_str);</span><br><span class="line"></span><br><span class="line">    string param_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, param_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = <span class="built_in">split</span>(param_str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算频度最高的数字</span></span><br><span class="line">    <span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; num_count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_count.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">            num_count[nums[i]] = num_count[nums[i]] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num_count[nums[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        max_count = <span class="built_in">max</span>(max_count, num_count[nums[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; max_num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : num_count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.second == max_count) &#123;</span><br><span class="line">            max_num.<span class="built_in">insert</span>(item.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到第一次和最后一次出现位置</span></span><br><span class="line">    <span class="type">int</span> result = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : max_num) &#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[left] != i) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (nums[right] != i) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt;= right) &#123;</span><br><span class="line">            result = <span class="built_in">min</span>(result, rig</span><br><span class="line">ht - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt; result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="最大报酬"><a href="#最大报酬" class="headerlink" title="最大报酬"></a>最大报酬</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>小明每周上班都会拿到自己的工作清单，工作清单内包含n项工作，每项工作都有对应的耗时时间（单位h）和报酬,</p><p>工作的总报酬为所有已完成工作的报酬之和，那么请你帮小明安排一下工作，保证小明在指定的工作时间内工作收入最大化。</p><p><strong>输入描述</strong></p><p>输入的第一行为两个正整数T，n。</p><p>T代表工作时长（单位h，0&lt;T&lt;1000000），n代表工作数量（1&lt;n≤3000）。</p><p>接下来是n行，每行包含两个整数t，w。</p><p>t代表该工作消耗的时长（单位h，t&gt;0）,w代表该项工作的报酬。</p><p><strong>输出描述</strong></p><p>输出小明制定工作时长内工作可获得的最大报酬。</p><p><strong>输入</strong></p><p>40 3</p><p>20 10</p><p>20 20</p><p>20 5</p><p><strong>输出</strong></p><p>30</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> Cap, num;</span><br><span class="line">    cin&gt;&gt;Cap&gt;&gt;num;</span><br><span class="line">    <span class="type">int</span> weight[<span class="number">100</span>], value[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;weight[i]&gt;&gt;value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=weight[i]; j&lt;=Cap; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[num][Cap]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="机器人"><a href="#机器人" class="headerlink" title="机器人"></a>机器人</h2><h2 id="新学校选址"><a href="#新学校选址" class="headerlink" title="新学校选址"></a>新学校选址</h2><h2 id="寻找路径"><a href="#寻找路径" class="headerlink" title="寻找路径"></a>寻找路径</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>二叉树Q也可以用数组来存储，给定一个数组，树的根节点的值储存在下标1对于储存在下标n的节点，他的左子节点和右子节点分别储存在下标2n和2*n+1.并且我们用-1代表一个节点为空。<br>给定一个数组存储的二叉树，试求从根节点到最小的 叶子节点Q 的路径，路径由节点的值组<br>成。<br>输入描述<br>输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分割。注意第一个元素即为根节点的值，即数组的第n元素对应下标n。下标0在树的表示中没有使用所以我们省略了。输入的树最多为7层。<br>输出描述<br>输出从根节点到最小叶子节点的路径上各个节点的值由空格分割用例保证最小叶子节点只有一个示例一<br>输入<br>3 5 7 -1 -1 2 4<br>输出<br>3 7 2<br>示例二<br>输入<br>5 9 8-1 -1 7 -1 -1-1-1 -1 6<br>输出<br>5 8 7 6</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">split</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found)));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(params_str));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">split_str</span><span class="params">(string params_str)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; p;</span><br><span class="line">    <span class="keyword">while</span> (params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>) != string::npos) &#123;</span><br><span class="line">        <span class="type">int</span> found = params_str.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        p.<span class="built_in">push_back</span>(params_str.<span class="built_in">substr</span>(<span class="number">0</span>, found));</span><br><span class="line">        params_str = params_str.<span class="built_in">substr</span>(found + <span class="number">1</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    p.<span class="built_in">push_back</span>(params_str);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string operation_str;</span><br><span class="line">    <span class="built_in">getline</span>(cin, operation_str);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nodes = <span class="built_in">split</span>(operation_str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minValue = *<span class="built_in">max_element</span>(nodes.<span class="built_in">begin</span>(), nodes.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> minPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//找最小叶子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nodes.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i] != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i * <span class="number">2</span> + <span class="number">1</span> &lt;= nodes.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nodes[i * <span class="number">2</span> + <span class="number">1</span>] != <span class="number">-1</span>) || (i * <span class="number">2</span> + <span class="number">2</span> &lt;= nodes.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nodes[i * <span class="number">2</span> + <span class="number">2</span>] != <span class="number">-1</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minValue &gt; nodes[i]) &#123;</span><br><span class="line">                minValue = nodes[i];</span><br><span class="line">                minPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往上遍历</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    path.<span class="built_in">push_back</span>(minValue);</span><br><span class="line">    <span class="keyword">while</span> (minPos &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nodes[(minPos<span class="number">-1</span>)/<span class="number">2</span>]);</span><br><span class="line">        minPos = (minPos<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = path.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        cout &lt;&lt; path[i];</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p>现有一个CPU和一些任务需要处理，已提前获知每个任务的任务ID、优先级、所需执行时间和到达时间。CPU同时只能运行一个任务，请编写一个任务调度程序，采用“可抢占优先权调度”调度算法进行任务调度，规则如下：</p><p>1：如果一个任务到来时，CPU是空闲的，则CPU可以运行该任务直到任务执行完毕。但是如果运行中有一个更高优先级的任务到来，则CPU必须暂停当前任务去运行这个优先级更高的任务；</p><p>2：如果一个任务到来时，CPU正在运行一个比他优先级更高的任务时，信道大的任务必须等待；</p><p>3：当CPU空闲时，如果还有任务在等待，CPU会从这些任务中选择一个优先级最高的任务执行，相同优先级的任务选择到达时间最早的任务。</p><p>输入描述</p><p>输入有若干行，每一行有四个数字（均小于10^8）,分别为任务ID，任务优先级，执行时间和到达时间。每个任务的任务ID不同，优先级数字越大优先级越高，并且相同优先级的任务不会同时到达。</p><p>输入的任务已按照到达时间从小到大排序，并且保证在任何时间，处于等待的任务不超过10000个。</p><p><strong>输出描述</strong></p><p>按照任务执行结束的顺序，</p><p>示例一</p><p><strong>输入</strong></p><p>1 3 5 1</p><p>2 1 5 10</p><p>3 2 7 12</p><p>4 3 2 20</p><p>5 4 9 21</p><p>6 4 2 22</p><p><strong>输出</strong></p><p>1 6</p><p>3 19</p><p>5 30</p><p>6 32</p><p>4 33</p><p>2 35</p>              </div>            </details>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/21/hello-world/"/>
      <url>/2023/05/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无重复的最长字串</title>
      <link href="/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
      <url>/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>遍历字符串，找每个字符为首的最长子串。时间复杂度为O(n)*O(以首字符开始的字符串)，寻找首字符开始的字符串时间复杂度O(n^2)，总的时间复杂度为O(n^3)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//要考虑到空串的情况</span></span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i,j);<span class="comment">// 子串范围s[i,j)</span></span><br><span class="line">                <span class="keyword">if</span>(str.indexOf(s.charAt(j)) &lt; <span class="number">0</span>)&#123;<span class="comment">//indexOf也是O(n)的方法，所以总的时间复杂度时O(n^3)</span></span><br><span class="line">                    length ++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(length&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h2><p>用哈希表，可以减少找每个字符为首的最长子串的时间，那么就可以从最初的O(n^2)降低到O(n),总的时间复杂度就为O(n)*O(n)=0(n^2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length;<span class="comment">// 要考虑到空串的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(s.charAt(j))==<span class="literal">false</span>)&#123;</span><br><span class="line">                    length++;</span><br><span class="line">                    map.put(s.charAt(j),<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxLength&lt;length)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>万万没想到，本题的最佳时间复杂度竟然是O(n)，算法原理如下：<br>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。<br>我们不妨以示例一中的字符串<code>abcabcbb</code> 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><p>以<b>(a)bcabcbb</b>开始的最长字符串为<b>(abc)abcbb</b><br>以<strong>a(b)cabcbb</strong>开始的最长字符串为<strong>a(bca)bcbb</strong><br>以<strong>ab(c)abcbb</strong>开始的最长字符串为<strong>ab(cab)cbb</strong><br>以<strong>abc(a)bcbb</strong>开始的最长字符串为<strong>abc(abc)bb</strong><br>以<strong>abca(b)cbb</strong>开始的最长字符串为<strong>abca(bc)bb</strong><br>以<strong>abcab(c)bb</strong>开始的最长字符串为<strong>abcab(cb)b</strong><br>以<strong>abcabc(b)b</strong>开始的最长字符串为<strong>abcabc(b)b</strong><br>以<b>abcabcb(b)</b>开始的最长字符串为<b>abcabcb(b)</b></p><p>发现了子串的结束位置是非递减的，这里的原因在于，假设第k个字符作为起始位置，rk为终止位置。那么当我们选择第k+1个字符作为起始位置时，首先k+1到rk的位置显然是不重复的，并且我们还可以尝试继续增大rk(不必回到k+1的位置判断)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk &lt; n &amp;&amp; !occ.contains(s.charAt(rk ))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk-1 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234abc&quot;</span>;</span><br><span class="line"><span class="comment">// substring 左闭右开</span></span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 123 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf 可以求字符位置，也可以求字串位置</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">s.indexOf(<span class="string">&quot;23&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt(i) 求指定位置的字符    </span></span><br><span class="line">s.charAt(<span class="number">0</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line">occ.remove(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">occ.add(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 哈希集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><span id="more"></span><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><a href="https://leetcode.cn/problems/two-sum/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    ans[<span class="number">0</span>]=i;</span><br><span class="line">                    ans[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h3><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N)降低到O(1)。</p><p><strong>注意：</strong></p><p>创建一个哈希表，对于每一个 <code>x</code>，我们<strong>首先</strong>查询哈希表中是否存在 <code>target - x</code>，<strong>然后</strong>将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Java-Map接口"><a href="#Java-Map接口" class="headerlink" title="Java Map接口"></a>Java Map接口</h3><p>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的初始化</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//不限定键和值的类型</span></span><br><span class="line">Map&lt;Integer,Integer&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsKey</span></span><br><span class="line">m1.containsKey(<span class="number">3</span>); <span class="comment">//含有key(3)，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">m1.get(<span class="number">3</span>); <span class="comment">//返回指定键所映射的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line">m1.put(<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">//将键值对添加到表中</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>偶的第一篇博客就从markdown语法开始吧，主要参考的是<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a>。从中摘录了可能最常用的语法，并结合其他资源整合而成，那就让我们开始md之旅吧！。<br><span id="more"></span></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a name="Name">标题</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br></pre></td></tr></table></figure><h2 id="段落样式"><a href="#段落样式" class="headerlink" title="段落样式"></a>段落样式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">**粗体文本**</span><br><span class="line">***斜粗体文本***</span><br></pre></td></tr></table></figure><p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>斜粗体文本</em></strong></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~~Hell World~~</span><br></pre></td></tr></table></figure><p><del>Hell World</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><p><u>带下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[^名称]</span><br><span class="line">[^名称]: 解释名称</span><br><span class="line">例：</span><br><span class="line">我用Hexo[^<span class="number">1</span>]搭建了第一个博客</span><br><span class="line">[^<span class="number">1</span>]:一个很好用的博客框架</span><br></pre></td></tr></table></figure><p>我用Hexo<sup><a href="#fn_1" id="reffn_1">1</a></sup>搭建了第一个博客</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项：</span><br><span class="line">    * 第一项嵌套的第一个元素</span><br><span class="line">    * 第一项嵌套的第二个元素</span><br><span class="line"><span class="number">2.</span> 第二项：</span><br><span class="line">    * 第二项嵌套的第一个元素</span><br><span class="line">    * 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><ol><li><p>第一项：</p><ul><li><p>第一项嵌套的第一个元素</p></li><li><p>第一项嵌套的第二个元素</p></li></ul></li><li><p>第二项：</p><ul><li><p>第二项嵌套的第一个元素</p></li><li><p>第二项嵌套的第二个元素</p></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`printf()`</span><br></pre></td></tr></table></figure><h3 id="一段代码"><a href="#一段代码" class="headerlink" title="一段代码"></a>一段代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```加回车</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> [菜鸟教程](https://www.runoob.com)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> &lt;https://www.runoob.com&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> [百度][<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]:https:www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com">菜鸟教程</a></p><p><a href="https://www.runoob.com">https://www.runoob.com</a></p><p><a href="https:www.baidu.com">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png )</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png <span class="string">&quot;标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> [RUNOOB][<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]:http://static.runoob.com/images/runoob-logo.png </span><br></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB" title="标题"></p><p><a href="http://static.runoob.com/images/runoob-logo.png">RUNOOB</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="补充样式"><a href="#补充样式" class="headerlink" title="补充样式"></a>补充样式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;font size=<span class="number">5</span>&gt;&lt;/font&gt; 字体大小</span><br><span class="line">&lt;a style=<span class="string">&quot;color:black&quot;</span>&gt;&lt;/a&gt; 字体颜色</span><br><span class="line">&lt;a style=<span class="string">&quot;text-decoration:none&quot;</span>&gt;&lt;/a&gt; 取消链接下划线</span><br></pre></td></tr></table></figure><h3 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#Name&quot;</span>&gt;&lt;/a&gt; 跳转的起点</span><br><span class="line">&lt;a name=<span class="string">&quot;Name&quot;</span>&gt;&lt;/a&gt; 跳转的终点</span><br></pre></td></tr></table></figure><p><a href="#Name">跳转的起点</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
