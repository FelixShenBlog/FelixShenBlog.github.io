<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单调栈</title>
      <link href="/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
      <url>/2023/05/27/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739.每日温度"></a>739.每日温度</h2><p><a href="https://leetcode.cn/problems/daily-temperatures/">题目链接</a></p><p>题意概括：找下一个比当前元素大的数</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><p>栈存的是下标</p></li><li><p>如果每次存的都是比栈顶小的元素，找的就是比当前元素大的数</p></li><li><p>如果每次存的都是比栈顶大的元素，找的就是比当前元素小的数</p></li><li><p>单调栈记录的是遍历过的元素，栈顶和当前元素对比，再进行求值的过程</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 代码随想录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经</title>
      <link href="/2023/05/27/%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/05/27/%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.哈希冲突</strong></p><ul><li><p>定义：在哈希表中，不同的键经过哈希函数计算后得到相同的哈希值，导致它们应该存储在哈希表的同一个位置上</p></li><li><p>链地址法（Chaining）：使用链表或其他数据结构，在哈希表的每个位置上维护一个链表，将哈希冲突的元素存储在同一个位置的链表中。当需要查找、插入或删除元素时，遍历对应位置的链表即可。这种方法简单且易于实现，但可能会造成额外的存储空间开销和链表的遍历操作。</p></li><li><p>开放地址法（Open Addressing）：当发生哈希冲突时，通过一定的规则在哈希表的其他位置寻找空槽来存储冲突元素。常见的开放地址法有线性探测、二次探测、双重哈希等。这种方法不需要额外的数据结构存储冲突元素，节省了存储空间，但可能导致聚集现象，即连续的冲突元素会聚集在一起，影响性能。</p></li><li><p>建立更好的哈希函数：改进哈希函数的设计，减少哈希冲突的发生。好的哈希函数能够尽可能地将键均匀地分布在哈希表的各个位置上，减少冲突的概率。通常，好的哈希函数应该具有均匀性、雪崩效应（即输入的微小变化会导致输出的巨大变化）等特性。</p></li><li><p>调整哈希表的负载因子：负载因子是指哈希表中已存储元素的数量与哈希表大小的比值。当负载因子过高时，哈希冲突的概率会增加。通过动态调整哈希表的大小，可以控制负载因子在一个合理的范围内，减少哈希冲突的发生。</p></li></ul>              </div>            </details><h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.C++内存分布：</strong></p><ul><li><p>栈（stack）：栈是用于存储局部变量和函数调用信息的内存区域。它的分配和释放是由编译器自动完成的，遵循后进先出（LIFO）的原则。每当函数被调用时，函数的局部变量和参数被压入栈中，并在函数返回时被自动弹出。栈的大小通常是有限的，一般在编译时确定，超出栈大小的分配会导致栈溢出。</p></li><li><p>堆（heap）：堆是用于动态分配内存的区域。在堆上分配的内存需要手动进行管理，包括分配和释放。通常使用<code>new</code>操作符来分配内存，使用<code>delete</code>操作符来释放内存。堆上分配的内存在不需要时需要手动释放，否则可能导致内存泄漏。堆的大小一般比栈大，并且在运行时动态增长。</p></li><li><p>静态存储区（static storage area）：静态存储区用于存储全局变量、静态变量和静态常量。它在程序开始执行时被分配，并在程序结束时被释放。静态存储区的大小在编译时确定，存储区域在整个程序的执行期间都存在。</p></li><li><p>常量区（Constant Storage）：常量区用于存储常量数据，如字符串常量。这些数据在程序执行期间是只读的，无法修改。代码区（存储程序的机器指令）</p></li><li><p>程序代码区（Code Area）：程序代码区存储程序的指令代码。这部分内存是只读的，存储着程序的可执行指令。</p></li></ul><p><strong>2.什么是智能指针？为什么在C++中使用智能指针？</strong></p><p>智能指针是C++中的一种包装类，用于管理动态分配的对象的生命周期。它们提供了自动化的内存管理，可以避免内存泄漏和悬挂指针的问题。智能指针通过在对象上使用引用计数或其他技术来跟踪对象的引用，并在引用计数为零时自动释放对象的内存。</p><p><strong>3.C++中有哪些类型的智能指针？请简要描述它们的区别</strong></p><p>C++中有三种常用的智能指针类型：unique_ptr、shared_ptr和weak_ptr。</p><ul><li><p>unique_ptr：独占所有权的智能指针，不能共享所有权。它使用独占式所有权语义，确保只有一个指针可以访问所拥有的对象。</p></li><li><p>shared_ptr：允许多个指针共享同一个对象的智能指针。它使用引用计数来跟踪对象的引用，当引用计数为零时自动释放对象。</p></li><li><p>weak_ptr：用于解决shared_ptr可能引起的循环引用问题。weak_ptr可以观测shared_ptr，但不会增加引用计数，也不能直接访问所指向的对象。</p></li></ul><p><strong>3.如何创建和使用智能指针？</strong></p><p>可以使用<code>std::make_unique</code>、<code>std::make_shared</code>和<code>std::make_weak</code>等函数来创建智能指针。例如，使用<code>std::make_unique</code>创建unique_ptr。</p><p><strong>4.智能指针有什么缺点？</strong></p><p>答案：尽管智能指针提供了方便和安全的内存管理，但也存在一些缺点。其中一个主要的缺点是智能指针可能引起循环引用的问题，导致内存泄漏。为了避免这种情况，应该使用weak_ptr来打破循环引用。此外，智能指针相对于裸指针有一些额外的开销，包括引用计数的维护等。</p><p><a href="https://blog.csdn.net/qq_26538113/article/details/125796865">智能指针循环引用问题</a></p><p><strong>5.C++多态</strong></p><ul><li><p>什么是多态性（Polymorphism）：多态性是面向对象编程中的一个重要特性，它允许使用基类的指针或引用来访问派生类对象，实现代码的灵活性和可扩展性。</p></li><li><p>多态性的实现方式：两种主要的实现方式：静态多态性（静态绑定）和动态多态性（动态绑定）。静态多态性通过函数重载和模板实现，而动态多态性通过虚函数和继承实现。</p></li><li><p>虚函数和纯虚函数：虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，它可以在派生类中被重写，实现动态绑定。纯虚函数是在基类中声明并使用<code>virtual</code>关键字修饰的函数，但没有提供具体的实现，需要在派生类中实现。</p></li><li><p>虚函数表（Virtual Function Table）：虚函数表是一个特殊的数据结构，用于实现动态多态性。每个包含虚函数的类都有自己的虚函数表，该表存储了类的虚函数的地址，使得在运行时能够正确调用派生类的虚函数。</p></li><li><p>虚析构函数：虚析构函数的作用是确保在删除指向派生类对象的基类指针时，能够正确调用派生类的析构函数，防止内存泄漏。</p></li><li><p>多态性的优点和应用场景：多态性提供了代码的灵活性、可扩展性和可维护性。它使得代码可以更容易地适应变化和扩展，同时也提高了代码的可读性和重用性。</p></li><li><p>如何阻止派生类重写虚函数：可以在基类中使用<code>final</code>关键字来修饰虚函数，以阻止派生类对该虚函数进行重写。被标记为<code>final</code>的虚函数在派生类中不能被重写。</p></li></ul>              </div>            </details><h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.IO复用模型</strong></p><p>IO复用模型是一种用于实现高效的并发I/O操作的技术，它允许一个线程同时监视多个I/O事件，并在有事件发生时进行处理，避免了传统的阻塞式I/O中的线程阻塞和轮询等待。</p><p><strong>2.socket编程的流程</strong></p><ol><li><p>创建Socket：使用<code>socket()</code>系统调用创建一个Socket对象。需要指定网络协议、Socket类型和协议族。</p></li><li><p>绑定Socket：使用<code>bind()</code>系统调用将Socket绑定到一个特定的IP地址和端口号上。这一步是可选的，如果不绑定，操作系统会自动为Socket分配一个可用的端口。</p></li><li><p>监听连接请求（仅适用于服务器）：使用<code>listen()</code>系统调用将Socket设置为监听状态，以等待客户端的连接请求。服务器Socket需要指定可以同时处理的最大连接数。</p></li><li><p>接受连接（仅适用于服务器）：使用<code>accept()</code>系统调用接受客户端的连接请求，返回一个新的Socket对象用于与客户端进行通信。服务器Socket会一直阻塞，直到有客户端连接进来。</p></li><li><p>连接服务器（仅适用于客户端）：使用<code>connect()</code>系统调用连接到服务器的Socket。需要指定服务器的IP地址和端口号。</p></li><li><p>发送和接收数据：使用<code>send()</code>和<code>recv()</code>系统调用进行数据的发送和接收。可以根据具体需求进行数据的分割、组装和处理。</p></li><li><p>关闭连接：使用<code>close()</code>系统调用关闭Socket连接，释放相关资源。</p></li></ol><p><strong>3.TCP</strong></p><ul><li><p>TCP的基本概念：TCP是一种可靠的、面向连接的传输协议，它提供了可靠的数据传输、流量控制、拥塞控制和错误恢复机制等功能。</p></li><li><p>三次握手：包括客户端向服务器发送SYN（同步）请求，服务器回复SYN-ACK（同步-应答）确认，最后客户端发送ACK（应答）确认。</p></li><li><p>四次挥手：客户端或服务器发送FIN（结束）请求，对方回复ACK确认，然后再发送FIN请求，对方再次回复ACK确认</p></li></ul>              </div>            </details><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>              <p><strong>1.死锁的必要条件</strong></p><ul><li><p>互斥条件（Mutual Exclusion）</p></li><li><p>不可剥夺条件（No Preemption）</p></li><li><p>请求和保持条件（Hold and Wait)</p></li><li><p>循环等待条件（Circular Wait）</p></li></ul><p><strong>2.死锁的破坏</strong></p><ul><li><p>预防死锁（Deadlock Prevention）：</p><ul><li><p>互斥条件破坏：将某些资源设计为可共享的，多个进程可以同时访问。</p></li><li><p>请求与保持条件破坏：进程在申请资源时，要求一次性申请所需要的所有资源，而不是逐个申请。</p></li><li><p>不可剥夺条件破坏：允许操作系统在必要时剥夺进程已经占有的资源。</p></li><li><p>循环等待条件破坏：对系统中的资源进行全局排序，并规定进程按照序号递增的顺序申请资源。</p></li></ul></li><li><p>避免死锁（Deadlock Avoidance）：银行家算法（Banker’s Algorithm）和资源分配图（Resource Allocation Graph）。</p></li><li><p>检测和恢复死锁（Deadlock Detection and Recovery）：常见的死锁检测算法有图论算法、资源分配图算法等。恢复死锁可以采取一些策略，如终止某个或多个进程、抢占资源、回滚进程等。</p></li><li><p>忽略死锁（Deadlock Ignorance）：这种方法适用于死锁发生的概率极低，或者死锁发生后对系统造成的影响较小的场景。</p></li></ul><p><strong>3.进程通信方式</strong></p><ol><li><p>共享内存（Shared Memory）：多个进程可以访问和操作同一块共享内存区域，从而实现数据的共享和交换。进程可以直接读写内存，无需进行复制和传输。共享内存需要使用同步机制（如信号量）来避免多个进程同时访问导致的竞态条件。</p></li><li><p>管道（Pipe）：管道是一种半双工的通信方式，用于具有亲缘关系的进程间通信。一个进程可以将输出写入管道，另一个进程则可以从管道读取输入。管道可以是匿名管道（在进程创建时自动创建）或命名管道（通过文件系统中的路径名创建）。</p></li><li><p>命名管道（Named Pipe）：命名管道允许不具有亲缘关系的进程进行通信。与匿名管道不同，命名管道在文件系统中有一个关联的路径名，进程可以通过打开该路径名来进行通信。</p></li><li><p>消息队列（Message Queue）：消息队列是一种可以实现进程间异步通信的方式。进程可以将消息发送到队列中，其他进程则可以从队列中接收这些消息。消息队列允许不同进程之间以先进先出的顺序进行通信。</p></li><li><p>信号量（Semaphore）：信号量是一种用于进程间同步的机制。它可以用来保护临界区，限制资源的访问以及实现进程间的互斥和同步操作。进程可以通过等待（wait）和释放（signal）信号量来实现对共享资源的访问控制。</p></li><li><p>套接字（Socket）：套接字是一种用于网络通信的接口。它允许不同主机上的进程进行通信，实现了跨网络的进程间通信。</p></li><li><p>文件（File）：进程可以通过读写文件来进行通信。一个进程可以将数据写入文件，另一个进程则可以从文件中读取这些数据。</p></li></ol><p><strong>进程和线程的区别</strong></p><ul><li><p>定义：进程是程序的执行实例，是资源分配和调度的基本单位。它拥有独立的内存空间，包含程序代码、数据和执行状态。线程是进程内的一个执行单元，是进程的实际执行者。线程共享进程的内存空间和资源，可以看作是进程内的子任务。</p></li><li><p>资源占用：每个进程都有独立的内存空间和资源，包括文件描述符、环境变量、信号处理器等。不同进程之间的资源是相互隔离的，需要通过进程间通信机制来实现数据交换。而线程共享进程的内存空间和资源，可以直接读取和修改进程的数据。</p></li><li><p>切换开销：进程之间切换的开销较大，因为需要保存和恢复整个进程的状态信息，包括程序计数器、寄存器状态、内存映射等。线程切换的开销较小，因为线程共享进程的内存空间，只需要保存和恢复线程私有的寄存器状态即可。</p></li><li><p>通信和同步：进程间通信（IPC）是相对复杂的，需要使用进程间通信机制，如管道、消息队列、共享内存等。线程之间通信和同步较为简单，可以直接读写共享的内存空间，也可以使用线程间同步机制，如互斥锁、条件变量等，来保证数据的一致性和互斥访问。</p></li><li><p>安全性：由于每个进程有独立的内存空间，一个进程的崩溃不会影响其他进程。而在多线程编程中，一个线程的错误可能导致整个进程崩溃。</p></li></ul>              </div>            </details><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><details class="folding-tag" blue><summary> 展开查看 </summary>              <div class='content'>                            </div>            </details><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 面试八股文 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++11-右值引用</title>
      <link href="/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>/2023/05/26/C-11-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>lvalue: 可以取地址</p><p>rvalue: 不可取地址</p><p>引用就是别名</p><p>只能通过左值去初始化左值引用，右值去初始化右值引用</p><p>常量的左值引用是万能的引用类型，可以用左值、左值引用、常量的右值引用</p><p>右值引用：延长临时变量的时间， A a=临时</p><p>左值引用：用来函数传递参数</p><p>移动构造函数-复用其他对象中的资源(堆内存)（浅拷贝+其他对象指针指向空）</p><p>右值引用：复用匿名对象所有资源</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为OD题库</title>
      <link href="/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/"/>
      <url>/2023/05/23/%E5%8D%8E%E4%B8%BAOD%E9%A2%98%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1162-地图分析"><a href="#1162-地图分析" class="headerlink" title="1162.地图分析"></a>1162.地图分析</h3><details class="folding-tag" blue><summary> 查看代码测试 </summary>              <div class='content'>              <p><a href="https://leetcode.cn/problems/as-far-from-land-as-possible/description/">题目链接</a></p>              </div>            </details>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/21/hello-world/"/>
      <url>/2023/05/21/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>无重复的最长字串</title>
      <link href="/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/"/>
      <url>/2022/06/20/%E6%97%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%97%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><span id="more"></span><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>遍历字符串，找每个字符为首的最长子串。时间复杂度为O(n)*O(以首字符开始的字符串)，寻找首字符开始的字符串时间复杂度O(n^2)，总的时间复杂度为O(n^3)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//要考虑到空串的情况</span></span><br><span class="line">        <span class="type">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i,j);<span class="comment">// 子串范围s[i,j)</span></span><br><span class="line">                <span class="keyword">if</span>(str.indexOf(s.charAt(j)) &lt; <span class="number">0</span>)&#123;<span class="comment">//indexOf也是O(n)的方法，所以总的时间复杂度时O(n^3)</span></span><br><span class="line">                    length ++;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(length&gt;maxLength)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希解法"><a href="#哈希解法" class="headerlink" title="哈希解法"></a>哈希解法</h2><p>用哈希表，可以减少找每个字符为首的最长子串的时间，那么就可以从最初的O(n^2)降低到O(n),总的时间复杂度就为O(n)*O(n)=0(n^2)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> length;<span class="comment">// 要考虑到空串的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++)&#123;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">            HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;s.length(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(s.charAt(j))==<span class="literal">false</span>)&#123;</span><br><span class="line">                    length++;</span><br><span class="line">                    map.put(s.charAt(j),<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxLength&lt;length)&#123;</span><br><span class="line">                maxLength = length;</span><br><span class="line">            &#125;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>万万没想到，本题的最佳时间复杂度竟然是O(n)，算法原理如下：<br>我们先用一个例子考虑如何在较优的时间复杂度内通过本题。<br>我们不妨以示例一中的字符串<code>abcabcbb</code> 为例，找出从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。对于示例一中的字符串，我们列举出这些结果，其中括号中表示选中的字符以及最长的字符串：</p><p>以<b>(a)bcabcbb</b>开始的最长字符串为<b>(abc)abcbb</b><br>以<strong>a(b)cabcbb</strong>开始的最长字符串为<strong>a(bca)bcbb</strong><br>以<strong>ab(c)abcbb</strong>开始的最长字符串为<strong>ab(cab)cbb</strong><br>以<strong>abc(a)bcbb</strong>开始的最长字符串为<strong>abc(abc)bb</strong><br>以<strong>abca(b)cbb</strong>开始的最长字符串为<strong>abca(bc)bb</strong><br>以<strong>abcab(c)bb</strong>开始的最长字符串为<strong>abcab(cb)b</strong><br>以<strong>abcabc(b)b</strong>开始的最长字符串为<strong>abcabc(b)b</strong><br>以<b>abcabcb(b)</b>开始的最长字符串为<b>abcabcb(b)</b></p><p>发现了子串的结束位置是非递减的，这里的原因在于，假设第k个字符作为起始位置，rk为终止位置。那么当我们选择第k+1个字符作为起始位置时，首先k+1到rk的位置显然是不重复的，并且我们还可以尝试继续增大rk(不必回到k+1的位置判断)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rk</span> <span class="operator">=</span> <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk &lt; n &amp;&amp; !occ.contains(s.charAt(rk ))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk-1 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="String方法"><a href="#String方法" class="headerlink" title="String方法"></a>String方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234abc&quot;</span>;</span><br><span class="line"><span class="comment">// substring 左闭右开</span></span><br><span class="line">s.substring(<span class="number">0</span>,<span class="number">3</span>); <span class="comment">// 123 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// indexOf 可以求字符位置，也可以求字串位置</span></span><br><span class="line">s.indexOf(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 4</span></span><br><span class="line">s.indexOf(<span class="string">&quot;23&quot;</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// charAt(i) 求指定位置的字符    </span></span><br><span class="line">s.charAt(<span class="number">0</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="哈希集合"><a href="#哈希集合" class="headerlink" title="哈希集合"></a>哈希集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Set&lt;Character&gt; occ = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line"><span class="comment">// 移除元素</span></span><br><span class="line">occ.remove(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">occ.add(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 哈希集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/06/20/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><span id="more"></span><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p><a href="https://leetcode.cn/problems/two-sum/">题目链接</a></p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双重循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j&lt; nums.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                    ans[<span class="number">0</span>]=i;</span><br><span class="line">                    ans[<span class="number">1</span>]=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="思路和算法"><a href="#思路和算法" class="headerlink" title="思路和算法"></a>思路和算法</h3><p>注意到方法一的时间复杂度较高的原因是寻找 <code>target - x</code> 的时间复杂度过高。使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O(N)降低到O(1)。</p><p><strong>注意：</strong></p><p>创建一个哈希表，对于每一个 <code>x</code>，我们<strong>首先</strong>查询哈希表中是否存在 <code>target - x</code>，<strong>然后</strong>将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; hashTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hashTable.containsKey(target-nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashTable.get(target-nums[i]),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashTable.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="Java-Map接口"><a href="#Java-Map接口" class="headerlink" title="Java Map接口"></a>Java Map接口</h3><p>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的初始化</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">//不限定键和值的类型</span></span><br><span class="line">Map&lt;Integer,Integer&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// containsKey</span></span><br><span class="line">m1.containsKey(<span class="number">3</span>); <span class="comment">//含有key(3)，返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line">m1.get(<span class="number">3</span>); <span class="comment">//返回指定键所映射的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line">m1.put(<span class="string">&quot;name&quot;</span>,<span class="string">&#x27;Mike&#x27;</span>) <span class="comment">//将键值对添加到表中</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode100 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode100 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown常用语法</title>
      <link href="/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/06/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>偶的第一篇博客就从markdown语法开始吧，主要参考的是<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程</a>。从中摘录了可能最常用的语法，并结合其他资源整合而成，那就让我们开始md之旅吧！。<br><span id="more"></span></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a><a name="Name">标题</a></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br></pre></td></tr></table></figure><h2 id="段落样式"><a href="#段落样式" class="headerlink" title="段落样式"></a>段落样式</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">**粗体文本**</span><br><span class="line">***斜粗体文本***</span><br></pre></td></tr></table></figure><p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>斜粗体文本</em></strong></p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><hr><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">~~Hell World~~</span><br></pre></td></tr></table></figure><p><del>Hell World</del></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;带下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><p><u>带下划线文本</u></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[^名称]</span><br><span class="line">[^名称]: 解释名称</span><br><span class="line">例：</span><br><span class="line">我用Hexo[^<span class="number">1</span>]搭建了第一个博客</span><br><span class="line">[^<span class="number">1</span>]:一个很好用的博客框架</span><br></pre></td></tr></table></figure><p>我用Hexo<sup><a href="#fn_1" id="reffn_1">1</a></sup>搭建了第一个博客</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br></pre></td></tr></table></figure><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项</span><br><span class="line"><span class="number">2.</span> 第二项</span><br><span class="line"><span class="number">3.</span> 第三项</span><br></pre></td></tr></table></figure><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 第一项：</span><br><span class="line">    * 第一项嵌套的第一个元素</span><br><span class="line">    * 第一项嵌套的第二个元素</span><br><span class="line"><span class="number">2.</span> 第二项：</span><br><span class="line">    * 第二项嵌套的第一个元素</span><br><span class="line">    * 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><ol><li><p>第一项：</p><ul><li><p>第一项嵌套的第一个元素</p></li><li><p>第一项嵌套的第二个元素</p></li></ul></li><li><p>第二项：</p><ul><li><p>第二项嵌套的第一个元素</p></li><li><p>第二项嵌套的第二个元素</p></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`printf()`</span><br></pre></td></tr></table></figure><h3 id="一段代码"><a href="#一段代码" class="headerlink" title="一段代码"></a>一段代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">```加回车</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> [菜鸟教程](https://www.runoob.com)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> &lt;https://www.runoob.com&gt;</span><br><span class="line">    </span><br><span class="line"><span class="number">3.</span> [百度][<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>]:https:www.baidu.com</span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com">菜鸟教程</a></p><p><a href="https://www.runoob.com">https://www.runoob.com</a></p><p><a href="https:www.baidu.com">百度</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png )</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> ![RUNOOB](http://static.runoob.com/images/runoob-logo.png <span class="string">&quot;标题&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> [RUNOOB][<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]:http://static.runoob.com/images/runoob-logo.png </span><br></pre></td></tr></table></figure><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB"></p><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB" title="标题"></p><p><a href="http://static.runoob.com/images/runoob-logo.png">RUNOOB</a></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="补充样式"><a href="#补充样式" class="headerlink" title="补充样式"></a>补充样式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;font size=<span class="number">5</span>&gt;&lt;/font&gt; 字体大小</span><br><span class="line">&lt;a style=<span class="string">&quot;color:black&quot;</span>&gt;&lt;/a&gt; 字体颜色</span><br><span class="line">&lt;a style=<span class="string">&quot;text-decoration:none&quot;</span>&gt;&lt;/a&gt; 取消链接下划线</span><br></pre></td></tr></table></figure><h3 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;#Name&quot;</span>&gt;&lt;/a&gt; 跳转的起点</span><br><span class="line">&lt;a name=<span class="string">&quot;Name&quot;</span>&gt;&lt;/a&gt; 跳转的终点</span><br></pre></td></tr></table></figure><p><a href="#Name">跳转的起点</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
